<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoirÃ© Hypercube Codex - Advanced Lattice Animation</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .control-panel { 
            position: fixed; top: 20px; left: 20px; 
            background: rgba(0,0,0,0.8); padding: 20px; 
            border: 2px solid #00ffff; color: #00ffff; 
            border-radius: 10px; backdrop-filter: blur(15px);
            z-index: 100; max-width: 300px;
        }
        .slider-group { margin: 15px 0; }
        .slider-label { margin-bottom: 8px; font-size: 14px; }
        input[type="range"] { width: 100%; }
        .preset-btn { 
            background: rgba(255,0,255,0.2); border: 1px solid #ff00ff; 
            color: #ff00ff; padding: 8px 12px; margin: 5px 5px 5px 0; 
            cursor: pointer; border-radius: 5px; font-size: 12px;
        }
        .preset-btn:hover { 
            background: rgba(255,0,255,0.4); box-shadow: 0 0 10px #ff00ff; 
        }
        .toggle-btn {
            background: rgba(255,255,0,0.2); border: 1px solid #ffff00;
            color: #ffff00; padding: 6px 10px; margin: 3px;
            cursor: pointer; border-radius: 3px; font-size: 11px;
        }
        .toggle-btn.active {
            background: rgba(255,255,0,0.4); box-shadow: 0 0 8px #ffff00;
        }
        .export-group {
            margin-top: 18px;
            padding-top: 12px;
            border-top: 1px solid rgba(0,255,255,0.2);
        }
        .export-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .export-btn {
            flex: 1 1 120px;
            min-height: 36px;
            background: linear-gradient(135deg, rgba(0,255,255,0.15), rgba(255,0,255,0.15));
            border: 1px solid rgba(0,255,255,0.4);
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .export-btn:hover {
            background: linear-gradient(135deg, rgba(0,255,255,0.35), rgba(255,0,255,0.35));
            box-shadow: 0 0 12px rgba(0,255,255,0.4);
        }
        .export-meta {
            font-size: 10px;
            opacity: 0.75;
            margin-top: 6px;
            line-height: 1.4;
        }
        .evolution-dock {
            margin-top: 18px;
            padding-top: 14px;
            border-top: 1px solid rgba(255,0,255,0.25);
        }
        .evolution-dock h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            letter-spacing: 0.08em;
        }
        .evolution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
        }
        .evolution-card {
            background: linear-gradient(135deg, rgba(0,0,0,0.45), rgba(40,0,40,0.65));
            border: 1px solid rgba(255,0,255,0.35);
            border-radius: 8px;
            padding: 8px;
            font-size: 11px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: transform 0.2s ease, border 0.2s ease;
        }
        .evolution-card:hover {
            transform: translateY(-2px);
            border-color: rgba(255,0,255,0.6);
            box-shadow: 0 0 12px rgba(255,0,255,0.35);
        }
        .evolution-card.active {
            border-color: rgba(255,255,0,0.8);
            box-shadow: 0 0 16px rgba(255,255,0,0.45);
        }
        .evolution-card strong {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #ffff00;
            letter-spacing: 0.05em;
        }
        .autopilot-btn {
            margin-top: 10px;
            width: 100%;
            background: rgba(255,255,0,0.2);
            border: 1px solid rgba(255,255,0,0.6);
            color: #ffff00;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s ease;
        }
        .autopilot-btn:hover {
            background: rgba(255,255,0,0.35);
            box-shadow: 0 0 10px rgba(255,255,0,0.35);
        }
        .toast {
            position: fixed;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: #00ffff;
            padding: 12px 20px;
            border: 1px solid rgba(0,255,255,0.5);
            border-radius: 8px;
            font-size: 12px;
            letter-spacing: 0.04em;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }
        .toast.show {
            opacity: 1;
        }
        .status {
            position: fixed; bottom: 20px; right: 20px;
            color: #00ffff; font-size: 12px; text-align: right;
        }
        .timeline-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 260px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(0,255,255,0.35);
            border-radius: 12px;
            padding: 16px;
            color: #00ffff;
            font-size: 11px;
            line-height: 1.5;
            box-shadow: 0 0 18px rgba(0,255,255,0.2);
        }
        .timeline-panel h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            letter-spacing: 0.08em;
        }
        .timeline-entry {
            border-left: 2px solid rgba(0,255,255,0.4);
            margin-bottom: 10px;
            padding-left: 10px;
            opacity: 0.85;
        }
        .timeline-entry strong {
            color: #ffff00;
            display: block;
            font-size: 11px;
        }
        .timeline-entry span {
            display: block;
            color: rgba(255,255,255,0.7);
            margin-top: 2px;
        }
        .timeline-entry:last-child {
            margin-bottom: 0;
        }
        .ticker {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 14px;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(255,0,255,0.35);
            border-radius: 10px;
            color: #ff00ff;
            font-size: 11px;
            letter-spacing: 0.05em;
            max-width: 320px;
            line-height: 1.5;
        }
        .moire-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0.1; z-index: 5;
            background:
                repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(255,0,255,0.3) 8px, rgba(255,0,255,0.3) 16px),
                repeating-linear-gradient(90deg, transparent, transparent 6px, rgba(0,255,255,0.2) 6px, rgba(0,255,255,0.2) 12px);
            animation: moireShift 8s linear infinite;
        }
        @keyframes moireShift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(16px, 12px); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="moire-overlay" id="moireOverlay"></div>
    
    <div class="control-panel">
        <h3 style="margin: 0 0 15px 0;">MOIRÃ‰ HYPERCUBE CODEX</h3>
        
        <div class="slider-group">
            <div class="slider-label">Grid Density: <span id="densityVal">1.0</span></div>
            <input type="range" id="density" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">Lattice Morph: <span id="morphVal">0.5</span></div>
            <input type="range" id="morph" min="0.0" max="5.0" step="0.1" value="0.5">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">RGB Split: <span id="rgbVal">0.3</span></div>
            <input type="range" id="rgb" min="0.0" max="2.0" step="0.05" value="0.3">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">MoirÃ© Intensity: <span id="moireVal">0.4</span></div>
            <input type="range" id="moireIntensity" min="0.0" max="2.0" step="0.05" value="0.4">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">Glitch Factor: <span id="glitchVal">0.2</span></div>
            <input type="range" id="glitch" min="0.0" max="2.0" step="0.05" value="0.2">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">Animation Speed: <span id="speedVal">1.0</span></div>
            <input type="range" id="speed" min="0.1" max="10.0" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <div class="slider-label">Layer 2 Opacity: <span id="layer2OpacityVal">0.5</span></div>
            <input type="range" id="layer2Opacity" min="0.0" max="1.0" step="0.05" value="0.5">
        </div>
        
        <div style="margin: 15px 0;">
            <strong>PRESETS:</strong><br>
            <button class="preset-btn" onclick="setPreset('hypercube')">Hypercube</button>
            <button class="preset-btn" onclick="setPreset('chaos')">Chaos</button>
            <button class="preset-btn" onclick="setPreset('minimal')">Minimal</button>
            <button class="preset-btn" onclick="setPreset('extreme')">Extreme</button>
        </div>
        
        <div style="margin: 15px 0;">
            <strong>EFFECTS:</strong><br>
            <button class="toggle-btn" id="rgbToggle" onclick="toggleEffect('rgb')">RGB GLITCH</button>
            <button class="toggle-btn active" id="moireToggle" onclick="toggleEffect('moire')">MOIRÃ‰</button>
            <button class="toggle-btn" id="pulseToggle" onclick="toggleEffect('pulse')">PULSE</button>
        </div>

        <div class="export-group">
            <strong>EXPORT &amp; CAPTURE</strong>
            <div class="export-actions">
                <button class="export-btn" id="exportCodexBtn">Export JSON Codex</button>
                <button class="export-btn" id="capturePngBtn">Capture PNG Snapshot</button>
                <button class="export-btn" id="copyCodexBtn">Copy Settings</button>
            </div>
            <div class="export-meta" id="exportMeta">Last export: never</div>
        </div>

        <div class="evolution-dock">
            <h4>CODIFIED EVOLUTIONS</h4>
            <div class="evolution-grid" id="evolutionGrid">
                <div class="evolution-card active" data-mode="0">
                    <strong>Quantum Loom</strong>
                    Filamented lattice with classic cyan/magenta weave.
                </div>
                <div class="evolution-card" data-mode="1">
                    <strong>Prismatic Bloom</strong>
                    Radial neon blooms with breathing chromatic wells.
                </div>
                <div class="evolution-card" data-mode="2">
                    <strong>Singularity Shear</strong>
                    Torn gridlines fold into gravitational spirals.
                </div>
                <div class="evolution-card" data-mode="3">
                    <strong>Temporal Drift</strong>
                    Layered echo trails mapped to state history.
                </div>
                <div class="evolution-card" data-mode="4">
                    <strong>Flux Cathedral</strong>
                    Faceted prisms fold light into crystalline corridors.
                </div>
                <div class="evolution-card" data-mode="5">
                    <strong>Aurora Cascade</strong>
                    Polar curtains ripple through the lattice strata.
                </div>
                <div class="evolution-card" data-mode="6">
                    <strong>Entropy Bloom</strong>
                    Chaotic petal storms bloom from resonance spikes.
                </div>
            </div>
            <button class="autopilot-btn" id="autopilotBtn">Activate Evolution Autopilot</button>
        </div>
    </div>

    <div class="status">
        <div>FPS: <span id="fps">--</span></div>
        <div>Mode: HYPERCUBE LATTICE</div>
        <div>RGB SPLIT ACTIVE</div>
        <div>MOIRÃ‰ INTERFERENCE</div>
    </div>

    <div class="timeline-panel" id="timelinePanel">
        <h4>EVOLUTION TIMELINE</h4>
        <div id="timelineEntries"></div>
    </div>

    <div class="toast" id="toast"></div>

    <div class="ticker" id="evolutionTicker">
        Awaiting evolutionary pulsesâ€¦
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        let params = {
            density: 1.0,
            morph: 0.5,
            rgb: 0.3,
            moireIntensity: 0.4,
            glitch: 0.2,
            speed: 1.0,
            layer2Opacity: 0.5,
            evolutionMode: 0
        };

        let effects = {
            rgb: false,
            moire: true,
            pulse: false
        };

        let currentPreset = 'custom';
        const exportHistory = [];

        const toastEl = document.getElementById('toast');
        const timelineEntriesEl = document.getElementById('timelineEntries');
        const tickerEl = document.getElementById('evolutionTicker');
        const autopilotBtn = document.getElementById('autopilotBtn');
        const evolutionCards = Array.from(document.querySelectorAll('.evolution-card'));

        let autopilotActive = false;
        let historyCharge = 0.0;
        let evolutionPulse = 0.0;
        let lastTickerUpdate = 0;
        let evolutionVariant = Math.random();
        let autopilotSequence = null;
        let autopilotIndex = 0;
        let autopilotHandle = null;

        const EVOLUTION_TARGETS = [
            {
                name: 'Quantum Loom',
                ticker: 'Quantum Loom engaged: crystalline weaving stabilized.',
                params: { density: 1.2, morph: 0.65, rgb: 0.35, moireIntensity: 0.45, glitch: 0.15, speed: 1.0, layer2Opacity: 0.55 }
            },
            {
                name: 'Prismatic Bloom',
                ticker: 'Prismatic Bloom unfolding â€“ chroma wells breathing.',
                params: { density: 0.85, morph: 1.3, rgb: 0.75, moireIntensity: 0.65, glitch: 0.12, speed: 1.6, layer2Opacity: 0.68 }
            },
            {
                name: 'Singularity Shear',
                ticker: 'Singularity Shear active â€“ lattice torn toward event core.',
                params: { density: 1.65, morph: 1.8, rgb: 0.55, moireIntensity: 0.85, glitch: 0.45, speed: 1.9, layer2Opacity: 0.42 }
            },
            {
                name: 'Temporal Drift',
                ticker: 'Temporal Drift streaming â€“ echo trails mapping history.',
                params: { density: 0.6, morph: 0.95, rgb: 0.25, moireIntensity: 0.55, glitch: 0.32, speed: 0.75, layer2Opacity: 0.78 }
            },
            {
                name: 'Flux Cathedral',
                ticker: 'Flux Cathedral resonating â€“ refracted vaults align.',
                params: { density: 1.1, morph: 1.5, rgb: 0.9, moireIntensity: 0.7, glitch: 0.28, speed: 1.35, layer2Opacity: 0.64 }
            },
            {
                name: 'Aurora Cascade',
                ticker: 'Aurora Cascade unfurled â€“ polar curtains streaming.',
                params: { density: 0.7, morph: 1.1, rgb: 1.2, moireIntensity: 0.9, glitch: 0.38, speed: 1.85, layer2Opacity: 0.52 }
            },
            {
                name: 'Entropy Bloom',
                ticker: 'Entropy Bloom erupting â€“ petals of noise in full flare.',
                params: { density: 1.95, morph: 2.1, rgb: 0.65, moireIntensity: 1.05, glitch: 0.6, speed: 2.35, layer2Opacity: 0.46 }
            }
        ];

        const EVOLUTION_SEQUENCES = [
            [0, 2, 5, 3],
            [4, 1, 6],
            [2, 4, 0, 5],
            [6, 3, 1],
            [5, 0, 4, 2, 6]
        ];

        let mouse = { x: 0, y: 0 };
        let frameCount = 0;
        let lastTime = 0;

        function showToast(message) {
            if (!toastEl) return;
            toastEl.textContent = message;
            toastEl.classList.add('show');
            clearTimeout(showToast.timeout);
            showToast.timeout = setTimeout(() => {
                toastEl.classList.remove('show');
            }, 2200);
        }

        function pushTicker(message) {
            if (!tickerEl) return;
            lastTickerUpdate = Date.now();
            tickerEl.textContent = message;
        }

        function updateTimeline() {
            if (!timelineEntriesEl) return;
            const recent = exportHistory.slice(-8).reverse();
            timelineEntriesEl.innerHTML = recent.map(entry => {
                const ts = new Date(entry.timestamp).toLocaleTimeString();
                const evo = EVOLUTION_TARGETS[entry.evolutionMode || 0]?.name || 'Custom';
                const variant = typeof entry.variant === 'number' ? `Variant Î»=${entry.variant.toFixed(2)}` : '';
                return `
                    <div class="timeline-entry">
                        <strong>${ts} â€¢ ${evo}</strong>
                        <span>${entry.source}${variant ? ` â€¢ ${variant}` : ''}</span>
                    </div>
                `;
            }).join('');
        }

        function updateEvolutionUI() {
            evolutionCards.forEach(card => {
                const mode = Number(card.dataset.mode || 0);
                card.classList.toggle('active', mode === params.evolutionMode);
            });
        }

        function applyEvolutionTargets(mode, blend = 0.4) {
            const target = EVOLUTION_TARGETS[mode];
            if (!target) return;
            Object.entries(target.params).forEach(([key, value]) => {
                if (typeof params[key] === 'number') {
                    params[key] = params[key] * (1 - blend) + value * blend;
                }
            });
            updateSliders();
        }

        function pickAutopilotSequence() {
            const selection = EVOLUTION_SEQUENCES[Math.floor(Math.random() * EVOLUTION_SEQUENCES.length)] || [];
            return selection.slice();
        }

        function resetAutopilotSchedule() {
            if (autopilotHandle) {
                clearTimeout(autopilotHandle);
                autopilotHandle = null;
            }
        }

        function scheduleAutopilotStep(initial = false) {
            if (!autopilotActive) return;
            if (!autopilotSequence || autopilotIndex >= autopilotSequence.length) {
                autopilotSequence = pickAutopilotSequence();
                autopilotIndex = 0;
                const itinerary = autopilotSequence
                    .map(index => EVOLUTION_TARGETS[index]?.name || `Mode ${index}`)
                    .join(' â†’ ');
                const itineraryMessage = `Autopilot itinerary locked: ${itinerary || 'cycling default grid.'}`;
                pushTicker(itineraryMessage);
                if (itinerary) {
                    showToast(itineraryMessage);
                }
            }
            if (!autopilotSequence.length) return;
            const nextMode = autopilotSequence[autopilotIndex % autopilotSequence.length];
            autopilotIndex += 1;
            setEvolutionMode(nextMode, 'autopilot');
            const delay = initial ? 1800 : 5200 + Math.random() * 3200;
            resetAutopilotSchedule();
            autopilotHandle = setTimeout(() => scheduleAutopilotStep(), delay);
        }

        function setEvolutionMode(mode, source = 'manual') {
            if (mode === params.evolutionMode) {
                logSnapshot(`evolution:${source}`, { evolutionMode: mode });
                return;
            }
            params.evolutionMode = mode;
            evolutionVariant = Math.random();
            updateEvolutionUI();
            applyEvolutionTargets(mode, source === 'autopilot' ? 0.55 : 0.45);
            const evolutionName = EVOLUTION_TARGETS[mode]?.name || 'Custom Evolution';
            showToast(`${evolutionName} engaged`);
            pushTicker(EVOLUTION_TARGETS[mode]?.ticker || `${evolutionName} active.`);
            historyCharge = Math.min(1.0, historyCharge + 0.6);
            evolutionPulse = 1.0;
            logSnapshot(`evolution:${source}`, { evolutionMode: mode, variant: evolutionVariant });
        }

        function toggleAutopilot() {
            autopilotActive = !autopilotActive;
            if (autopilotBtn) {
                autopilotBtn.textContent = autopilotActive ? 'Disable Evolution Autopilot' : 'Activate Evolution Autopilot';
            }
            if (autopilotActive) {
                pushTicker('Autopilot weaving through codex evolutions.');
                showToast('Evolution autopilot enabled');
                autopilotSequence = pickAutopilotSequence();
                autopilotIndex = 0;
                scheduleAutopilotStep(true);
            } else {
                showToast('Evolution autopilot disabled');
                pushTicker('Manual control restored to codex weaver.');
                resetAutopilotSchedule();
                autopilotSequence = null;
                autopilotIndex = 0;
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_density;
            uniform float u_morph;
            uniform float u_rgb;
            uniform float u_moireIntensity;
            uniform float u_glitch;
            uniform float u_speed;
            uniform float u_rgbEnabled;
            uniform float u_moireEnabled;
            uniform float u_pulseEnabled;
            uniform float u_layer2Opacity;
            uniform float u_evolutionMode;
            uniform float u_historyCharge;
            uniform float u_variantSeed;

            // 4D rotation matrices
            mat4 rotateXY(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            }
            
            mat4 rotateZW(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);
            }
            
            mat4 rotateXW(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);
            }
            
            // Enhanced hypercube lattice with morphing
            float morphingHypercubeLattice(vec4 p, float gridSize, float morphFactor) {
                // Base grid
                vec4 grid = abs(fract(p / gridSize) - 0.5);
                
                // Morphing distortion
                vec4 morph = vec4(
                    sin(p.y * 3.0 + u_time * u_speed) * morphFactor * 0.1,
                    cos(p.x * 3.0 + u_time * u_speed) * morphFactor * 0.1,
                    sin(p.z * 2.0 + u_time * u_speed * 0.7) * morphFactor * 0.15,
                    cos(p.w * 2.0 + u_time * u_speed * 0.9) * morphFactor * 0.15
                );
                
                grid += morph;
                grid = abs(fract(grid) - 0.5);
                
                float thickness = 0.02 * (1.0 + morphFactor * 0.5);
                float minDist = min(min(min(grid.x, grid.y), grid.z), grid.w);
                
                return smoothstep(thickness, thickness * 0.5, minDist);
            }
            
            // Advanced RGB color separation
            vec3 advancedRGBSplit(vec3 baseColor, vec2 uv, float intensity) {
                if (u_rgbEnabled < 0.5) return baseColor;
                
                vec2 offset1 = vec2(intensity * 0.02 * sin(u_time * u_speed * 8.0), 0.0);
                vec2 offset2 = vec2(-intensity * 0.015 * cos(u_time * u_speed * 6.0), 
                                   intensity * 0.01 * sin(u_time * u_speed * 12.0));
                
                // Separate RGB channels with different offsets
                float r = baseColor.r;
                float g = mix(baseColor.g, baseColor.r * 1.2, intensity * 0.6);
                float b = mix(baseColor.b, baseColor.g * 1.1, intensity * 0.4);
                
                // Add chromatic aberration
                r += sin(uv.x * 50.0 + u_time * u_speed * 5.0) * intensity * 0.1;
                b += cos(uv.y * 45.0 + u_time * u_speed * 4.0) * intensity * 0.1;
                
                return vec3(r, g, b);
            }
            
            // Complex moirÃ© interference patterns
            float complexMoirePattern(vec2 uv, vec4 p4d, float intensity) {
                if (u_moireEnabled < 0.5) return 0.0;
                
                // Multiple overlapping patterns
                float pattern1 = sin(uv.x * 60.0 * (1.0 + intensity)) * 
                               sin(uv.y * 60.0 * (1.0 + intensity));
                               
                float pattern2 = sin((uv.x + uv.y) * 40.0 * (1.0 + intensity * 0.7)) *
                               cos((uv.x - uv.y) * 35.0 * (1.0 + intensity * 0.5));
                               
                float pattern3 = sin(length(uv - 0.5) * 80.0 * (1.0 + intensity)) *
                               cos(atan(uv.y - 0.5, uv.x - 0.5) * 16.0);
                
                // Add 4D influence
                float pattern4d = sin(p4d.z * 25.0 + u_time * u_speed) * 
                                cos(p4d.w * 20.0 + u_time * u_speed * 0.8);
                
                return (pattern1 + pattern2 + pattern3 + pattern4d) * intensity * 0.2;
            }
            
            // Glitch effects
            vec3 glitchDistortion(vec3 color, vec2 uv, float intensity) {
                // Digital noise
                float noise = fract(sin(dot(uv + u_time * u_speed * 0.1, vec2(12.9898, 78.233))) * 43758.5453);

                // Scanline effects
                float scanline = sin(uv.y * 800.0 + u_time * u_speed * 10.0) * intensity * 0.1;

                // Block displacement
                float block = step(0.95, noise) * intensity;
                color += vec3(block * 0.3, -block * 0.2, block * 0.1);

                // Add scanlines
                color += vec3(scanline);

                return color;
            }

            vec3 applyEvolution(vec3 color, vec4 p4d, vec2 uv) {
                float mode = u_evolutionMode;
                float variant = u_variantSeed;
                vec2 centered = uv - 0.5;
                float radius = length(centered);
                if (mode < 0.5) {
                    return color;
                } else if (mode < 1.5) {
                    float bloom = pow(sin(radius * 18.0 + u_time * u_speed * 1.2) * 0.5 + 0.5, 1.6);
                    vec3 bloomColor = vec3(0.7 + 0.4 * bloom, 0.2 + 0.5 * bloom, 0.8 + 0.3 * bloom);
                    return mix(color, bloomColor, 0.55);
                } else if (mode < 2.5) {
                    float angle = atan(centered.y, centered.x);
                    float shear = sin(angle * 6.0 + radius * 40.0 - u_time * u_speed * 1.6);
                    vec3 singular = vec3(0.4 + 0.8 * shear, 0.15 + 0.45 * shear, 0.9 + 0.3 * shear);
                    singular *= (0.6 + radius * 1.8);
                    return mix(color, singular, 0.65);
                } else if (mode < 3.5) {
                    float echo = exp(-radius * 6.0) * (0.35 + u_historyCharge * 1.1);
                    float stripes = sin((p4d.z + p4d.w) * 12.0 + u_time * u_speed * 2.5);
                    vec3 drift = vec3(0.45 + echo, 0.25 + echo * 0.6, 0.8 + echo);
                    drift += vec3(stripes * 0.12);
                    return mix(color, drift, clamp(u_historyCharge + 0.25, 0.0, 1.0));
                } else if (mode < 4.5) {
                    float vaultWave = cos((p4d.x + p4d.y) * (12.0 + variant * 6.0) + u_time * u_speed * 1.2);
                    float refract = sin((p4d.z - p4d.w) * (10.0 + variant * 7.0) - u_time * u_speed * 0.9);
                    float faceted = smoothstep(0.1, 0.75, abs(vaultWave * refract));
                    vec3 cathedral = vec3(
                        0.28 + 0.65 * faceted,
                        0.34 + 0.55 * faceted,
                        0.82 + 0.4 * faceted
                    );
                    cathedral += vec3(
                        sin(radius * 16.0 + variant * 6.283) * 0.12,
                        cos(radius * 18.0 + variant * 4.712) * 0.08,
                        sin((p4d.z + p4d.w) * 6.0 + variant * 3.1415) * 0.1
                    );
                    float blend = clamp(0.45 + faceted * 0.4 + u_historyCharge * 0.2, 0.0, 1.0);
                    return mix(color, cathedral, blend);
                } else if (mode < 5.5) {
                    float curtain = sin(centered.y * (18.0 + variant * 10.0) + u_time * u_speed * (1.4 + variant));
                    float aurora = cos((p4d.x + p4d.z) * (4.0 + variant * 3.0) - u_time * u_speed * 0.9);
                    float cascade = curtain * 0.6 + aurora * 0.4;
                    vec3 auroraColor = vec3(
                        0.32 + cascade * 0.35,
                        0.78 + cascade * 0.5,
                        0.95 + cascade * 0.45
                    );
                    auroraColor *= 0.75 + sin(p4d.w * (6.0 + variant * 2.5) + u_time * u_speed * 0.8) * 0.25;
                    float blend = clamp(0.4 + (cascade * 0.35) + radius * 0.1 + u_historyCharge * 0.2, 0.0, 0.95);
                    return mix(color, auroraColor, blend);
                } else {
                    float bloom = sin((p4d.z + p4d.w) * (8.0 + variant * 6.0) + u_time * u_speed * 2.2);
                    float petals = cos((p4d.x - p4d.y) * (9.0 + variant * 7.0) - u_time * u_speed * 1.6);
                    float turbulence = pow(abs(bloom * petals), 0.65);
                    float noise = fract(sin(dot(uv * (60.0 + variant * 20.0), vec2(45.233, 12.989))) * 43758.5453);
                    vec3 entropy = vec3(
                        0.58 + bloom * 0.45 + noise * 0.25,
                        0.2 + petals * 0.4 + noise * 0.2,
                        0.85 + turbulence * 0.5
                    );
                    entropy += vec3(noise * 0.18, noise * 0.12, noise * 0.22);
                    float blend = clamp(0.35 + turbulence * 0.5 + u_historyCharge * 0.35, 0.0, 1.0);
                    return mix(color, entropy, blend);
                }
            }

            vec3 renderLayer(vec2 uv, float time_offset) {
                vec2 coord = (uv - 0.5) * 2.0;
                
                // Mouse influence
                vec2 mouse = u_mouse / u_resolution;
                float mouseInfluence = length(mouse - 0.5) * 2.0;
                coord += (mouse - 0.5) * 0.3;
                
                // Create 4D space with enhanced time evolution
                vec4 p4d = vec4(
                    coord, 
                    sin(u_time * u_speed * 0.4 + mouseInfluence + time_offset) + cos(u_time * u_speed * 0.6 + time_offset),
                    cos(u_time * u_speed * 0.3 + mouseInfluence * 0.7 + time_offset) + sin(u_time * u_speed * 0.8 + time_offset)
                );
                
                // Apply complex 4D rotations
                p4d = rotateXY(u_time * u_speed * 0.15 + mouseInfluence * 0.5) * p4d;
                p4d = rotateZW(u_time * u_speed * 0.12 + sin(u_time * u_speed * 0.3)) * p4d;
                p4d = rotateXW(u_time * u_speed * 0.08 + cos(u_time * u_speed * 0.4)) * p4d;
                
                // Generate morphing hypercube lattice
                float lattice = morphingHypercubeLattice(p4d, u_density, u_morph);
                
                // Enhanced color palette
                vec3 color1 = vec3(0.0, 1.0, 1.0);   // Cyan
                vec3 color2 = vec3(1.0, 0.0, 1.0);   // Magenta  
                vec3 color3 = vec3(1.0, 1.0, 0.0);   // Yellow
                vec3 color4 = vec3(0.5, 0.0, 1.0);   // Purple
                
                // Dynamic color mixing based on 4D position and time
                float colorMix1 = sin(p4d.z + u_time * u_speed * 0.7) * 0.5 + 0.5;
                float colorMix2 = cos(p4d.w + u_time * u_speed * 0.5) * 0.5 + 0.5;
                float colorMix3 = sin(mouseInfluence + u_time * u_speed) * 0.5 + 0.5;
                
                vec3 baseColor = mix(
                    mix(color1, color2, colorMix1),
                    mix(color3, color4, colorMix2),
                    colorMix3
                );
                
                // Apply lattice
                baseColor *= lattice;
                
                // Pulse effect
                if (u_pulseEnabled > 0.5) {
                    float pulse = sin(u_time * u_speed * 3.0) * 0.3 + 0.7;
                    baseColor *= pulse;
                }
                
                // Add moirÃ© patterns
                float moire = complexMoirePattern(uv, p4d, u_moireIntensity);
                baseColor += vec3(moire);
                
                // Apply RGB color separation
                baseColor = advancedRGBSplit(baseColor, uv, u_rgb);
                
                // Apply glitch effects
                baseColor = glitchDistortion(baseColor, uv, u_glitch);

                // Mouse interaction glow
                float mouseDist = length(uv - mouse);
                baseColor += exp(-mouseDist * 6.0) * 0.2 * vec3(1.0, 0.5, 1.0);

                // Depth-based intensity variation
                float depth4d = (sin(p4d.z * 1.5) + cos(p4d.w * 1.2)) * 0.25 + 0.75;
                baseColor *= depth4d;

                // Final intensity adjustment
                baseColor *= 0.2 + lattice * 0.8;

                // Subtle vignette
                float vignette = 1.0 - length(coord) * 0.3;
                baseColor *= vignette;

                baseColor = applyEvolution(baseColor, p4d, uv);

                return baseColor;
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution;
                vec3 layer1 = renderLayer(uv, 0.0);
                vec3 layer2 = renderLayer(uv, 10.0);

                gl_FragColor = vec4(mix(layer1, layer2, u_layer2Opacity), 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {
            time: gl.getUniformLocation(program, 'u_time'),
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            mouse: gl.getUniformLocation(program, 'u_mouse'),
            density: gl.getUniformLocation(program, 'u_density'),
            morph: gl.getUniformLocation(program, 'u_morph'),
            rgb: gl.getUniformLocation(program, 'u_rgb'),
            moireIntensity: gl.getUniformLocation(program, 'u_moireIntensity'),
            glitch: gl.getUniformLocation(program, 'u_glitch'),
            speed: gl.getUniformLocation(program, 'u_speed'),
            rgbEnabled: gl.getUniformLocation(program, 'u_rgbEnabled'),
            moireEnabled: gl.getUniformLocation(program, 'u_moireEnabled'),
            pulseEnabled: gl.getUniformLocation(program, 'u_pulseEnabled'),
            layer2Opacity: gl.getUniformLocation(program, 'u_layer2Opacity'),
            evolutionMode: gl.getUniformLocation(program, 'u_evolutionMode'),
            historyCharge: gl.getUniformLocation(program, 'u_historyCharge'),
            variantSeed: gl.getUniformLocation(program, 'u_variantSeed')
        };

        // Event handlers
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = window.innerHeight - e.clientY;
        });

        evolutionCards.forEach(card => {
            card.addEventListener('click', () => {
                const mode = Number(card.dataset.mode || 0);
                if (autopilotActive) {
                    toggleAutopilot();
                }
                setEvolutionMode(mode, 'manual');
            });
        });

        autopilotBtn?.addEventListener('click', toggleAutopilot);

        // Slider setup
        function logSnapshot(source, extra = {}) {
            const snapshot = {
                timestamp: new Date().toISOString(),
                source,
                preset: currentPreset,
                params: { ...params },
                effects: { ...effects },
                evolutionMode: params.evolutionMode,
                autopilot: autopilotActive,
                variant: extra?.variant ?? evolutionVariant,
                ...extra
            };
            exportHistory.push(snapshot);
            if (exportHistory.length > 60) {
                exportHistory.shift();
            }
            historyCharge = Math.min(1.0, historyCharge + 0.25);
            updateTimeline();
        }

        function setupSlider(id, param, valueId) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);
            const decimals = param === 'layer2Opacity' ? 2 : 1;

            slider.addEventListener('input', (e) => {
                params[param] = parseFloat(e.target.value);
                if (valueDisplay) {
                    valueDisplay.textContent = params[param].toFixed(decimals);
                }
                currentPreset = 'custom';
                logSnapshot(`slider:${param}`);
            });

            if (valueDisplay) {
                valueDisplay.textContent = params[param].toFixed(decimals);
            }
        }

        setupSlider('density', 'density', 'densityVal');
        setupSlider('morph', 'morph', 'morphVal');
        setupSlider('rgb', 'rgb', 'rgbVal');
        setupSlider('moireIntensity', 'moireIntensity', 'moireVal');
        setupSlider('glitch', 'glitch', 'glitchVal');
        setupSlider('speed', 'speed', 'speedVal');
        setupSlider('layer2Opacity', 'layer2Opacity', 'layer2OpacityVal');

        // Preset configurations
        window.setPreset = function(preset) {
            const preserveMode = params.evolutionMode;
            switch(preset) {
                case 'hypercube':
                    params = { ...params, density: 1.0, morph: 0.5, rgb: 0.3, moireIntensity: 0.4, glitch: 0.2, speed: 1.0, layer2Opacity: 0.5 };
                    break;
                case 'chaos':
                    params = { ...params, density: 2.5, morph: 1.8, rgb: 0.8, moireIntensity: 0.9, glitch: 0.7, speed: 2.5, layer2Opacity: 0.7 };
                    break;
                case 'minimal':
                    params = { ...params, density: 0.5, morph: 0.1, rgb: 0.1, moireIntensity: 0.2, glitch: 0.0, speed: 0.5, layer2Opacity: 0.3 };
                    break;
                case 'extreme':
                    params = { ...params, density: 3.0, morph: 2.0, rgb: 1.0, moireIntensity: 1.0, glitch: 1.0, speed: 4.0, layer2Opacity: 1.0 };
                    break;
            }
            params.evolutionMode = preserveMode;
            currentPreset = preset;
            updateSliders();
            logSnapshot(`preset:${preset}`);
        };

        function updateSliders() {
            ['density', 'morph', 'rgb', 'moireIntensity', 'glitch', 'speed', 'layer2Opacity'].forEach(key => {
                const element = document.getElementById(key === 'moireIntensity' ? 'moireIntensity' : key);
                if (!element) return;
                element.value = params[key];
                const valueId = key === 'moireIntensity' ? 'moireVal' : key + 'Val';
                const display = document.getElementById(valueId);
                if (display) {
                    const decimals = key === 'layer2Opacity' ? 2 : 1;
                    display.textContent = params[key].toFixed(decimals);
                }
            });
        }

        // Effect toggles
        window.toggleEffect = function(effect) {
            effects[effect] = !effects[effect];
            document.getElementById(effect + 'Toggle').classList.toggle('active', effects[effect]);

            if (effect === 'moire') {
                document.getElementById('moireOverlay').style.opacity = effects[effect] ? '0.1' : '0';
            }
            logSnapshot(`toggle:${effect}`);
        };

        // FPS counter
        function updateFPS(currentTime) {
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function animate(time) {
            updateFPS(time);
            
            gl.uniform1f(uniforms.time, time * 0.001);
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform2f(uniforms.mouse, mouse.x, mouse.y);
            gl.uniform1f(uniforms.density, params.density);
            gl.uniform1f(uniforms.morph, params.morph);
            gl.uniform1f(uniforms.rgb, params.rgb);
            gl.uniform1f(uniforms.moireIntensity, params.moireIntensity);
            gl.uniform1f(uniforms.glitch, params.glitch);
            gl.uniform1f(uniforms.speed, params.speed);
            gl.uniform1f(uniforms.rgbEnabled, effects.rgb ? 1.0 : 0.0);
            gl.uniform1f(uniforms.moireEnabled, effects.moire ? 1.0 : 0.0);
            gl.uniform1f(uniforms.pulseEnabled, effects.pulse ? 1.0 : 0.0);
            gl.uniform1f(uniforms.layer2Opacity, params.layer2Opacity);
            evolutionPulse = Math.max(0.0, evolutionPulse - 0.01);
            historyCharge = Math.max(0.0, historyCharge - 0.0035);
            if (tickerEl && Date.now() - lastTickerUpdate > 9000 && autopilotActive) {
                pushTicker('Autopilot driftingâ€¦ next evolution recalibrating.');
            }
            gl.uniform1f(uniforms.evolutionMode, params.evolutionMode);
            gl.uniform1f(uniforms.historyCharge, historyCharge + evolutionPulse * 0.45);
            gl.uniform1f(uniforms.variantSeed, evolutionVariant);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }

        animate(0);
        logSnapshot('init');
        updateEvolutionUI();
        updateTimeline();
        pushTicker('Quantum Loom standing by for manual weaving.');

        // Export function for Hypercube Codex
        function exportCodex() {
            const exportData = {
                timestamp: new Date().toISOString(),
                currentParams: { ...params },
                activeEffects: { ...effects },
                canvasSize: { width: canvas.width, height: canvas.height },
                hypercubeType: 'Moire Pattern System',
                preset: currentPreset,
                evolutionMode: params.evolutionMode,
                autopilotActive,
                history: [...exportHistory.slice(-10)],
                version: '1.1'
            };

            // Create downloadable JSON
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `hypercube-codex-export-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('ðŸŽ¯ Hypercube Codex exported successfully');
            showToast('Hypercube Codex exported as JSON');
            updateExportMeta('JSON export ready');
        }
        function captureSnapshot() {
            const dataUrl = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `hypercube-codex-${Date.now()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showToast('PNG snapshot captured');
            updateExportMeta('PNG snapshot saved');
        }

        async function copyCodexToClipboard() {
            const payload = {
                params: { ...params },
                effects: { ...effects },
                preset: currentPreset
            };
            try {
                await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
                showToast('Codex settings copied to clipboard');
                updateExportMeta('Settings copied');
            } catch (error) {
                console.warn('Clipboard copy failed', error);
                showToast('Clipboard copy unavailable');
            }
        }

        function updateExportMeta(message) {
            const meta = document.getElementById('exportMeta');
            if (!meta) return;
            const now = new Date();
            meta.textContent = `${message} â€¢ ${now.toLocaleTimeString()}`;
        }

        const exportCodexBtn = document.getElementById('exportCodexBtn');
        const capturePngBtn = document.getElementById('capturePngBtn');
        const copyCodexBtn = document.getElementById('copyCodexBtn');

        exportCodexBtn?.addEventListener('click', exportCodex);
        capturePngBtn?.addEventListener('click', captureSnapshot);
        copyCodexBtn?.addEventListener('click', copyCodexToClipboard);
    </script>
    
    <!-- Add collapsible menu system -->
    <script>
        window.COLLAPSIBLE_MENU_CONFIG = {
            startCollapsed: true,
            position: 'top-right',
            theme: 'dark'
        };
    </script>
    <script src="../js/inject-collapsible-menu.js"></script>
</body>
</html>