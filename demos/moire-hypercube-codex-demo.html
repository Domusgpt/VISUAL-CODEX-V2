<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moir√© Hypercube Codex - Advanced Lattice Animation</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .control-panel { 
            position: fixed; top: 20px; left: 20px; 
            background: rgba(0,0,0,0.8); padding: 20px; 
            border: 2px solid #00ffff; color: #00ffff; 
            border-radius: 10px; backdrop-filter: blur(15px);
            z-index: 100; max-width: 300px;
        }
        .slider-group { margin: 15px 0; }
        .slider-label { margin-bottom: 8px; font-size: 14px; }
        input[type="range"] { width: 100%; }
        .preset-btn { 
            background: rgba(255,0,255,0.2); border: 1px solid #ff00ff; 
            color: #ff00ff; padding: 8px 12px; margin: 5px 5px 5px 0; 
            cursor: pointer; border-radius: 5px; font-size: 12px;
        }
        .preset-btn:hover { 
            background: rgba(255,0,255,0.4); box-shadow: 0 0 10px #ff00ff; 
        }
        .toggle-btn {
            background: rgba(255,255,0,0.2); border: 1px solid #ffff00;
            color: #ffff00; padding: 6px 10px; margin: 3px;
            cursor: pointer; border-radius: 3px; font-size: 11px;
        }
        .toggle-btn.active {
            background: rgba(255,255,0,0.4); box-shadow: 0 0 8px #ffff00;
        }
        .export-group {
            margin-top: 18px;
            padding-top: 12px;
            border-top: 1px solid rgba(0,255,255,0.2);
        }
        .export-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .export-btn {
            flex: 1 1 120px;
            min-height: 36px;
            background: linear-gradient(135deg, rgba(0,255,255,0.15), rgba(255,0,255,0.15));
            border: 1px solid rgba(0,255,255,0.4);
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .evolution-group {
            margin: 18px 0 10px;
            padding: 12px 10px;
            border: 1px solid rgba(255,0,255,0.25);
            border-radius: 8px;
            background: rgba(10,0,30,0.35);
        }
        .evolution-badges {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            margin-top: 10px;
        }
        .evolution-badges.wide {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }
        .evolution-btn {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(0,0,0,0.35);
            color: #ffe6ff;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .evolution-btn:hover {
            background: rgba(255,0,255,0.3);
            color: white;
            box-shadow: 0 0 12px rgba(255,0,255,0.35);
        }
        .evolution-btn.active {
            background: linear-gradient(135deg, rgba(0,255,255,0.35), rgba(255,0,255,0.35));
            border-color: rgba(255,255,255,0.65);
            color: #ffffff;
        }
        .sequence-controls {
            margin-top: 12px;
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 8px;
        }
        .evolution-memo {
            margin-top: 10px;
            font-size: 10px;
            line-height: 1.5;
            color: rgba(255, 200, 255, 0.75);
        }
        .sequence-log {
            margin-top: 10px;
            font-size: 10px;
            line-height: 1.5;
            max-height: 70px;
            overflow: hidden;
            color: rgba(200, 255, 255, 0.75);
        }
        .export-btn:hover {
            background: linear-gradient(135deg, rgba(0,255,255,0.35), rgba(255,0,255,0.35));
            box-shadow: 0 0 12px rgba(0,255,255,0.4);
        }
        .export-meta {
            font-size: 10px;
            opacity: 0.75;
            margin-top: 6px;
            line-height: 1.4;
        }
        .toast {
            position: fixed;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: #00ffff;
            padding: 12px 20px;
            border: 1px solid rgba(0,255,255,0.5);
            border-radius: 8px;
            font-size: 12px;
            letter-spacing: 0.04em;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }
        .toast.show {
            opacity: 1;
        }
        .status { 
            position: fixed; bottom: 20px; right: 20px; 
            color: #00ffff; font-size: 12px; text-align: right;
        }
        .moire-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0.1; z-index: 5;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(255,0,255,0.3) 8px, rgba(255,0,255,0.3) 16px),
                repeating-linear-gradient(90deg, transparent, transparent 6px, rgba(0,255,255,0.2) 6px, rgba(0,255,255,0.2) 12px);
            animation: moireShift 8s linear infinite;
        }
        @keyframes moireShift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(16px, 12px); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="moire-overlay" id="moireOverlay"></div>
    
    <div class="control-panel">
        <h3 style="margin: 0 0 15px 0;">MOIR√â HYPERCUBE CODEX</h3>
        
        <div class="slider-group">
            <div class="slider-label">Grid Density: <span id="densityVal">1.0</span></div>
            <input type="range" id="density" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">Lattice Morph: <span id="morphVal">0.5</span></div>
            <input type="range" id="morph" min="0.0" max="5.0" step="0.1" value="0.5">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">RGB Split: <span id="rgbVal">0.3</span></div>
            <input type="range" id="rgb" min="0.0" max="2.0" step="0.05" value="0.3">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">Moir√© Intensity: <span id="moireVal">0.4</span></div>
            <input type="range" id="moireIntensity" min="0.0" max="2.0" step="0.05" value="0.4">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">Glitch Factor: <span id="glitchVal">0.2</span></div>
            <input type="range" id="glitch" min="0.0" max="2.0" step="0.05" value="0.2">
        </div>
        
        <div class="slider-group">
            <div class="slider-label">Animation Speed: <span id="speedVal">1.0</span></div>
            <input type="range" id="speed" min="0.1" max="10.0" step="0.1" value="1.0">
        </div>

        <div class="slider-group">
            <div class="slider-label">Layer 2 Opacity: <span id="layer2OpacityVal">0.5</span></div>
            <input type="range" id="layer2Opacity" min="0.0" max="1.0" step="0.05" value="0.5">
        </div>
        
        <div style="margin: 15px 0;">
            <strong>PRESETS:</strong><br>
            <button class="preset-btn" onclick="setPreset('hypercube')">Hypercube</button>
            <button class="preset-btn" onclick="setPreset('chaos')">Chaos</button>
            <button class="preset-btn" onclick="setPreset('minimal')">Minimal</button>
            <button class="preset-btn" onclick="setPreset('extreme')">Extreme</button>
        </div>

        <div style="margin: 15px 0;">
            <strong>EFFECTS:</strong><br>
            <button class="toggle-btn" id="rgbToggle" onclick="toggleEffect('rgb')">RGB GLITCH</button>
            <button class="toggle-btn active" id="moireToggle" onclick="toggleEffect('moire')">MOIR√â</button>
            <button class="toggle-btn" id="pulseToggle" onclick="toggleEffect('pulse')">PULSE</button>
        </div>

        <div class="evolution-group">
            <div style="font-weight: 600; letter-spacing: 0.08em;">CODex EVOLUTIONS</div>
            <div style="font-size: 10px; opacity: 0.75; margin-top: 6px;">Each evolution shifts the shader mathematics, color atlas, and dimensional feedback loop.</div>
            <div class="evolution-badges wide">
                <button class="evolution-btn active" data-evolution="luminous" onclick="setEvolution('luminous')">Luminous Weave</button>
                <button class="evolution-btn" data-evolution="entropic" onclick="setEvolution('entropic')">Entropic Cascade</button>
                <button class="evolution-btn" data-evolution="prismatic" onclick="setEvolution('prismatic')">Prismatic Relay</button>
                <button class="evolution-btn" data-evolution="abyssal" onclick="setEvolution('abyssal')">Abyssal Bloom</button>
                <button class="evolution-btn" data-evolution="celestial" onclick="setEvolution('celestial')">Celestial Archive</button>
                <button class="evolution-btn" data-evolution="memetic" onclick="setEvolution('memetic')">Memetic Lattice</button>
            </div>
            <div class="sequence-controls">
                <button class="export-btn" id="sequenceBtn">Run Evolution Cycle</button>
                <button class="export-btn" id="pulseSequenceBtn">Pulse Burst</button>
                <button class="export-btn" id="resetEvolutionBtn">Reset Evolution</button>
            </div>
            <div class="sequence-log" id="evolutionLog">Evolution sequence idle.</div>
            <div class="evolution-memo" id="evolutionMemo">Memory imprint: dormant</div>
        </div>

        <div class="export-group">
            <strong>EXPORT &amp; CAPTURE</strong>
            <div class="export-actions">
                <button class="export-btn" id="exportCodexBtn">Export JSON Codex</button>
                <button class="export-btn" id="capturePngBtn">Capture PNG Snapshot</button>
                <button class="export-btn" id="copyCodexBtn">Copy Settings</button>
            </div>
            <div class="export-meta" id="exportMeta">Last export: never</div>
        </div>
    </div>

    <div class="status">
        <div>FPS: <span id="fps">--</span></div>
        <div>Mode: HYPERCUBE LATTICE</div>
        <div>RGB SPLIT ACTIVE</div>
        <div>MOIR√â INTERFERENCE</div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        let params = {
            density: 1.0,
            morph: 0.5,
            rgb: 0.3,
            moireIntensity: 0.4,
            glitch: 0.2,
            speed: 1.0,
            layer2Opacity: 0.5,
            feedback: 0.35,
            dimensionWarp: 0.6
        };

        let effects = {
            rgb: false,
            moire: true,
            pulse: false
        };

        const STORAGE_KEY = 'moire-hypercube-codex-phase3-state';
        let storageAvailable = false;
        try {
            const testKey = `${STORAGE_KEY}-test`;
            localStorage.setItem(testKey, '1');
            localStorage.removeItem(testKey);
            storageAvailable = true;
        } catch (error) {
            console.warn('Storage unavailable for codex persistence', error);
        }

        const evolutionModes = {
            luminous: {
                label: 'Luminous Weave',
                paletteShift: [1.0, 0.3, 0.8],
                morphBias: 0.6,
                feedback: 0.35,
                dimensionWarp: 0.45,
                vector: [0.25, 0.45, 0.9],
                memoryBias: 0.12
            },
            entropic: {
                label: 'Entropic Cascade',
                paletteShift: [1.4, 1.0, 0.4],
                morphBias: 1.8,
                feedback: 0.65,
                dimensionWarp: 0.85,
                vector: [0.8, 0.55, 0.25],
                memoryBias: 0.18
            },
            prismatic: {
                label: 'Prismatic Relay',
                paletteShift: [0.6, 1.2, 1.2],
                morphBias: 1.1,
                feedback: 0.5,
                dimensionWarp: 0.7,
                vector: [0.45, 0.8, 0.65],
                memoryBias: 0.14
            },
            abyssal: {
                label: 'Abyssal Bloom',
                paletteShift: [0.35, 0.65, 1.4],
                morphBias: 2.4,
                feedback: 0.8,
                dimensionWarp: 1.05,
                vector: [0.2, 0.45, 1.35],
                memoryBias: 0.22
            },
            celestial: {
                label: 'Celestial Archive',
                paletteShift: [1.2, 0.8, 1.5],
                morphBias: 1.65,
                feedback: 0.58,
                dimensionWarp: 0.9,
                vector: [0.65, 0.7, 1.25],
                memoryBias: 0.2
            },
            memetic: {
                label: 'Memetic Lattice',
                paletteShift: [0.55, 1.35, 0.95],
                morphBias: 2.1,
                feedback: 0.72,
                dimensionWarp: 1.15,
                vector: [0.35, 1.15, 0.85],
                memoryBias: 0.26
            }
        };

        let currentEvolution = 'luminous';
        let currentPreset = 'custom';
        const exportHistory = [];
        let sequenceTimer = null;
        let sequenceIndex = 0;
        let evolutionPhase = 0;
        let evolutionMemory = 0.18;

        const toastEl = document.getElementById('toast');
        const evolutionLog = document.getElementById('evolutionLog');
        const evolutionMemoEl = document.getElementById('evolutionMemo');

        let mouse = { x: 0, y: 0 };
        let frameCount = 0;
        let lastTime = 0;

        function persistState() {
            if (!storageAvailable) return;
            const payload = {
                params,
                effects,
                currentEvolution,
                currentPreset,
                evolutionPhase,
                evolutionMemory,
                sequenceIndex
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
            } catch (error) {
                console.warn('Failed to persist codex state', error);
            }
        }

        function syncEffectButtons() {
            Object.keys(effects).forEach((key) => {
                const toggle = document.getElementById(`${key}Toggle`);
                if (toggle) {
                    toggle.classList.toggle('active', effects[key]);
                }
            });
            const overlay = document.getElementById('moireOverlay');
            if (overlay) {
                overlay.style.opacity = effects.moire ? '0.1' : '0';
            }
        }

        function renderEvolutionMemo(context = 'active') {
            if (!evolutionMemoEl) return;
            const mode = evolutionModes[currentEvolution];
            const label = mode ? mode.label : 'Unknown Evolution';
            const imprint = evolutionMemory.toFixed(2);
            const prefix = context === 'restored' ? 'Memory imprint restored' : 'Memory imprint';
            evolutionMemoEl.textContent = `${prefix}: ${label} (${imprint})`;
        }

        function showToast(message) {
            if (!toastEl) return;
            toastEl.textContent = message;
            toastEl.classList.add('show');
            clearTimeout(showToast.timeout);
            showToast.timeout = setTimeout(() => {
                toastEl.classList.remove('show');
            }, 2200);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_density;
            uniform float u_morph;
            uniform float u_rgb;
            uniform float u_moireIntensity;
            uniform float u_glitch;
            uniform float u_speed;
            uniform float u_rgbEnabled;
            uniform float u_moireEnabled;
            uniform float u_pulseEnabled;
            uniform float u_layer2Opacity;
            uniform float u_feedback;
            uniform float u_dimensionWarp;
            uniform vec3 u_paletteShift;
            uniform float u_evolutionPhase;
            uniform vec3 u_evolutionVector;
            uniform float u_memoryDrive;

            // 4D rotation matrices
            mat4 rotateXY(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            }
            
            mat4 rotateZW(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);
            }
            
            mat4 rotateXW(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);
            }
            
            // Enhanced hypercube lattice with morphing
            float morphingHypercubeLattice(vec4 p, float gridSize, float morphFactor) {
                // Base grid
                vec4 grid = abs(fract(p / gridSize) - 0.5);

                // Morphing distortion
                vec4 morph = vec4(
                    sin(p.y * 3.0 + u_time * u_speed) * morphFactor * 0.1,
                    cos(p.x * 3.0 + u_time * u_speed) * morphFactor * 0.1,
                    sin(p.z * 2.0 + u_time * u_speed * 0.7) * morphFactor * 0.15,
                    cos(p.w * 2.0 + u_time * u_speed * 0.9) * morphFactor * 0.15
                );
                
                grid += morph;
                grid = abs(fract(grid) - 0.5);
                
                float thickness = 0.02 * (1.0 + morphFactor * 0.5);
                float minDist = min(min(min(grid.x, grid.y), grid.z), grid.w);
                
                return smoothstep(thickness, thickness * 0.5, minDist);
            }
            
            // Advanced RGB color separation
            vec3 advancedRGBSplit(vec3 baseColor, vec2 uv, float intensity) {
                if (u_rgbEnabled < 0.5) return baseColor;

                vec2 offset1 = vec2(intensity * 0.02 * sin(u_time * u_speed * 8.0), 0.0);
                vec2 offset2 = vec2(-intensity * 0.015 * cos(u_time * u_speed * 6.0),
                                   intensity * 0.01 * sin(u_time * u_speed * 12.0));
                
                // Separate RGB channels with different offsets
                float r = baseColor.r;
                float g = mix(baseColor.g, baseColor.r * 1.2, intensity * 0.6);
                float b = mix(baseColor.b, baseColor.g * 1.1, intensity * 0.4);
                
                // Add chromatic aberration
                r += sin(uv.x * 50.0 + u_time * u_speed * 5.0) * intensity * 0.1;
                b += cos(uv.y * 45.0 + u_time * u_speed * 4.0) * intensity * 0.1;
                
                return vec3(r, g, b);
            }
            
            // Complex moir√© interference patterns
            float complexMoirePattern(vec2 uv, vec4 p4d, float intensity) {
                if (u_moireEnabled < 0.5) return 0.0;

                // Multiple overlapping patterns
                float pattern1 = sin(uv.x * 60.0 * (1.0 + intensity)) *
                               sin(uv.y * 60.0 * (1.0 + intensity));
                               
                float pattern2 = sin((uv.x + uv.y) * 40.0 * (1.0 + intensity * 0.7)) *
                               cos((uv.x - uv.y) * 35.0 * (1.0 + intensity * 0.5));
                               
                float pattern3 = sin(length(uv - 0.5) * 80.0 * (1.0 + intensity)) *
                               cos(atan(uv.y - 0.5, uv.x - 0.5) * 16.0);
                
                // Add 4D influence
                float pattern4d = sin(p4d.z * 25.0 + u_time * u_speed) * 
                                cos(p4d.w * 20.0 + u_time * u_speed * 0.8);
                
                return (pattern1 + pattern2 + pattern3 + pattern4d) * intensity * 0.2;
            }
            
            // Glitch effects
            vec3 glitchDistortion(vec3 color, vec2 uv, float intensity) {
                // Digital noise
                float noise = fract(sin(dot(uv + u_time * u_speed * 0.1, vec2(12.9898, 78.233))) * 43758.5453);

                // Scanline effects
                float scanline = sin(uv.y * 800.0 + u_time * u_speed * 10.0) * intensity * 0.1;
                
                // Block displacement
                float block = step(0.95, noise) * intensity;
                color += vec3(block * 0.3, -block * 0.2, block * 0.1);
                
                // Add scanlines
                color += vec3(scanline);
                
                return color;
            }

            vec3 renderLayer(vec2 uv, float time_offset) {
                vec2 coord = (uv - 0.5) * 2.0;

                // Mouse influence
                vec2 mouse = u_mouse / u_resolution;
                float mouseInfluence = length(mouse - 0.5) * 2.0;
                coord += (mouse - 0.5) * 0.3;

                // Create 4D space with enhanced time evolution
                vec4 p4d = vec4(
                    coord,
                    sin(u_time * u_speed * 0.4 + mouseInfluence + time_offset) + cos(u_time * u_speed * 0.6 + time_offset) + u_feedback * 0.35,
                    cos(u_time * u_speed * 0.3 + mouseInfluence * 0.7 + time_offset) + sin(u_time * u_speed * 0.8 + time_offset) + u_dimensionWarp * 0.28
                );

                // Apply complex 4D rotations
                float evolutionSpin = u_time * u_speed * mix(0.12, 0.35, u_evolutionPhase);
                p4d = rotateXY(evolutionSpin + mouseInfluence * 0.5) * p4d;
                p4d = rotateZW(u_time * u_speed * 0.12 + sin(u_time * u_speed * 0.3 + u_evolutionPhase * 6.283)) * p4d;
                p4d = rotateXW(u_time * u_speed * 0.08 + cos(u_time * u_speed * 0.4 + u_evolutionPhase * 4.712)) * p4d;

                // Generate morphing hypercube lattice
                float lattice = morphingHypercubeLattice(p4d, u_density, u_morph + u_evolutionPhase * 0.8 + u_memoryDrive * 0.6);

                // Enhanced color palette
                vec3 color1 = vec3(0.0, 1.0, 1.0) * u_paletteShift.r;
                vec3 color2 = vec3(1.0, 0.0, 1.0) * u_paletteShift.g;
                vec3 color3 = vec3(1.0, 1.0, 0.0) * (0.6 + u_evolutionPhase * 0.6 + u_memoryDrive * 0.3);
                vec3 color4 = vec3(0.5, 0.0, 1.0) * (0.7 + u_paletteShift.b * 0.4 + u_evolutionVector.z * 0.2);

                // Dynamic color mixing based on 4D position and time
                float colorMix1 = sin(p4d.z + u_time * u_speed * (0.7 + u_evolutionPhase)) * 0.5 + 0.5;
                float colorMix2 = cos(p4d.w + u_time * u_speed * (0.5 + u_evolutionPhase * 0.5)) * 0.5 + 0.5;
                float colorMix3 = sin(mouseInfluence + u_time * u_speed + u_evolutionPhase * 1.5 + u_memoryDrive * 1.2) * 0.5 + 0.5;
                float colorMix4 = sin(dot(p4d.xy, u_evolutionVector.xy) * 3.2 + u_time * u_speed * 0.6) * 0.5 + 0.5;

                vec3 baseColor = mix(
                    mix(color1, color2, colorMix1),
                    mix(color3, color4, colorMix2),
                    colorMix3
                );
                baseColor = mix(baseColor, vec3(u_evolutionVector), colorMix4 * (0.25 + u_memoryDrive * 0.3));

                // Apply lattice
                baseColor *= lattice;

                // Pulse effect
                if (u_pulseEnabled > 0.5) {
                    float pulse = sin(u_time * u_speed * 3.0 + u_evolutionPhase * 6.283) * 0.3 + 0.7 + u_feedback * 0.2;
                    baseColor *= pulse;
                }

                // Add moir√© patterns
                float moire = complexMoirePattern(uv, p4d, u_moireIntensity);
                baseColor += vec3(moire);
                
                // Apply RGB color separation
                baseColor = advancedRGBSplit(baseColor, uv, u_rgb);
                
                // Apply glitch effects
                baseColor = glitchDistortion(baseColor, uv, u_glitch);
                
                // Mouse interaction glow
                float mouseDist = length(uv - mouse);
                baseColor += exp(-mouseDist * 6.0) * (0.2 + u_feedback * 0.1) * vec3(1.0, 0.5, 1.0);

                // Depth-based intensity variation
                float depth4d = (sin(p4d.z * (1.5 + u_dimensionWarp)) + cos(p4d.w * (1.2 + u_dimensionWarp * 0.5))) * 0.25 + 0.75;
                baseColor *= depth4d;

                // Final intensity adjustment
                baseColor *= 0.2 + lattice * (0.6 + u_evolutionPhase * 0.4);

                // Subtle vignette
                float vignette = 1.0 - length(coord) * 0.3;
                baseColor *= vignette;

                return baseColor;
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution;
                vec3 layer1 = renderLayer(uv, 0.0);
                vec3 layer2 = renderLayer(uv, 10.0);

                gl_FragColor = vec4(mix(layer1, layer2, u_layer2Opacity), 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {
            time: gl.getUniformLocation(program, 'u_time'),
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            mouse: gl.getUniformLocation(program, 'u_mouse'),
            density: gl.getUniformLocation(program, 'u_density'),
            morph: gl.getUniformLocation(program, 'u_morph'),
            rgb: gl.getUniformLocation(program, 'u_rgb'),
            moireIntensity: gl.getUniformLocation(program, 'u_moireIntensity'),
            glitch: gl.getUniformLocation(program, 'u_glitch'),
            speed: gl.getUniformLocation(program, 'u_speed'),
            rgbEnabled: gl.getUniformLocation(program, 'u_rgbEnabled'),
            moireEnabled: gl.getUniformLocation(program, 'u_moireEnabled'),
            pulseEnabled: gl.getUniformLocation(program, 'u_pulseEnabled'),
            layer2Opacity: gl.getUniformLocation(program, 'u_layer2Opacity'),
            feedback: gl.getUniformLocation(program, 'u_feedback'),
            dimensionWarp: gl.getUniformLocation(program, 'u_dimensionWarp'),
            paletteShift: gl.getUniformLocation(program, 'u_paletteShift'),
            evolutionPhase: gl.getUniformLocation(program, 'u_evolutionPhase'),
            evolutionVector: gl.getUniformLocation(program, 'u_evolutionVector'),
            memoryDrive: gl.getUniformLocation(program, 'u_memoryDrive')
        };

        // Event handlers
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = window.innerHeight - e.clientY;
        });

        // Slider setup
        function logSnapshot(source, detail = {}) {
            const snapshot = {
                timestamp: new Date().toISOString(),
                source,
                preset: currentPreset,
                params: { ...params },
                effects: { ...effects },
                detail
            };
            exportHistory.push(snapshot);
            if (exportHistory.length > 30) {
                exportHistory.shift();
            }
            persistState();
        }

        function setupSlider(id, param, valueId) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);

            slider.addEventListener('input', (e) => {
                params[param] = parseFloat(e.target.value);
                valueDisplay.textContent = params[param].toFixed(1);
                currentPreset = 'custom';
                logSnapshot(`slider:${param}`, { value: params[param] });
            });
        }

        setupSlider('density', 'density', 'densityVal');
        setupSlider('morph', 'morph', 'morphVal');
        setupSlider('rgb', 'rgb', 'rgbVal');
        setupSlider('moireIntensity', 'moireIntensity', 'moireVal');
        setupSlider('glitch', 'glitch', 'glitchVal');
        setupSlider('speed', 'speed', 'speedVal');
        setupSlider('layer2Opacity', 'layer2Opacity', 'layer2OpacityVal');

        // Preset configurations
        window.setPreset = function(preset) {
            const base = { feedback: params.feedback, dimensionWarp: params.dimensionWarp };
            switch(preset) {
                case 'hypercube':
                    params = { ...params, ...base, density: 1.0, morph: 0.5, rgb: 0.3, moireIntensity: 0.4, glitch: 0.2, speed: 1.0, layer2Opacity: 0.5 };
                    break;
                case 'chaos':
                    params = { ...params, ...base, density: 2.5, morph: 1.8, rgb: 0.8, moireIntensity: 0.9, glitch: 0.7, speed: 2.5, layer2Opacity: 0.7 };
                    break;
                case 'minimal':
                    params = { ...params, ...base, density: 0.5, morph: 0.1, rgb: 0.1, moireIntensity: 0.2, glitch: 0.0, speed: 0.5, layer2Opacity: 0.3 };
                    break;
                case 'extreme':
                    params = { ...params, ...base, density: 3.0, morph: 2.0, rgb: 1.0, moireIntensity: 1.0, glitch: 1.0, speed: 4.0, layer2Opacity: 1.0 };
                    break;
            }
            currentPreset = preset;
            updateSliders();
            logSnapshot(`preset:${preset}`, { density: params.density, morph: params.morph });
            renderEvolutionMemo();
        };

        function updateSliders() {
            Object.keys(params).forEach(key => {
                const element = document.getElementById(key === 'moireIntensity' ? 'moireIntensity' : key);
                if (element) {
                    element.value = params[key];
                    const valueId = key === 'moireIntensity' ? 'moireVal' : key + 'Val';
                    document.getElementById(valueId).textContent = params[key].toFixed(1);
                }
            });
        }

        // Effect toggles
        window.toggleEffect = function(effect) {
            effects[effect] = !effects[effect];
            document.getElementById(effect + 'Toggle').classList.toggle('active', effects[effect]);

            if (effect === 'moire') {
                document.getElementById('moireOverlay').style.opacity = effects[effect] ? '0.1' : '0';
            }
            logSnapshot(`toggle:${effect}`, { active: effects[effect] });
            syncEffectButtons();
        };

        // FPS counter
        function updateFPS(currentTime) {
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function animate(time) {
            updateFPS(time);

            evolutionMemory = Math.max(0.05, evolutionMemory * 0.995 + (effects.pulse ? 0.0025 : 0.0008));

            gl.uniform1f(uniforms.time, time * 0.001);
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform2f(uniforms.mouse, mouse.x, mouse.y);
            gl.uniform1f(uniforms.density, params.density);
            gl.uniform1f(uniforms.morph, params.morph);
            gl.uniform1f(uniforms.rgb, params.rgb);
            gl.uniform1f(uniforms.moireIntensity, params.moireIntensity);
            gl.uniform1f(uniforms.glitch, params.glitch);
            gl.uniform1f(uniforms.speed, params.speed);
            gl.uniform1f(uniforms.rgbEnabled, effects.rgb ? 1.0 : 0.0);
            gl.uniform1f(uniforms.moireEnabled, effects.moire ? 1.0 : 0.0);
            gl.uniform1f(uniforms.pulseEnabled, effects.pulse ? 1.0 : 0.0);
            gl.uniform1f(uniforms.layer2Opacity, params.layer2Opacity);
            gl.uniform1f(uniforms.feedback, params.feedback);
            gl.uniform1f(uniforms.dimensionWarp, params.dimensionWarp);
            gl.uniform3f(uniforms.paletteShift, ...activePaletteShift());
            gl.uniform1f(uniforms.evolutionPhase, evolutionPhase);
            gl.uniform3f(uniforms.evolutionVector, ...activeEvolutionVector());
            gl.uniform1f(uniforms.memoryDrive, evolutionMemory);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }

        animate(0);

        function activePaletteShift() {
            const mode = evolutionModes[currentEvolution];
            return mode ? mode.paletteShift : [1, 1, 1];
        }

        function activeEvolutionVector() {
            const mode = evolutionModes[currentEvolution];
            return mode && mode.vector ? mode.vector : [0.5, 0.5, 0.5];
        }

        // Export function for Hypercube Codex
        function exportCodex() {
            const exportData = {
                timestamp: new Date().toISOString(),
                currentParams: { ...params },
                activeEffects: { ...effects },
                canvasSize: { width: canvas.width, height: canvas.height },
                hypercubeType: 'Moire Pattern System',
                preset: currentPreset,
                currentEvolution,
                evolutionMemory,
                history: [...exportHistory.slice(-10)],
                version: '1.2'
            };

            // Create downloadable JSON
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `hypercube-codex-export-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('üéØ Hypercube Codex exported successfully');
            showToast('Hypercube Codex exported as JSON');
            updateExportMeta('JSON export ready');
        }
        function captureSnapshot() {
            const dataUrl = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `hypercube-codex-${Date.now()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showToast('PNG snapshot captured');
            updateExportMeta('PNG snapshot saved');
        }

        async function copyCodexToClipboard() {
            const payload = {
                params: { ...params },
                effects: { ...effects },
                preset: currentPreset,
                currentEvolution,
                evolutionMemory
            };
            try {
                await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
                showToast('Codex settings copied to clipboard');
                updateExportMeta('Settings copied');
            } catch (error) {
                console.warn('Clipboard copy failed', error);
                showToast('Clipboard copy unavailable');
            }
        }

        function updateExportMeta(message) {
            const meta = document.getElementById('exportMeta');
            if (!meta) return;
            const now = new Date();
            meta.textContent = `${message} ‚Ä¢ ${now.toLocaleTimeString()}`;
        }

        function setEvolution(mode, options = {}) {
            if (!evolutionModes[mode]) return;
            const { silent = false, phase = null } = options;
            currentEvolution = mode;
            const config = evolutionModes[mode];
            params.feedback = config.feedback;
            params.dimensionWarp = config.dimensionWarp;
            params.morph = Math.min(5, config.morphBias);
            document.getElementById('morph').value = params.morph;
            document.getElementById('morphVal').textContent = params.morph.toFixed(1);
            document.querySelectorAll('.evolution-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.evolution === mode);
            });
            if (phase !== null) {
                evolutionPhase = phase;
            } else if (!silent) {
                evolutionPhase = (evolutionPhase + 0.12) % 1.0;
            }
            if (!silent) {
                evolutionMemory = Math.min(1, evolutionMemory + (config.memoryBias || 0.1));
                logSnapshot(`evolution:${mode}`, { memory: evolutionMemory });
                appendEvolutionLog(`‚Üí ${config.label} loaded`);
                renderEvolutionMemo();
            } else {
                renderEvolutionMemo('restored');
            }
            persistState();
        }

        function appendEvolutionLog(message) {
            const now = new Date();
            const stamp = now.toLocaleTimeString();
            evolutionLog.textContent = `${stamp} ${message}\n${evolutionLog.textContent}`.slice(0, 220);
        }

        function runSequenceStep() {
            const modes = Object.keys(evolutionModes);
            const nextMode = modes[sequenceIndex % modes.length];
            setEvolution(nextMode);
            params.speed = 1.4 + Math.sin(sequenceIndex * 0.6) * 0.4;
            document.getElementById('speed').value = params.speed;
            document.getElementById('speedVal').textContent = params.speed.toFixed(1);
            params.layer2Opacity = 0.4 + ((sequenceIndex % 3) * 0.2);
            document.getElementById('layer2Opacity').value = params.layer2Opacity;
            document.getElementById('layer2OpacityVal').textContent = params.layer2Opacity.toFixed(1);
            evolutionPhase = (sequenceIndex * 0.17) % 1.0;
            logSnapshot('sequence-step', { evolution: nextMode, index: sequenceIndex });
            appendEvolutionLog(`cycling ${evolutionModes[nextMode].label}`);
            sequenceIndex += 1;
        }

        function startEvolutionCycle() {
            stopEvolutionCycle();
            appendEvolutionLog('Evolution cycle initiated.');
            runSequenceStep();
            sequenceTimer = setInterval(() => {
                evolutionPhase = (evolutionPhase + 0.12) % 1.0;
                runSequenceStep();
            }, 4200);
        }

        function stopEvolutionCycle() {
            if (sequenceTimer) {
                clearInterval(sequenceTimer);
                sequenceTimer = null;
            }
        }

        function triggerPulseBurst() {
            evolutionPhase = Math.random();
            params.feedback = 0.45 + Math.random() * 0.35;
            params.dimensionWarp = 0.4 + Math.random() * 0.7;
            document.getElementById('density').value = params.density = 0.7 + Math.random() * 1.2;
            document.getElementById('densityVal').textContent = params.density.toFixed(1);
            evolutionMemory = Math.min(1, evolutionMemory + 0.1);
            renderEvolutionMemo();
            logSnapshot('pulse-burst', { evolutionPhase, memory: evolutionMemory });
            appendEvolutionLog('Pulse burst triggered.');
            showToast('Pulse burst injected into lattice');
        }

        function resetEvolution() {
            stopEvolutionCycle();
            currentEvolution = 'luminous';
            params.feedback = 0.35;
            params.dimensionWarp = 0.6;
            document.getElementById('density').value = params.density = 1.0;
            document.getElementById('densityVal').textContent = params.density.toFixed(1);
            document.getElementById('layer2Opacity').value = params.layer2Opacity = 0.5;
            document.getElementById('layer2OpacityVal').textContent = params.layer2Opacity.toFixed(1);
            document.querySelectorAll('.evolution-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.evolution === 'luminous');
            });
            evolutionLog.textContent = 'Evolution reset to luminous weave.';
            evolutionMemory = 0.2;
            renderEvolutionMemo();
            logSnapshot('evolution-reset');
        }

        function restoreState() {
            updateSliders();
            syncEffectButtons();
            if (!storageAvailable) {
                renderEvolutionMemo('active');
                return false;
            }
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) {
                renderEvolutionMemo('active');
                return false;
            }
            try {
                const saved = JSON.parse(raw);
                if (saved.params) {
                    params = { ...params, ...saved.params };
                }
                if (saved.effects) {
                    effects = { ...effects, ...saved.effects };
                }
                if (saved.currentPreset) {
                    currentPreset = saved.currentPreset;
                }
                if (typeof saved.evolutionPhase === 'number') {
                    evolutionPhase = saved.evolutionPhase;
                }
                if (typeof saved.evolutionMemory === 'number') {
                    evolutionMemory = saved.evolutionMemory;
                }
                if (typeof saved.sequenceIndex === 'number') {
                    sequenceIndex = saved.sequenceIndex;
                }
                if (saved.currentEvolution && evolutionModes[saved.currentEvolution]) {
                    currentEvolution = saved.currentEvolution;
                }
                updateSliders();
                syncEffectButtons();
                setEvolution(currentEvolution, { silent: true, phase: evolutionPhase });
                appendEvolutionLog('‚Ü∫ Codex state restored from quantum memory.');
                renderEvolutionMemo('restored');
                return true;
            } catch (error) {
                console.warn('Failed to restore codex state', error);
                renderEvolutionMemo('active');
                return false;
            }
        }

        const exportCodexBtn = document.getElementById('exportCodexBtn');
        const capturePngBtn = document.getElementById('capturePngBtn');
        const copyCodexBtn = document.getElementById('copyCodexBtn');
        const sequenceBtn = document.getElementById('sequenceBtn');
        const pulseSequenceBtn = document.getElementById('pulseSequenceBtn');
        const resetEvolutionBtn = document.getElementById('resetEvolutionBtn');

        exportCodexBtn?.addEventListener('click', exportCodex);
        capturePngBtn?.addEventListener('click', captureSnapshot);
        copyCodexBtn?.addEventListener('click', copyCodexToClipboard);
        sequenceBtn?.addEventListener('click', startEvolutionCycle);
        pulseSequenceBtn?.addEventListener('click', triggerPulseBurst);
        resetEvolutionBtn?.addEventListener('click', resetEvolution);

        const stateRestored = restoreState();
        if (!stateRestored) {
            setEvolution('luminous', { silent: true, phase: evolutionPhase });
            appendEvolutionLog('Luminous weave primed.');
            renderEvolutionMemo();
            persistState();
        }
        const initSource = stateRestored ? 'init-restored' : 'init-seeded';
        logSnapshot(initSource, { restored: stateRestored, memory: evolutionMemory });
    </script>
    
    <!-- Add collapsible menu system -->
    <script>
        window.COLLAPSIBLE_MENU_CONFIG = {
            startCollapsed: true,
            position: 'top-right',
            theme: 'dark'
        };
    </script>
    <script src="../js/inject-collapsible-menu.js"></script>
</body>
</html>