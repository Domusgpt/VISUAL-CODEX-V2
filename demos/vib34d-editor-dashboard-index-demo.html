<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VIB34D Editor Dashboard – Holographic Index Cards</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: radial-gradient(circle at 20% 20%, rgba(255, 0, 255, 0.12), transparent 45%),
                    radial-gradient(circle at 80% 10%, rgba(0, 255, 255, 0.1), transparent 40%),
                    #05030d;
            --grid-color: rgba(0, 255, 255, 0.12);
            --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
            --transition-duration: 420ms;
            --cascade-delay: 120;
            --focus-outline: rgba(0, 255, 255, 0.75);
            font-family: "JetBrains Mono", "Fira Code", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: var(--bg);
            color: #e8efff;
            padding: clamp(18px, 4vw, 36px);
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        body.reduce-motion * {
            animation-duration: 0.001ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.001ms !important;
        }

        body.reduce-motion .visualizer-preview::after {
            animation: none !important;
        }

        body.reduce-motion .visualizer-preview {
            animation: none !important;
        }

        header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .title-block h1 {
            font-size: clamp(1.8rem, 2.6vw, 3rem);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #7ad6ff;
            text-shadow: 0 0 12px rgba(0, 255, 255, 0.45);
            margin: 0 0 8px;
        }

        .title-block p {
            margin: 0;
            max-width: 640px;
            line-height: 1.6;
            color: #97a8ff;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 14px 18px;
            padding: 14px 20px;
            border-radius: 22px;
            border: 1px solid var(--grid-color, rgba(0, 255, 255, 0.28));
            background: rgba(5, 10, 23, 0.78);
            box-shadow: 0 0 18px var(--grid-color, rgba(0, 255, 255, 0.12));
            backdrop-filter: blur(14px);
        }

        .control-panel .range-group {
            display: grid;
            gap: 8px;
            min-width: 220px;
        }

        .control-panel label {
            font-size: 0.72rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: rgba(180, 220, 255, 0.75);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-panel label output {
            font-size: 0.68rem;
            letter-spacing: 0.12em;
            color: rgba(255, 255, 255, 0.78);
        }

        .control-panel input[type="range"] {
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            outline: none;
            overflow: hidden;
        }

        .control-panel input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(120deg, rgba(0, 255, 255, 0.65), rgba(255, 0, 255, 0.65));
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.4);
            cursor: pointer;
        }

        .control-panel input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(120deg, rgba(0, 255, 255, 0.65), rgba(255, 0, 255, 0.65));
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.4);
            border: none;
            cursor: pointer;
        }

        .control-panel select {
            appearance: none;
            border-radius: 14px;
            border: 1px solid rgba(0, 255, 255, 0.25);
            padding: 10px 14px;
            background: rgba(8, 12, 24, 0.75);
            color: #e8efff;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }

        .control-panel select:focus {
            outline: 2px solid rgba(0, 255, 255, 0.55);
            outline-offset: 2px;
        }

        button:focus-visible,
        input:focus-visible,
        select:focus-visible {
            outline: 2px solid var(--focus-outline);
            outline-offset: 3px;
        }

        .control-panel .panel-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .snapshot-group {
            display: grid;
            gap: 8px;
            min-width: 220px;
        }

        .snapshot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            font-size: 0.68rem;
            color: rgba(180, 220, 255, 0.75);
        }

        .snapshot-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .snapshot-actions button {
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.28);
            background: linear-gradient(120deg, rgba(0, 255, 255, 0.22), rgba(255, 0, 255, 0.28));
            color: rgba(240, 248, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 0.14em;
            font-size: 0.68rem;
            cursor: pointer;
            transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease;
        }

        .snapshot-actions button:hover:not([disabled]) {
            transform: translateY(-2px);
            box-shadow: 0 10px 18px rgba(0, 0, 0, 0.3);
        }

        .snapshot-actions button[disabled] {
            opacity: 0.55;
            cursor: not-allowed;
            filter: saturate(0.6);
        }

        .snapshot-note {
            margin: 0;
            font-size: 0.64rem;
            letter-spacing: 0.12em;
            color: rgba(180, 210, 255, 0.68);
        }

        .control-panel .reset-controls {
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 999px;
            padding: 10px 20px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            background: linear-gradient(120deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.3));
            color: #f5f9ff;
            cursor: pointer;
            transition: transform 200ms ease, box-shadow 200ms ease;
        }

        .control-panel .reset-controls:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 16px rgba(0, 255, 255, 0.24);
        }

        .toggle-control {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 0.72rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(190, 220, 255, 0.75);
        }

        .toggle-control input[type="checkbox"] {
            appearance: none;
            width: 42px;
            height: 22px;
            border-radius: 999px;
            position: relative;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            cursor: pointer;
            transition: background 180ms ease;
        }

        .toggle-control input[type="checkbox"]::after {
            content: '';
            position: absolute;
            inset: 3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(120deg, rgba(0, 255, 255, 0.8), rgba(255, 0, 255, 0.8));
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.35);
            transform: translateX(0);
            transition: transform 180ms ease;
        }

        .toggle-control input[type="checkbox"]:checked {
            background: rgba(0, 255, 255, 0.25);
        }

        .toggle-control input[type="checkbox"]:checked::after {
            transform: translateX(18px);
        }

        button.randomize-all {
            font-family: inherit;
            border: none;
            border-radius: 999px;
            padding: 10px 22px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.12em;
            background: linear-gradient(120deg, rgba(0, 255, 255, 0.25), rgba(255, 0, 255, 0.35));
            color: #f6f6ff;
            transition: transform 200ms ease, box-shadow 200ms ease;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.24);
        }

        button.randomize-all:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 22px rgba(255, 0, 255, 0.38);
        }

        .dashboard-grid {
            position: relative;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: clamp(18px, 2.8vw, 36px);
            padding: clamp(12px, 2vw, 20px);
            border-radius: 28px;
            border: 1px solid rgba(0, 255, 255, 0.14);
            background: rgba(2, 9, 22, 0.8);
            backdrop-filter: blur(18px);
            overflow: hidden;
        }

        .dashboard-grid::before,
        .dashboard-grid::after {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background-image: linear-gradient(rgba(0, 255, 255, 0.12) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.12) 1px, transparent 1px);
            background-size: 52px 52px;
            mix-blend-mode: screen;
            opacity: 0.25;
            transform: translate3d(0, 0, 0);
        }

        .dashboard-grid::after {
            background-size: 26px 26px;
            opacity: 0.12;
        }

        .card {
            position: relative;
            border-radius: 20px;
            padding: 22px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            cursor: pointer;
            transition: transform var(--transition-duration) cubic-bezier(0.17, 0.84, 0.44, 1),
                filter var(--transition-duration) ease,
                box-shadow var(--transition-duration) ease;
            background: linear-gradient(130deg, hsla(var(--hue, 195), 82%, 62%, 0.18), hsla(calc(var(--hue, 195) + 60), 85%, 68%, 0.05));
            box-shadow:
                var(--card-shadow),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                0 0 22px rgba(var(--glow-rgb, 0, 255, 255), 0.24);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(22px) saturate(var(--saturation, 1.1));
            transform: perspective(800px) rotateX(var(--tilt-x, 0deg)) rotateY(var(--tilt-y, 0deg)) translateY(var(--lift, 0px));
            filter: drop-shadow(0 0 20px rgba(var(--glow-rgb, 0, 255, 255), 0.18));
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 1px;
            border-radius: 19px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.12), transparent 40%);
            opacity: 0.4;
            pointer-events: none;
            mix-blend-mode: screen;
        }

        .card:hover {
            --lift: -8px;
            --tilt-x: -4deg;
            --tilt-y: 3deg;
            box-shadow:
                0 20px 45px rgba(0, 0, 0, 0.55),
                0 0 0 2px rgba(var(--glow-rgb, 0, 255, 255), 0.35),
                0 0 36px rgba(var(--glow-rgb, 0, 255, 255), 0.4);
        }

        .card:active {
            --lift: -2px;
            --tilt-x: 2deg;
            --tilt-y: -1deg;
            box-shadow:
                0 16px 30px rgba(0, 0, 0, 0.55),
                0 0 0 2px rgba(255, 255, 0, 0.45),
                0 0 30px rgba(255, 255, 0, 0.35);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
        }

        .card-title {
            font-size: 1.05rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: #f4f6ff;
        }

        .card-state {
            font-size: 0.85rem;
            letter-spacing: 0.2em;
            color: rgba(255, 255, 255, 0.72);
        }

        .visualizer-preview {
            position: relative;
            height: 160px;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background:
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.22), transparent 55%),
                radial-gradient(circle at 70% 20%, rgba(var(--glow-rgb, 0, 255, 255), 0.28), transparent 60%),
                conic-gradient(from 120deg at 50% 50%, rgba(var(--glow-rgb, 0, 255, 255), 0.55), transparent 210deg);
            animation: breathe 6s ease-in-out infinite;
        }

        .visualizer-preview::after {
            content: "";
            position: absolute;
            inset: -50%;
            background:
                repeating-linear-gradient(
                    var(--grid-angle, 45deg),
                    transparent,
                    transparent calc(var(--grid-size, 22px) - 1px),
                    rgba(var(--glow-rgb, 0, 255, 255), 0.3) calc(var(--grid-size, 22px))
                );
            opacity: 0.45;
            mix-blend-mode: screen;
            animation: scan var(--scan-speed, 18s) linear infinite;
        }

        .param-list {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px 12px;
            font-size: 0.78rem;
            letter-spacing: 0.02em;
        }

        .param {
            display: flex;
            justify-content: space-between;
            color: rgba(240, 244, 255, 0.86);
        }

        .param label {
            font-size: 0.72rem;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: rgba(146, 206, 255, 0.8);
        }

        .status-readout {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 0.78rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(170, 210, 255, 0.78);
        }

        .status-readout::before {
            content: '';
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.4);
        }

        body.high-contrast {
            background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.14), transparent 45%), #040112;
        }

        body.high-contrast .control-panel {
            border-color: rgba(0, 255, 255, 0.35);
            box-shadow: 0 0 26px rgba(0, 255, 255, 0.24);
        }

        body.high-contrast .dashboard-grid {
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 24px 44px rgba(0, 0, 0, 0.55);
        }

        body.high-contrast .card {
            border-color: rgba(255, 255, 255, 0.18);
            box-shadow:
                var(--card-shadow),
                0 0 0 2px rgba(255, 255, 255, 0.28),
                0 0 36px rgba(var(--glow-rgb, 0, 255, 255), 0.45);
        }

        footer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 0.85rem;
            color: rgba(170, 200, 255, 0.72);
            max-width: 840px;
            line-height: 1.6;
        }

        footer span {
            color: rgba(255, 255, 255, 0.82);
            font-weight: 600;
        }

        @keyframes breathe {
            0%,
            100% {
                transform: scale(1);
                filter: saturate(1.1);
            }
            50% {
                transform: scale(1.03);
                filter: saturate(1.4);
            }
        }

        @keyframes scan {
            0% {
                transform: rotate(var(--grid-angle, 45deg)) translate3d(-10%, -10%, 0);
            }
            100% {
                transform: rotate(var(--grid-angle, 45deg)) translate3d(10%, 10%, 0);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .visualizer-preview,
            .visualizer-preview::after {
                animation: none !important;
            }
        }

        @media (max-width: 768px) {
            .visualizer-preview {
                height: 140px;
            }

            .param-list {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="title-block">
            <h1>VIB34D Editor Dashboard — Holographic Index</h1>
            <p>
                Click any card to trigger a cascade of 25 randomized parameter states. The holographic styling responds with
                real-time color shifts, 3D tilts, morph factors, and glitch intensity adjustments to mirror the behaviour of the
                archived GEMINI dashboard prototypes.
            </p>
        </div>
        <div class="control-panel">
            <div class="range-group">
                <label for="speedControl">cascade pace<output id="speedValue">120ms</output></label>
                <input type="range" id="speedControl" min="60" max="220" step="10" value="120" />
            </div>
            <div class="range-group">
                <label for="themeControl">palette mode</label>
                <select id="themeControl" aria-label="Select palette mode">
                    <option value="aurora-cascade">Aurora Cascade</option>
                    <option value="circuit-bloom">Circuit Bloom</option>
                    <option value="luminous-grid">Luminous Grid</option>
                </select>
            </div>
            <label class="toggle-control">
                <input type="checkbox" id="autoToggle" />
                auto cascade
            </label>
            <div class="panel-actions">
                <button class="reset-controls" type="button">reset controls</button>
                <button class="randomize-all" type="button">pulse 25 states</button>
            </div>
            <div class="snapshot-group">
                <div class="snapshot-header">
                    <span>snapshots</span>
                    <span id="snapshotStatus">unsaved</span>
                </div>
                <div class="snapshot-actions">
                    <button type="button" id="snapshotSave">save snapshot</button>
                    <button type="button" id="snapshotRestore" disabled>restore snapshot</button>
                    <button type="button" id="snapshotCopy" disabled>copy share code</button>
                </div>
                <p class="snapshot-note" id="snapshotNote">No snapshot stored yet.</p>
            </div>
        </div>
    </header>

    <section class="dashboard-grid" id="dashboard">
        <article class="card" data-layouts='["GRID 5x4","GRID 6x6","FLOW AI","SYNCED"]'>
            <header class="card-header">
                <h2 class="card-title">Quantum Layout Cartographer</h2>
                <span class="card-state">GRID 5x4</span>
            </header>
            <div class="visualizer-preview"></div>
            <div class="param-list">
                <div class="param"><label>color</label><span>192°</span></div>
                <div class="param"><label>morph</label><span>0.60</span></div>
                <div class="param"><label>density</label><span>5</span></div>
                <div class="param"><label>rotation</label><span>0.45x</span></div>
                <div class="param"><label>glitch</label><span>0.12</span></div>
                <div class="param"><label>dimension</label><span>3.5D</span></div>
            </div>
        </article>
        <article class="card" data-layouts='["STUDIO","XR PANELS","GRID 4x4","STREAM"]'>
            <header class="card-header">
                <h2 class="card-title">Reactive Preset Forge</h2>
                <span class="card-state">STUDIO</span>
            </header>
            <div class="visualizer-preview"></div>
            <div class="param-list">
                <div class="param"><label>color</label><span>264°</span></div>
                <div class="param"><label>morph</label><span>0.72</span></div>
                <div class="param"><label>density</label><span>7</span></div>
                <div class="param"><label>rotation</label><span>0.32x</span></div>
                <div class="param"><label>glitch</label><span>0.22</span></div>
                <div class="param"><label>dimension</label><span>4D</span></div>
            </div>
        </article>
        <article class="card" data-layouts='["OMNI","VERTEX","FOCUS","XR"]'>
            <header class="card-header">
                <h2 class="card-title">Visualizer Swarm Control</h2>
                <span class="card-state">OMNI</span>
            </header>
            <div class="visualizer-preview"></div>
            <div class="param-list">
                <div class="param"><label>color</label><span>144°</span></div>
                <div class="param"><label>morph</label><span>0.48</span></div>
                <div class="param"><label>density</label><span>4</span></div>
                <div class="param"><label>rotation</label><span>0.60x</span></div>
                <div class="param"><label>glitch</label><span>0.08</span></div>
                <div class="param"><label>dimension</label><span>5D</span></div>
            </div>
        </article>
        <article class="card" data-layouts='["AURORA","NEBULA","LIGHTFIELD","FOG"]'>
            <header class="card-header">
                <h2 class="card-title">Holographic Style Sequencer</h2>
                <span class="card-state">AURORA</span>
            </header>
            <div class="visualizer-preview"></div>
            <div class="param-list">
                <div class="param"><label>color</label><span>312°</span></div>
                <div class="param"><label>morph</label><span>0.84</span></div>
                <div class="param"><label>density</label><span>6</span></div>
                <div class="param"><label>rotation</label><span>0.20x</span></div>
                <div class="param"><label>glitch</label><span>0.32</span></div>
                <div class="param"><label>dimension</label><span>XR</span></div>
            </div>
        </article>
    </section>

    <footer>
        <p class="status-readout" id="statusReadout" role="status" aria-live="polite" aria-atomic="true">ready</p>
        <p><span>Interaction:</span> Clicking a card triggers a rapid cascade through 25 holographic presets. Every iteration rewrites CSS custom properties for hue, gradient spread, grid density, morph factor, rotation speed, and glitch intensity while cycling through saved layout states.</p>
        <p><span>Tip:</span> Use the “pulse 25 states” control to broadcast an identical cascade across the entire dashboard and watch the cards synchronize their holographic breathing patterns.</p>
    </footer>

    <script>
        const PARAM_LIMITS = {
            hue: [0, 360],
            gradientSkew: [15, 70],
            gridSize: [18, 46],
            morph: [0.25, 1.3],
            rotation: [0.12, 0.88],
            glitch: [0, 0.45],
            dimension: ['2.5D', '3D', '3.5D', '4D', '4.5D', '5D', 'XR'],
        };

        const root = document.documentElement;
        const reduceMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
        const contrastQuery = window.matchMedia('(prefers-contrast: more)');
        const controls = {
            speed: document.getElementById('speedControl'),
            speedOutput: document.getElementById('speedValue'),
            auto: document.getElementById('autoToggle'),
            trigger: document.querySelector('.randomize-all'),
            theme: document.getElementById('themeControl'),
            reset: document.querySelector('.reset-controls'),
        };
        const snapshotButtons = {
            save: document.getElementById('snapshotSave'),
            restore: document.getElementById('snapshotRestore'),
            copy: document.getElementById('snapshotCopy'),
        };
        const snapshotStatus = document.getElementById('snapshotStatus');
        const snapshotNote = document.getElementById('snapshotNote');
        const snapshotStorageKey = 'vib34dSnapshot';
        const status = document.getElementById('statusReadout');
        const cards = document.querySelectorAll('.card');
        const themePresets = {
            'aurora-cascade': {
                bg: 'radial-gradient(circle at 20% 20%, rgba(255, 0, 255, 0.12), transparent 45%), radial-gradient(circle at 80% 10%, rgba(0, 255, 255, 0.1), transparent 40%), #05030d',
                grid: 'rgba(0, 255, 255, 0.12)',
                shadow: '0 10px 30px rgba(0, 0, 0, 0.45)',
                label: 'Aurora Cascade',
            },
            'circuit-bloom': {
                bg: 'radial-gradient(circle at 15% 25%, rgba(0, 255, 180, 0.14), transparent 50%), radial-gradient(circle at 75% 15%, rgba(255, 120, 255, 0.16), transparent 42%), #03040f',
                grid: 'rgba(0, 255, 200, 0.16)',
                shadow: '0 14px 36px rgba(0, 20, 40, 0.55)',
                label: 'Circuit Bloom',
            },
            'luminous-grid': {
                bg: 'radial-gradient(circle at 18% 18%, rgba(255, 190, 120, 0.16), transparent 52%), radial-gradient(circle at 82% 12%, rgba(255, 90, 160, 0.14), transparent 48%), #08030e',
                grid: 'rgba(255, 210, 140, 0.18)',
                shadow: '0 16px 34px rgba(30, 0, 40, 0.55)',
                label: 'Luminous Grid',
            },
        };
        const defaultSettings = {
            speed: 120,
            theme: 'aurora-cascade',
            auto: false,
        };

        let cascadeDelay = Number(controls.speed.value);
        let autoTimer = null;
        let cascadeCount = 0;
        let snapshotData = null;
        let suppressDirtyFlag = false;

        const toRgb = (hue) => {
            const clampHue = ((hue % 360) + 360) % 360;
            const c = 1;
            const x = 1 - Math.abs(((clampHue / 60) % 2) - 1);
            let r = 0, g = 0, b = 0;
            if (clampHue < 60) [r, g, b] = [c, x, 0];
            else if (clampHue < 120) [r, g, b] = [x, c, 0];
            else if (clampHue < 180) [r, g, b] = [0, c, x];
            else if (clampHue < 240) [r, g, b] = [0, x, c];
            else if (clampHue < 300) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            return `${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}`;
        };

        function updateStatus(message) {
            status.textContent = message;
        }

        function updateSnapshotNote(message) {
            if (!snapshotNote) return;
            snapshotNote.textContent = message;
        }

        function updateSnapshotStatus(label, note) {
            if (snapshotStatus) {
                snapshotStatus.textContent = label;
            }
            if (typeof note === 'string') {
                updateSnapshotNote(note);
            }
        }

        function toggleSnapshotButtons(enabled) {
            if (!snapshotButtons) return;
            ['restore', 'copy'].forEach((key) => {
                const button = snapshotButtons[key];
                if (!button) return;
                button.disabled = !enabled;
                button.setAttribute('aria-disabled', enabled ? 'false' : 'true');
            });
        }

        function markSnapshotDirty() {
            if (suppressDirtyFlag) {
                return;
            }
            if (snapshotData) {
                updateSnapshotStatus('modified', 'Adjustments differ from the saved snapshot.');
            } else {
                updateSnapshotStatus('unsaved', 'No snapshot stored yet.');
            }
        }

        function captureSnapshot() {
            return {
                speed: Number(controls.speed.value),
                theme: controls.theme ? controls.theme.value : defaultSettings.theme,
                auto: controls.auto ? controls.auto.checked : false,
            };
        }

        function applySnapshot(data, { announce = true } = {}) {
            if (!data) return;
            suppressDirtyFlag = true;

            if (Number.isFinite(Number(data.speed))) {
                controls.speed.value = Number(data.speed);
                controls.speed.dispatchEvent(new Event('input'));
            }

            if (controls.theme && data.theme) {
                controls.theme.value = data.theme;
                const previousSuppress = suppressDirtyFlag;
                suppressDirtyFlag = true;
                applyTheme(data.theme, { announce: false });
                suppressDirtyFlag = previousSuppress;
            }

            if (controls.auto) {
                controls.auto.checked = Boolean(data.auto);
            }

            if (data.auto) {
                startAutoCascade();
            } else {
                stopAutoCascade();
            }

            suppressDirtyFlag = false;
            updateSnapshotStatus('synced', 'Snapshot restored.');
            if (announce) {
                updateStatus('snapshot restored');
            }
        }

        function handleContrastChange(event, { announce = false } = {}) {
            const enable = event.matches;
            document.body.classList.toggle('high-contrast', enable);
            if (announce) {
                updateStatus(
                    enable
                        ? 'high contrast preference detected — visuals boosted'
                        : 'high contrast preference cleared — standard palette'
                );
            }
        }

        toggleSnapshotButtons(false);
        updateSnapshotStatus('unsaved', 'No snapshot stored yet.');

        try {
            const storedSnapshot = localStorage.getItem(snapshotStorageKey);
            if (storedSnapshot) {
                const parsed = JSON.parse(storedSnapshot);
                if (parsed) {
                    snapshotData = parsed;
                    toggleSnapshotButtons(true);
                    updateSnapshotStatus('synced', 'Snapshot available from a previous session.');
                }
            }
        } catch (error) {
            console.warn('Unable to restore VIB34D snapshot from storage.', error);
        }

        if (snapshotButtons.save) {
            snapshotButtons.save.addEventListener('click', () => {
                snapshotData = captureSnapshot();
                toggleSnapshotButtons(true);
                updateSnapshotStatus('synced', 'Snapshot stored locally and ready to restore.');
                try {
                    localStorage.setItem(snapshotStorageKey, JSON.stringify(snapshotData));
                } catch (error) {
                    console.warn('Unable to persist VIB34D snapshot.', error);
                }
                updateStatus('snapshot saved');
            });
        }

        if (snapshotButtons.restore) {
            snapshotButtons.restore.addEventListener('click', () => {
                if (!snapshotData) {
                    try {
                        const stored = localStorage.getItem(snapshotStorageKey);
                        if (stored) {
                            snapshotData = JSON.parse(stored);
                        }
                    } catch (error) {
                        console.warn('Unable to access stored VIB34D snapshot.', error);
                    }
                }

                if (snapshotData) {
                    applySnapshot(snapshotData);
                } else {
                    updateSnapshotStatus('unsaved', 'Save a snapshot before restoring.');
                }
            });
        }

        if (snapshotButtons.copy) {
            snapshotButtons.copy.addEventListener('click', async () => {
                if (!snapshotData) {
                    updateSnapshotStatus('unsaved', 'Save a snapshot before copying.');
                    return;
                }

                const payload = JSON.stringify(snapshotData);
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(payload);
                        updateSnapshotStatus('copied', 'Snapshot JSON copied to clipboard.');
                        updateStatus('snapshot copied');
                    } else {
                        throw new Error('Clipboard API unavailable');
                    }
                } catch (error) {
                    updateSnapshotStatus('synced', 'Copy failed. Snapshot JSON logged to console.');
                    console.warn('Snapshot copy fallback:', error, payload);
                }
            });
        }

        function applyTheme(key, { announce = true } = {}) {
            const preset = themePresets[key];
            if (!preset) return;
            root.style.setProperty('--bg', preset.bg);
            root.style.setProperty('--grid-color', preset.grid);
            root.style.setProperty('--card-shadow', preset.shadow);
            if (controls.theme) {
                controls.theme.value = key;
            }
            if (announce) {
                updateStatus(`${preset.label.toLowerCase()} palette engaged`);
            }
            markSnapshotDirty();
        }

        function randomBetween([min, max]) {
            return Math.random() * (max - min) + min;
        }

        function pickRandom(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function buildState(card) {
            const hue = randomBetween(PARAM_LIMITS.hue);
            return {
                hue,
                glow: toRgb(hue),
                gradientSkew: randomBetween(PARAM_LIMITS.gradientSkew),
                gridSize: randomBetween(PARAM_LIMITS.gridSize),
                morph: randomBetween(PARAM_LIMITS.morph),
                rotation: randomBetween(PARAM_LIMITS.rotation),
                glitch: randomBetween(PARAM_LIMITS.glitch),
                dimension: pickRandom(PARAM_LIMITS.dimension),
                layout: pickRandom(JSON.parse(card.dataset.layouts || '[]')) || 'GRID',
            };
        }

        function applyState(card, state) {
            card.style.setProperty('--hue', state.hue.toFixed(2));
            card.style.setProperty('--glow-rgb', state.glow);
            card.style.setProperty('--saturation', (1 + state.glitch * 1.5).toFixed(2));
            card.style.setProperty('--grid-angle', `${state.gradientSkew.toFixed(1)}deg`);
            card.style.setProperty('--grid-size', `${state.gridSize.toFixed(0)}px`);
            card.style.setProperty('--tilt-x', `${(state.rotation * 14 - 4).toFixed(2)}deg`);
            card.style.setProperty('--tilt-y', `${(state.rotation * 10 - 3).toFixed(2)}deg`);
            card.style.setProperty('--lift', `${-state.morph * 12}px`);
            card.style.setProperty('--scan-speed', `${(12 - state.rotation * 6).toFixed(2)}s`);

            const params = card.querySelectorAll('.param span');
            params[0].textContent = `${state.hue.toFixed(0)}°`;
            params[1].textContent = state.morph.toFixed(2);
            params[2].textContent = Math.round(state.gridSize / 6);
            params[3].textContent = `${state.rotation.toFixed(2)}x`;
            params[4].textContent = state.glitch.toFixed(2);
            params[5].textContent = state.dimension;
            const stateLabel = card.querySelector('.card-state');
            if (stateLabel) stateLabel.textContent = state.layout;
        }

        function cascade(card, iterations = 25) {
            const states = Array.from({ length: iterations }, () => buildState(card));
            let index = 0;
            const delay = reduceMotionQuery.matches ? 0 : cascadeDelay;
            const tick = () => {
                applyState(card, states[index]);
                index += 1;
                if (index < states.length) {
                    window.setTimeout(tick, delay);
                }
            };
            tick();
        }

        function broadcastCascade(source = 'manual') {
            let offset = 0;
            cards.forEach((card) => {
                window.setTimeout(() => cascade(card), offset);
                offset += reduceMotionQuery.matches ? 0 : 90;
            });
            cascadeCount += 1;
            updateStatus(`${source === 'auto' ? 'auto' : 'manual'} cascade #${cascadeCount}`);
        }

        function stopAutoCascade() {
            if (autoTimer) {
                clearInterval(autoTimer);
                autoTimer = null;
            }
        }

        function startAutoCascade() {
            stopAutoCascade();
            const interval = Math.max(1600, (cascadeDelay || 60) * 18);
            autoTimer = setInterval(() => broadcastCascade('auto'), interval);
            updateStatus('auto cascade engaged');
        }

        cards.forEach((card) => {
            card.addEventListener('click', (event) => {
                event.stopPropagation();
                cascade(card);
                updateStatus(`card cascade → ${card.querySelector('.card-title')?.textContent || 'card'}`);
            });
        });

        controls.trigger.addEventListener('click', () => {
            broadcastCascade('manual');
        });

        controls.speed.addEventListener('input', (event) => {
            cascadeDelay = Number(event.target.value);
            controls.speedOutput.textContent = `${cascadeDelay}ms`;
            root.style.setProperty('--cascade-delay', cascadeDelay);
            if (autoTimer) {
                startAutoCascade();
            }
            markSnapshotDirty();
        });

        controls.auto.addEventListener('change', (event) => {
            if (event.target.checked) {
                startAutoCascade();
            } else {
                stopAutoCascade();
                updateStatus('auto cascade paused');
            }
            markSnapshotDirty();
        });

        if (controls.theme) {
            controls.theme.addEventListener('change', (event) => {
                applyTheme(event.target.value);
            });
        }

        if (controls.reset) {
            controls.reset.addEventListener('click', () => {
                stopAutoCascade();
                controls.speed.value = defaultSettings.speed;
                controls.speed.dispatchEvent(new Event('input'));
                controls.auto.checked = defaultSettings.auto;
                applyTheme(defaultSettings.theme, { announce: false });
                if (defaultSettings.auto) {
                    startAutoCascade();
                }
                updateStatus('controls reset to defaults');
                markSnapshotDirty();
            });
        }

        function handleReduceMotion(event) {
            const reduce = event.matches;
            document.body.classList.toggle('reduce-motion', reduce);
            controls.speed.disabled = reduce;
            controls.auto.disabled = reduce;
            if (reduce) {
                cascadeDelay = 0;
                root.style.setProperty('--cascade-delay', cascadeDelay);
                controls.speedOutput.textContent = 'instant';
                controls.auto.checked = false;
                stopAutoCascade();
                updateStatus('reduced motion active');
            } else {
                cascadeDelay = Number(controls.speed.value);
                root.style.setProperty('--cascade-delay', cascadeDelay);
                controls.speedOutput.textContent = `${cascadeDelay}ms`;
                updateStatus('ready');
            }
        }

        reduceMotionQuery.addEventListener('change', handleReduceMotion);
        handleReduceMotion(reduceMotionQuery);
        contrastQuery.addEventListener('change', (event) => handleContrastChange(event, { announce: true }));
        handleContrastChange(contrastQuery);
        applyTheme(defaultSettings.theme, { announce: false });
        updateStatus('ready');
    </script>
</body>
</html>
