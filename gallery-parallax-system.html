<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Codex Gallery - Parallax Scroll System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        :root {
            --neon-cyan: #00ffff;
            --neon-magenta: #ff00ff;
            --neon-yellow: #ffff00;
            --electric-blue: #0080ff;
            --hot-pink: #ff1088;
            --cyber-purple: #8000ff;
            --card-bg: rgba(16, 16, 32, 0.95);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: var(--neon-cyan);
            font-family: 'Orbitron', 'Courier New', monospace;
            overflow-x: hidden;
            cursor: crosshair;
        }
        body.modal-open {
            overflow: hidden;
        }

       
        /* EVOLVING BACKGROUND SYSTEM */
        .background-visualizer-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            opacity: 0.6;
        }
        
        .background-visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: opacity 1s ease;
        }
        
        .background-visualizer.inactive {
            opacity: 0;
            pointer-events: none;
        }
        
        .background-visualizer.active {
            opacity: 1;
        }
        
        /* PARALLAX SCROLL CONTAINER */
        .parallax-container {
            height: 800vh; /* 8 sections Ã— 100vh */
            position: relative;
        }
        
        /* FLOATING CARDS SYSTEM */
        .floating-cards-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            max-width: 1200px;
            height: 80vh;
            z-index: 100;
            pointer-events: none;
        }
        
        .card-section {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 20px;
            opacity: 0;
            transform: scale(0.8) translateY(50px);
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
        }
        
        .card-section.active {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: all;
        }
        .card-section[data-card-count="4"] {
            grid-template-columns: repeat(2, minmax(0, 1fr));
            grid-template-rows: repeat(2, minmax(0, 1fr));
            justify-items: center;
        }
        .card-section[data-card-count="5"] {
            grid-template-columns: repeat(3, minmax(0, 1fr));
            grid-auto-rows: minmax(0, 1fr);
            align-content: center;
        }
        .card-section[data-card-count="4"] .floating-card,
        .card-section[data-card-count="5"] .floating-card {
            margin: 0 auto;
        }
        
        .floating-card {
            background: var(--card-bg);
            border: 2px solid var(--neon-cyan);
            border-radius: 15px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.3s ease, border-color 0.3s ease;
            cursor: pointer;
            pointer-events: all;
            will-change: transform;
            display: flex;
            flex-direction: column;
        }

        .floating-card:hover {
            box-shadow:
                0 0 50px var(--neon-magenta),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-color: var(--neon-magenta);
        }

        .floating-card h3 {
            color: var(--neon-yellow);
            margin-bottom: 10px;
            font-size: 1.1em;
            text-shadow: 0 0 10px var(--neon-yellow);
        }
        
        .floating-card p {
            color: var(--neon-cyan);
            font-size: 0.8em;
            line-height: 1.4;
            margin-bottom: 15px;
            flex-grow: 1;
        }
        
        .floating-card .card-footer {
            margin-top: 1.1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.72em;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(210, 240, 255, 0.7);
        }

        .floating-card .card-cta {
            padding: 0.4rem 0.85rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 0, 255, 0.35);
            color: rgba(255, 0, 255, 0.75);
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        .floating-card:hover .card-cta {
            background: rgba(255, 0, 255, 0.18);
            border-color: rgba(255, 0, 255, 0.55);
        }

        .floating-card .tags {
            display: flex;
            gap: 6px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .floating-card .tag {
            background: rgba(255, 0, 255, 0.2);
            color: var(--neon-magenta);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.6em;
            border: 1px solid var(--neon-magenta);
        }
        .floating-card .evolution-callout {
            margin-top: 0.6rem;
            font-size: 0.62em;
            letter-spacing: 0.2em;
            color: rgba(255, 0, 255, 0.75);
        }
        .floating-card .evolution-callout strong {
            color: rgba(255, 255, 255, 0.88);
        }
        

        /* PARALLAX MODAL */
        .parallax-modal {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, 0.78);
            backdrop-filter: blur(16px);
            z-index: 4000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.35s ease;
        }

        .parallax-modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .parallax-modal-shell {
            width: min(1180px, 94vw);
            height: min(92vh, 860px);
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 2rem;
            padding: 2rem;
            background: rgba(6, 10, 24, 0.94);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 26px;
            box-shadow:
                0 40px 90px rgba(0, 0, 0, 0.6),
                0 0 55px rgba(0, 255, 255, 0.32);
            position: relative;
            overflow: hidden;
        }

        .parallax-modal-close {
            position: absolute;
            top: 18px;
            right: 18px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 1px solid rgba(255, 0, 255, 0.45);
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.85);
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .parallax-modal-close:hover,
        .parallax-modal-close:focus-visible {
            background: rgba(255, 0, 255, 0.3);
            color: white;
            outline: none;
        }

        .parallax-modal-main {
            border-radius: 18px;
            overflow: hidden;
            border: 1px solid rgba(0, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.45);
            position: relative;
        }

        .parallax-modal-main iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: #000;
        }

        .parallax-modal-sidebar {
            display: grid;
            grid-template-rows: auto auto 1fr auto;
            gap: 1rem;
        }

        .parallax-modal-sidebar h2 {
            font-size: 1.35rem;
            letter-spacing: 0.18em;
            color: var(--neon-yellow);
            text-transform: uppercase;
        }

        .parallax-modal-sidebar p {
            font-size: 0.78rem;
            letter-spacing: 0.16em;
            color: rgba(210, 240, 255, 0.75);
            line-height: 1.6;
        }
        .modal-evolution {
            font-size: 0.7rem;
            letter-spacing: 0.18em;
            color: rgba(255, 0, 255, 0.7);
            margin-top: 0.45rem;
            display: block;
        }

        .parallax-modal-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .parallax-modal-tags span {
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 255, 255, 0.12);
            font-size: 0.65rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: rgba(230, 255, 255, 0.8);
        }

        .parallax-modal-scroll {
            border-radius: 16px;
            border: 1px solid rgba(0, 255, 255, 0.18);
            background: rgba(3, 6, 16, 0.5);
            overflow: hidden;
            position: relative;
        }

        .parallax-modal-scroll::before,
        .parallax-modal-scroll::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 80px;
            z-index: 2;
            pointer-events: none;
        }

        .parallax-modal-scroll::before {
            top: 0;
            background: linear-gradient(180deg, rgba(6, 10, 24, 0.95), transparent);
        }

        .parallax-modal-scroll::after {
            bottom: 0;
            background: linear-gradient(0deg, rgba(6, 10, 24, 0.95), transparent);
        }

        .parallax-modal-track {
            height: 100%;
            overflow-y: scroll;
            padding: 2.25rem 1rem;
        }

        .parallax-modal-item {
            padding: 1rem 1.1rem;
            margin-bottom: 1rem;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.18);
            background: rgba(6, 12, 32, 0.6);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.28);
            font-size: 0.72rem;
            letter-spacing: 0.18em;
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
            transition: transform 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
        }

        .parallax-modal-item strong {
            color: rgba(255, 255, 255, 0.85);
        }

        .parallax-modal-item span {
            color: rgba(210, 240, 255, 0.6);
            font-size: 0.65rem;
        }

        .parallax-modal-item.active {
            border-color: rgba(255, 0, 255, 0.5);
            transform: scale(1.03);
            box-shadow:
                0 15px 45px rgba(0, 0, 0, 0.3),
                0 0 25px rgba(255, 0, 255, 0.25);
        }

        .parallax-modal-foot {
            font-size: 0.72rem;
            letter-spacing: 0.2em;
            color: rgba(210, 240, 255, 0.65);
            display: flex;
            justify-content: space-between;
            gap: 0.8rem;
            flex-wrap: wrap;
        }

        @media (max-width: 960px) {
            .parallax-modal-shell {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                height: min(94vh, 920px);
            }

            .parallax-modal-scroll {
                max-height: 280px;
            }

            .parallax-modal-foot {
                justify-content: center;
            }
        }

        /* NAVIGATION SYSTEM */
        .scroll-indicator {
            position: fixed;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
        }
        
        .scroll-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid var(--neon-cyan);
            background: transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .scroll-dot.active {
            background: var(--neon-cyan);
            box-shadow: 0 0 20px var(--neon-cyan);
        }
        
        .scroll-dot:hover {
            transform: scale(1.3);
            border-color: var(--neon-magenta);
        }
        
        /* SECTION PROGRESS INDICATOR */
        .section-info {
            position: fixed;
            top: 30px;
            left: 30px;
            background: var(--card-bg);
            border: 2px solid var(--neon-cyan);
            border-radius: 10px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        .section-title {
            color: var(--neon-yellow);
            font-size: 1.2em;
            margin-bottom: 5px;
            text-shadow: 0 0 10px var(--neon-yellow);
        }
        
        .section-subtitle {
            color: var(--neon-cyan);
            font-size: 0.8em;
        }
        
        /* CHAOS INTENSITY INDICATOR */
        .chaos-meter {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: var(--card-bg);
            border: 2px solid var(--electric-blue);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        .chaos-meter-title {
            color: var(--electric-blue);
            font-size: 0.9em;
            margin-bottom: 8px;
        }
        
        .chaos-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 128, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .chaos-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--electric-blue), var(--hot-pink));
            border-radius: 4px;
            transition: width 0.5s ease;
            box-shadow: 0 0 10px var(--electric-blue);
        }
        
        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .card-section {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(6, 1fr);
                gap: 15px;
            }
            
            .floating-cards-container {
                width: 95vw;
                height: 90vh;
            }
            
            .floating-card {
                padding: 15px;
            }
            
            .floating-card .preview-area {
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <!-- Background Visualizer Container -->
    <div class="background-visualizer-container" id="backgroundContainer">
        <!-- 8 background visualizers will be created dynamically -->
    </div>
    
    <!-- Section Info -->
    <div class="section-info">
        <div class="section-title" id="sectionTitle">Spectral Interface Shells</div>
        <div class="section-subtitle" id="sectionSubtitle">Section 1 of 8 â€¢ Hypercube Genesis</div>
    </div>
    
    <!-- Chaos Meter -->
    <div class="chaos-meter">
        <div class="chaos-meter-title">Chaos Intensity</div>
        <div class="chaos-bar">
            <div class="chaos-fill" id="chaosFill" style="width: 15%;"></div>
        </div>
    </div>
    
    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scrollIndicator">
        <!-- 8 dots will be created dynamically -->
    </div>
    
    <!-- Parallax Container -->
    <div class="parallax-container" id="parallaxContainer"></div>
    
    <!-- Floating Cards Container -->
    <div class="floating-cards-container" id="floatingCards">
        <!-- 8 card sections will be created dynamically -->
    </div>


    <div class="parallax-modal" id="parallaxModal" role="dialog" aria-modal="true" aria-labelledby="parallaxModalTitle">
        <div class="parallax-modal-shell">
            <button class="parallax-modal-close" id="parallaxModalClose" aria-label="Close modal">Ã—</button>
            <div class="parallax-modal-main">
                <iframe id="parallaxModalFrame" title="Parallax demo preview"></iframe>
            </div>
            <div class="parallax-modal-sidebar">
                <h2 id="parallaxModalTitle">Effect Title</h2>
                <p id="parallaxModalDescription">Description</p>
                <div class="parallax-modal-tags" id="parallaxModalTags"></div>
                <div class="parallax-modal-scroll" id="parallaxModalScroll">
                    <div class="parallax-modal-track" id="parallaxModalTrack"></div>
                </div>
                <div class="parallax-modal-foot" id="parallaxModalFoot">
                    <span id="parallaxModalGroup"></span>
                    <span id="parallaxModalType"></span>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('ðŸŒŒ Visual Codex Parallax System - Advanced Scroll Physics');
        
        // VISUAL EFFECTS DATA WITH SMART CANVAS GROUPING
        const visualEffectsGrouped = [
            {
                name: 'Spectral Interface Shells',
                description: 'CSS-driven holo panels, neon typographic grids, and light field overlays.',
                depth: 0.18,
                effects: [
                    { title: 'CSS Glassmorphism Lab', description: 'Layered glass surfaces with animated blur gradients and holographic shine.', tags: ['css', 'glass', 'ui'], file: 'demos/css-glassmorphism-demo.html', type: 'css' },
                    { title: 'CSS Glitch Array', description: 'Reactive glitch shaders driven by keyframe offsets and chromatic noise.', tags: ['css', 'glitch', 'motion'], file: 'demos/css-glitch-effects-demo.html', type: 'css' },
                    { title: 'Cyberpunk UI Mesh', description: 'Hi-fi interface slabs with neon scanlines and hovering microcopy.', tags: ['css', 'cyberpunk', 'ui'], file: 'demos/css-cyberpunk-ui-demo.html', type: 'css' },
                    { title: 'Vaporwave Spectrum', description: 'Gradient planes, CRT curves, and cassette-era typography.', tags: ['css', 'vaporwave', 'gradient'], file: 'demos/css-vaporwave-aesthetics-demo.html', type: 'css' },
                    { title: 'Animated Grid Overlay', description: 'Procedural grid overlays with spectral glows and depth warps.', tags: ['css', 'grid', 'animation'], file: 'demos/animated-grid-overlay-demo.html', type: 'css' }
                ]
            },
            {
                name: 'Holographic Fields & Particles',
                description: 'Multi-layer depth canvases, particle emitters, and responsive overlays.',
                depth: 0.22,
                effects: [
                    { title: 'Holographic Depth Layers', description: 'Stacked depth planes with adaptive parallax and shimmer pulses.', tags: ['webgl', 'depth', 'layers'], file: 'demos/holographic-depth-layers-demo.html', type: 'webgl' },
                    { title: 'Holographic Progress Indicators', description: 'Progress systems with glass arcs and neon data rings.', tags: ['css', 'progress', 'hud'], file: 'demos/holographic-progress-indicators-demo.html', type: 'css' },
                    { title: 'Particle Halo System', description: 'Canvas particle halo orchestrated with noise displacement.', tags: ['canvas', 'particles', 'halo'], file: 'demos/holographic-particle-system-demo.html', type: 'canvas' },
                    { title: 'Chaos Overlay Reactor', description: 'Chaos overlays layered with interference bands and strobing grids.', tags: ['webgl', 'chaos', 'overlay'], file: 'demos/chaos-overlay-effects-demo.html', type: 'webgl' },
                    { title: 'State Control Dots', description: 'Interactive navigation dots with reactive outlines and pulses.', tags: ['css', 'navigation', 'interaction'], file: 'demos/state-control-dots-demo.html', type: 'css' }
                ]
            },
            {
                name: 'Active Holographic Engines',
                description: 'Full spectrum holographic engines with modal expansions and parallax canvases.',
                depth: 0.28,
                effects: [
                    { title: 'Active Holographic Megasuite', description: '35 variation megasuite with pagination and modal infinite scroll.', tags: ['webgl', 'holographic', 'mega'], file: 'demos/active-holographic-systems-mega-demo.html', type: 'webgl', isHeavy: true },
                    { title: 'Tech Layout Active Holographic', description: 'Tech layout grid with synchronized holographic canvases.', tags: ['webgl', 'layout', 'multi-canvas'], file: 'demos/tech-layout-active-holographic-demo.html', type: 'webgl' },
                    { title: 'Parallax Systems Mega', description: 'Layered parallax canvases with atmospheric fog and card choreography.', tags: ['webgl', 'parallax', 'systems'], file: 'demos/holographic-parallax-systems-mega-demo.html', type: 'webgl' },
                    { title: 'Polytopal Consciousness Shader', description: 'Shader-driven polytopal forms with chromatic spill.', tags: ['webgl', 'shader', 'polytopal'], file: 'demos/polytopal-consciousness-shader-demo.html', type: 'webgl' },
                    { title: 'MillzMaleficarum Codex', description: 'Immersive codex with story-driven holographic transitions.', tags: ['webgl', 'codex', 'narrative'], file: 'demos/millzmaleficarum-codex-demo.html', type: 'webgl' }
                ]
            },
            {
                name: 'VIB3 / VIB34D Narratives',
                description: 'Narrative driven layouts powered by VIB3 and VIB34D orchestration.',
                depth: 0.32,
                effects: [
                    { title: 'VIB3CODE Reactive Core', description: 'Reactive hyperAV core with pulse field orchestration.', tags: ['webgl', 'core', 'reactive'], file: 'demos/vib3code-reactive-core-demo.html', type: 'webgl' },
                    { title: 'VIB3CODE Digital Magazine', description: 'Magazine layout blending WebGL hero visuals with text grids.', tags: ['webgl', 'magazine', 'ui'], file: 'demos/vib3code-digital-magazine-demo.html', type: 'webgl' },
                    { title: 'VIB34D Morphing Blog', description: 'Blog navigator with morphing 4D canvases and holo nav.', tags: ['webgl', 'blog', 'morphing'], file: 'demos/vib34d-morphing-blog-demo.html', type: 'webgl' },
                    { title: 'VIB34D Editor Dashboard', description: 'Interactive dashboard with holographic parameter decks.', tags: ['webgl', 'dashboard', 'editor'], file: 'demos/vib34d-editor-dashboard-demo.html', type: 'webgl' },
                    { title: 'VIB34D Production Spectacular', description: 'Production showcase with synchronized stage lighting effects.', tags: ['webgl', 'production', 'showcase'], file: 'demos/vib34d-production-spectacular-demo.html', type: 'webgl' }
                ]
            },
            {
                name: 'Adaptive Interface Systems',
                description: 'Adaptive card systems, orchestration engines, and touch-first controls.',
                depth: 0.26,
                effects: [
                    { title: 'VIB34D Adaptive Cards', description: 'Adaptive card layouts with holo depth and parameter slots.', tags: ['css', 'cards', 'adaptive'], file: 'demos/vib34d-adaptive-cards-demo.html', type: 'css' },
                    { title: 'System Orchestration Engine', description: 'System orchestration controls with reactive monitoring.', tags: ['css', 'system', 'controls'], file: 'demos/system-orchestration-engine-demo.html', type: 'css' },
                    { title: 'Neoskeuomorphic Cards Desktop', description: 'Desktop skeuomorphic cards with layered glows and depth.', tags: ['css', 'skeuomorphic', 'desktop'], file: 'demos/neoskeuomorphic-cards-demo.html', type: 'css' },
                    { title: 'Neoskeuomorphic Cards Mobile', description: 'Mobile tuned skeuomorphic cards with scroll choreography.', tags: ['css', 'skeuomorphic', 'mobile'], file: 'demos/neoskeuomorphic-cards-mobile.html', type: 'css' },
                    { title: 'State Control Dots Mobile', description: 'Mobile optimized dots with gesture aware interactions.', tags: ['css', 'navigation', 'mobile'], file: 'demos/state-control-dots-mobile.html', type: 'css' }
                ]
            },
            {
                name: 'Hypercube Lattice Laboratories',
                description: 'Hypercube visualizers, moirÃ© laboratories, and deep math canvases.',
                depth: 0.34,
                effects: [
                    { title: 'Hypercube Lattice Visualizer', description: 'Export-ready lattice visualizer with collapsible controls.', tags: ['webgl', 'lattice', 'export'], file: 'demos/hypercube-lattice-visualizer-demo.html', type: 'webgl' },
                    { title: 'MoirÃ© Hypercube Codex', description: 'MoirÃ© codex with export pipeline and holographic overlays.', tags: ['webgl', 'moire', 'codex'], file: 'demos/moire-hypercube-codex-demo.html', type: 'webgl' },
                    { title: 'MVEP 4D Hypercube Lab', description: 'Touch reactive MVEP system with scroll-parameter mapping.', tags: ['webgl', '4d', 'mvep'], file: 'effects/mvep-moire-hypercube.html', type: 'webgl' },
                    { title: 'Hyperdimensional Matrix', description: '8D+ hyperdimensional matrix with collapsible control suite.', tags: ['webgl', 'matrix', 'chaos'], file: 'effects/insane-hyperdimensional-matrix.html', type: 'webgl' },
                    { title: 'Hypercube Core Framework', description: 'Hypercube core WebGL framework with geometry switchers.', tags: ['webgl', 'framework', 'core'], file: 'effects/hypercube-core-webgl-framework.html', type: 'webgl' }
                ]
            },
            {
                name: 'Advanced Framework Archives',
                description: 'Framework archives showcasing orchestration layers and CSS/JS hybrids.',
                depth: 0.24,
                effects: [
                    { title: 'VIB34D Complete System', description: 'Complete 4D framework with collapsible analysis deck.', tags: ['webgl', 'framework', 'vib34d'], file: 'effects/vib34d-complete-system.html', type: 'webgl' },
                    { title: 'Multi-Canvas Visualizer', description: 'Multi canvas coordinator with synchronized geometry.', tags: ['webgl', 'multi-canvas', 'sync'], file: 'effects/multi-canvas-visualizer-system.html', type: 'webgl' },
                    { title: 'Elegant 4D Flow Visualizer', description: 'Organic 4D flow orchestrator with curvature fields.', tags: ['webgl', '4d', 'flow'], file: 'effects/elegant-4d-flow-visualizer.html', type: 'webgl' },
                    { title: 'Narrative Choreography Engine', description: 'Timeline driven narrative choreography engine.', tags: ['css', 'narrative', 'timeline'], file: 'effects/narrative-choreography-engine.html', type: 'css' },
                    { title: 'Advanced Card Bending', description: 'Advanced card bending system with mobile ready layout.', tags: ['css', 'cards', '3d'], file: 'effects/vib34d-advanced-card-bending-system.html', type: 'css' }
                ]
            },
            {
                name: 'Phase III Evolution Paths',
                description: 'Evolution pathways bridging codex, lattice, MVEP, and megasuite upgrades.',
                depth: 0.38,
                evolutionSummary: 'Evolution synergy deck',
                evolutionIntensity: 0.12,
                effects: [
                    {
                        title: 'Codex Evolution Deck',
                        description: 'MoirÃ© codex evolutions with luminous weave, sequencing, and export journals.',
                        tags: ['webgl', 'codex', 'evolution'],
                        file: 'demos/moire-hypercube-codex-demo.html',
                        type: 'webgl',
                        evolution: { stage: 'EVO-Î©', summary: 'Pairs luminous weave presets with evolution sequencer.', pairings: ['Hypercube Codex', 'Evolution Cycle'] }
                    },
                    {
                        title: 'Lattice Resonant Scenes',
                        description: 'Hypercube lattice visualizer with resonant scenes, traversal cycle, and flux sliders.',
                        tags: ['webgl', 'lattice', 'scenes'],
                        file: 'demos/hypercube-lattice-visualizer-demo.html',
                        type: 'webgl',
                        evolution: { stage: 'EVO-Î£', summary: 'Scene traversal toggles with flux/phase control.', pairings: ['Traversal Cycle', 'Flux Field'] }
                    },
                    {
                        title: 'MVEP Touch Sequencer',
                        description: 'Touch sequencer with evolution cycle, trail persistence, and resonance warp controls.',
                        tags: ['webgl', 'touch', 'sequencer'],
                        file: 'effects/mvep-moire-hypercube.html',
                        type: 'webgl',
                        evolution: { stage: 'EVO-Î›', summary: 'Sequenced touch ripples with evolution palettes.', pairings: ['Touch Ripples', 'Audio Sync'] }
                    },
                    {
                        title: 'Megasuite Evolution Deck',
                        description: 'Active holographic megasuite with evolution banner integration and 41-variation deck.',
                        tags: ['webgl', 'megasuite', 'evolution'],
                        file: 'demos/active-holographic-systems-mega-demo.html',
                        type: 'webgl',
                        evolution: { stage: 'EVO-Îž', summary: 'Evolution pathways surfaced inside holographic cards.', pairings: ['Evolution Banner', 'Modal Sequence'] }
                    },
                    {
                        title: 'Codex Memory Loom',
                        description: 'Persistent codex evolutions that restore luminous weave states between sessions.',
                        tags: ['webgl', 'codex', 'memory'],
                        file: 'demos/moire-hypercube-codex-demo.html',
                        type: 'webgl',
                        evolution: { stage: 'EVO-Î¨', summary: 'Memory imprinting with codex archive persistence.', pairings: ['Memory Deck', 'Evolution Log'] }
                    },
                    {
                        title: 'Fusion Weave Vault',
                        description: 'Hypercube lattice fusion controls layering scene weaves and hybrid pulses.',
                        tags: ['webgl', 'lattice', 'fusion'],
                        file: 'demos/hypercube-lattice-visualizer-demo.html',
                        type: 'webgl',
                        evolution: { stage: 'EVO-Î¦', summary: 'Scene fusion blends with traversal resonance.', pairings: ['Fusion Weaves', 'Traversal Cycle'] }
                    }
                ]
            }
        ];


        class ParallaxModal {
            constructor(effects) {
                this.effects = effects;
                this.modal = document.getElementById('parallaxModal');
                this.closeButton = document.getElementById('parallaxModalClose');
                this.frame = document.getElementById('parallaxModalFrame');
                this.title = document.getElementById('parallaxModalTitle');
                this.description = document.getElementById('parallaxModalDescription');
                this.tags = document.getElementById('parallaxModalTags');
                this.groupLabel = document.getElementById('parallaxModalGroup');
                this.typeLabel = document.getElementById('parallaxModalType');
                this.scrollShell = document.getElementById('parallaxModalScroll');
                this.track = document.getElementById('parallaxModalTrack');
                this.activeIndex = 0;
                this.itemHeight = 120;
                this.loopHeight = 0;
                this.isAdjusting = false;

                this.buildTrack();
                this.attachEvents();
            }

            buildTrack() {
                const fragment = document.createDocumentFragment();
                const loops = 3;
                for (let loop = 0; loop < loops; loop++) {
                    this.effects.forEach((effect, index) => {
                        const item = document.createElement('div');
                        item.className = 'parallax-modal-item';
                        item.dataset.index = index;
                        const stageLabel = effect.evolution ? `<span>${effect.evolution.stage}</span>` : '';
                        item.innerHTML = `
                            <strong>${(index + 1).toString().padStart(2, '0')} â€” ${effect.title}</strong>
                            <span>${effect.groupName}</span>
                            ${stageLabel}
                        `;
                        fragment.appendChild(item);
                    });
                }
                this.track.appendChild(fragment);
                this.loopHeight = this.track.scrollHeight / loops;
            }

            attachEvents() {
                this.closeButton.addEventListener('click', () => this.close());
                this.modal.addEventListener('click', (event) => {
                    if (event.target === this.modal) {
                        this.close();
                    }
                });

                this.scrollShell.addEventListener('scroll', () => {
                    if (this.isAdjusting) return;
                    this.handleScroll();
                });
            }

            open(index) {
                this.modal.classList.add('visible');
                document.body.classList.add('modal-open');
                this.applyIndex(index);
                this.setScrollPosition(index);
            }

            close() {
                this.modal.classList.remove('visible');
                document.body.classList.remove('modal-open');
            }

            setScrollPosition(index) {
                const base = this.loopHeight;
                this.isAdjusting = true;
                this.scrollShell.scrollTop = base + index * this.itemHeight;
                requestAnimationFrame(() => (this.isAdjusting = false));
            }

            handleScroll() {
                const max = this.loopHeight * 2;
                if (this.scrollShell.scrollTop < this.loopHeight * 0.45) {
                    this.isAdjusting = true;
                    this.scrollShell.scrollTop += this.loopHeight;
                    requestAnimationFrame(() => (this.isAdjusting = false));
                    return;
                }
                if (this.scrollShell.scrollTop > max - this.loopHeight * 0.45) {
                    this.isAdjusting = true;
                    this.scrollShell.scrollTop -= this.loopHeight;
                    requestAnimationFrame(() => (this.isAdjusting = false));
                    return;
                }

                const normalized = (this.scrollShell.scrollTop % this.loopHeight) / this.loopHeight;
                const targetIndex = Math.min(this.effects.length - 1, Math.floor(normalized * this.effects.length));
                if (targetIndex !== this.activeIndex) {
                    this.applyIndex(targetIndex);
                }
            }

            applyIndex(index) {
                this.activeIndex = index;
                const effect = this.effects[index];
                if (this.frame.dataset.src !== effect.file) {
                    this.frame.dataset.src = effect.file;
                    this.frame.src = effect.file;
                }

                this.title.textContent = effect.title;
                if (effect.evolution) {
                    const pairingText = effect.evolution.pairings ? `<span class="modal-evolution">Pairings: ${effect.evolution.pairings.join(' â€¢ ')}</span>` : '';
                    this.description.innerHTML = `${effect.description}<span class="modal-evolution">${effect.evolution.stage} â€¢ ${effect.evolution.summary}</span>${pairingText}`;
                } else {
                    this.description.textContent = effect.description;
                }
                const tagList = [...effect.tags];
                if (effect.evolution) {
                    tagList.push(effect.evolution.stage);
                }
                this.tags.innerHTML = tagList.map(tag => `<span>${tag}</span>`).join('');
                this.groupLabel.textContent = effect.evolution
                    ? `${effect.groupName} â€¢ ${effect.evolution.stage}`
                    : effect.groupName;
                this.typeLabel.textContent = effect.type.toUpperCase();

                [...this.track.children].forEach((item) => {
                    item.classList.toggle('active', Number(item.dataset.index) === index);
                });
            }
        }

// BACKGROUND VISUALIZER THEMES
        const backgroundThemes = [
            { name: 'Hypercube Genesis', geometry: 'hypercube', chaos: 0.15, speed: 0.3 },
            { name: 'Plasma Emergence', geometry: 'plasma', chaos: 0.35, speed: 0.5 },
            { name: 'Neural Awakening', geometry: 'neural', chaos: 0.50, speed: 0.7 },
            { name: 'Crystal Resonance', geometry: 'crystal', chaos: 0.65, speed: 0.9 },
            { name: 'Quantum Chaos', geometry: 'quantum', chaos: 0.80, speed: 1.2 },
            { name: 'Fractal Storm', geometry: 'fractal', chaos: 0.90, speed: 1.5 },
            { name: 'Dimensional Collapse', geometry: 'matrix', chaos: 1.0, speed: 2.0 },
            { name: 'Evolution Flux', geometry: 'evolution', chaos: 1.05, speed: 2.2 }
        ];
        
        // ADVANCED HOLOGRAPHIC BACKGROUND VISUALIZER
        class HolographicBackgroundVisualizer {
            constructor(canvas, theme, sectionIndex) {
                this.canvas = canvas;
                this.theme = theme;
                this.sectionIndex = sectionIndex;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    console.error('WebGL not supported for background visualizer');
                    return;
                }
                
                this.scrollProgress = 0;
                this.chaosLevel = theme.chaos;
                this.baseSpeed = theme.speed;
                this.rotationSpeed = 0;
                this.densityMultiplier = 1.0;
                
                this.startTime = Date.now();
                this.initShaders();
                this.initBuffers();
                this.resize();
                
                console.log(`âœ… Background Visualizer ${sectionIndex}: ${theme.name} (Chaos: ${theme.chaos})`);
            }
            
            initShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;
                
                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform vec2 u_resolution;
                    uniform float u_time;
                    uniform float u_scrollProgress;
                    uniform float u_chaosLevel;
                    uniform float u_rotationSpeed;
                    uniform float u_densityMultiplier;
                    uniform float u_geometryType;
                    
                    // Enhanced 4D rotation system
                    mat4 rotateXW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);
                    }
                    
                    mat4 rotateYW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1, 0, 0, 0, 0, c, 0, -s, 0, 0, 1, 0, 0, s, 0, c);
                    }
                    
                    mat4 rotateZW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);
                    }
                    
                    vec3 project4Dto3D(vec4 p) {
                        float w = 2.0 / (2.0 + p.w);
                        return vec3(p.x * w, p.y * w, p.z * w);
                    }
                    
                    // Chaos-driven geometry functions
                    float hypercubeGeometry(vec3 p, float density, float chaos) {
                        vec3 grid = fract(p * density * (1.0 + chaos * 3.0));
                        vec3 edges = 1.0 - smoothstep(0.0, 0.02 * (1.0 + chaos), abs(grid - 0.5));
                        float corners = length(grid - 0.5);
                        corners = 1.0 - smoothstep(0.0, 0.3 * (1.0 + chaos * 2.0), corners);
                        return max(max(max(edges.x, edges.y), edges.z), corners * chaos);
                    }
                    
                    float plasmaGeometry(vec3 p, float density, float chaos) {
                        float plasma = sin(p.x * density * (1.0 + chaos * 2.0) + u_time * 0.001) +
                                      sin(p.y * density * (1.0 + chaos * 2.0) + u_time * 0.0012) +
                                      sin(p.z * density * (1.0 + chaos * 2.0) + u_time * 0.0008);
                        plasma += chaos * (sin(p.x * density * 5.0) * sin(p.y * density * 5.0));
                        return smoothstep(-1.5, 1.5, plasma);
                    }
                    
                    float neuralGeometry(vec3 p, float density, float chaos) {
                        float nodes = 0.0;
                        for (int i = 0; i < 8; i++) {
                            float fi = float(i);
                            vec3 nodePos = vec3(sin(fi + u_time * 0.001), cos(fi + u_time * 0.0012), sin(fi * 0.7 + u_time * 0.0008));
                            float dist = length(p - nodePos * (1.0 + chaos));
                            nodes += exp(-dist * density * (1.0 + chaos * 2.0));
                        }
                        return nodes * (1.0 + chaos * 3.0);
                    }
                    
                    float crystalGeometry(vec3 p, float density, float chaos) {
                        vec3 q = fract(p * density * (1.0 + chaos)) - 0.5;
                        float d1 = abs(q.x + q.y + q.z) / sqrt(3.0);
                        float d2 = abs(q.x - q.y + q.z) / sqrt(3.0);
                        float d3 = abs(q.x + q.y - q.z) / sqrt(3.0);
                        float crystal = min(min(d1, d2), d3);
                        crystal = 1.0 - smoothstep(0.0, 0.2 * (1.0 + chaos), crystal);
                        return crystal * (1.0 + chaos * 2.0);
                    }
                    
                    float quantumGeometry(vec3 p, float density, float chaos) {
                        float quantum = 0.0;
                        for (int i = 0; i < 12; i++) {
                            float fi = float(i);
                            float angle = fi * 0.523 + u_time * 0.002 * (1.0 + chaos);
                            float radius = 0.5 + sin(u_time * 0.001 + fi) * 0.3 * (1.0 + chaos);
                            vec3 wavePos = vec3(cos(angle) * radius, sin(angle) * radius, sin(fi + u_time * 0.001) * 0.2);
                            float dist = length(p - wavePos);
                            quantum += exp(-dist * density * (1.0 + chaos * 3.0)) * (1.0 + chaos);
                        }
                        return quantum;
                    }
                    
                    float fractalGeometry(vec3 p, float density, float chaos) {
                        float fractal = 0.0;
                        vec3 z = p * density * (1.0 + chaos);
                        for (int i = 0; i < 6; i++) {
                            z = abs(z) - 0.5 * (1.0 + chaos);
                            float r2 = dot(z, z);
                            if (r2 > 1.0) z *= 1.0 / r2;
                            fractal += exp(-r2 * (1.0 + chaos * 2.0));
                        }
                        return fractal * (1.0 + chaos * 4.0);
                    }
                    
                    float matrixGeometry(vec3 p, float density, float chaos) {
                        vec3 grid = fract(p * density * (1.0 + chaos * 4.0));
                        float matrix = 0.0;
                        
                        // Grid lines
                        matrix = max(matrix, 1.0 - smoothstep(0.0, 0.05 * (1.0 + chaos), abs(grid.x - 0.5)));
                        matrix = max(matrix, 1.0 - smoothstep(0.0, 0.05 * (1.0 + chaos), abs(grid.y - 0.5)));
                        matrix = max(matrix, 1.0 - smoothstep(0.0, 0.05 * (1.0 + chaos), abs(grid.z - 0.5)));
                        
                        // Chaos interference
                        float interference = sin(p.x * 10.0 * (1.0 + chaos)) * sin(p.y * 10.0 * (1.0 + chaos)) * chaos;
                        matrix += interference * 0.5;
                        
                        return matrix;
                    }
                    
                    float getGeometry(vec3 p, float density, float chaos, float geomType) {
                        if (geomType < 0.5) return hypercubeGeometry(p, density, chaos);
                        else if (geomType < 1.5) return plasmaGeometry(p, density, chaos);
                        else if (geomType < 2.5) return neuralGeometry(p, density, chaos);
                        else if (geomType < 3.5) return crystalGeometry(p, density, chaos);
                        else if (geomType < 4.5) return quantumGeometry(p, density, chaos);
                        else if (geomType < 5.5) return fractalGeometry(p, density, chaos);
                        else return matrixGeometry(p, density, chaos);
                    }
                    
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    void main() {
                        vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                        float aspectRatio = u_resolution.x / u_resolution.y;
                        uv.x *= aspectRatio;
                        uv -= 0.5;
                        
                        // Scroll-driven rotation and movement
                        float scrollRotation = u_scrollProgress * 6.28 * 2.0; // 2 full rotations per scroll
                        float time = u_time * 0.0005 * (1.0 + u_chaosLevel);
                        
                        // 4D space with scroll-tied transformations
                        vec4 p4d = vec4(uv, 
                                       sin(time + scrollRotation * 0.5) * 0.3, 
                                       cos(time + scrollRotation * 0.3) * 0.3);
                        
                        // Multi-axis rotations tied to scroll and chaos
                        p4d = rotateXW(scrollRotation + time * u_rotationSpeed + u_chaosLevel) * p4d;
                        p4d = rotateYW(scrollRotation * 0.7 + time * u_rotationSpeed * 0.8 + u_chaosLevel * 0.5) * p4d;
                        p4d = rotateZW(scrollRotation * 1.3 + time * u_rotationSpeed * 1.2 + u_chaosLevel * 0.3) * p4d;
                        
                        vec3 p = project4Dto3D(p4d);
                        
                        // Scroll-driven density (gets tighter/more chaotic)
                        float baseDensity = 3.0 + u_scrollProgress * 12.0; // 3 to 15
                        float finalDensity = baseDensity * u_densityMultiplier * (1.0 + u_chaosLevel * 2.0);
                        
                        // Get geometry value with chaos
                        float geometry = getGeometry(p, finalDensity, u_chaosLevel, u_geometryType);
                        
                        // Chaos-driven coloring
                        float baseHue = u_geometryType * 0.4 + u_scrollProgress * 0.8 + u_chaosLevel;
                        float hue = baseHue + sin(u_time * 0.001) * 0.2;
                        float saturation = 0.6 + u_chaosLevel * 0.3 + geometry * 0.2;
                        float brightness = 0.1 + geometry * 0.6 + u_chaosLevel * 0.3;
                        
                        vec3 color = hsv2rgb(vec3(hue, saturation, brightness));
                        
                        // Chaos enhancement
                        color *= (1.0 + u_chaosLevel * 2.0);
                        
                        // Scroll-driven intensity boost
                        color *= (1.0 + u_scrollProgress * 0.5);
                        
                        gl_FragColor = vec4(color, 0.6 + u_chaosLevel * 0.3);
                    }
                `;
                
                this.program = this.createProgram(vertexShaderSource, fragmentShaderSource);
                this.uniforms = {
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    scrollProgress: this.gl.getUniformLocation(this.program, 'u_scrollProgress'),
                    chaosLevel: this.gl.getUniformLocation(this.program, 'u_chaosLevel'),
                    rotationSpeed: this.gl.getUniformLocation(this.program, 'u_rotationSpeed'),
                    densityMultiplier: this.gl.getUniformLocation(this.program, 'u_densityMultiplier'),
                    geometryType: this.gl.getUniformLocation(this.program, 'u_geometryType')
                };
            }
            
            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking failed:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation failed:', this.gl.getShaderInfoLog(shader));
                    return null;
                }
                
                return shader;
            }
            
            initBuffers() {
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                
                this.buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
                
                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            updateScroll(scrollProgress) {
                this.scrollProgress = scrollProgress;
                this.rotationSpeed = this.baseSpeed * (1.0 + scrollProgress * 2.0);
                this.densityMultiplier = 1.0 + scrollProgress * 1.5;
            }
            
            render() {
                if (!this.program) return;
                
                this.resize();
                this.gl.useProgram(this.program);
                
                const time = Date.now() - this.startTime;
                const geometryType = this.sectionIndex % 7; // 7 geometry types
                
                // Set uniforms
                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform1f(this.uniforms.time, time);
                this.gl.uniform1f(this.uniforms.scrollProgress, this.scrollProgress);
                this.gl.uniform1f(this.uniforms.chaosLevel, this.chaosLevel);
                this.gl.uniform1f(this.uniforms.rotationSpeed, this.rotationSpeed);
                this.gl.uniform1f(this.uniforms.densityMultiplier, this.densityMultiplier);
                this.gl.uniform1f(this.uniforms.geometryType, geometryType);
                
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
        }
        
        // PARALLAX SCROLL SYSTEM MANAGER
        class ParallaxScrollSystemManager {
            constructor() {
                this.sections = visualEffectsGrouped;
                this.flatEffects = [];
                this.currentSection = 0;
                this.scrollProgress = 0;
                this.backgroundVisualizers = [];
                this.isScrolling = false;
                this.cardSections = [];

                this.sections.forEach((group, sectionIndex) => {
                    group.effects = group.effects.map((effect) => {
                        const enriched = {
                            ...effect,
                            sectionIndex,
                            groupName: group.name,
                            groupDescription: group.description,
                            globalIndex: this.flatEffects.length
                        };
                        enriched.tags = enriched.tags || [];
                        this.flatEffects.push(enriched);
                        return enriched;
                    });
                });

                this.modal = new ParallaxModal(this.flatEffects);

                this.initialize();
            }

            initialize() {
                console.log('ðŸŽ¨ Initializing Parallax Scroll System...');

                this.createBackgroundVisualizers();
                this.createCardSections();
                this.createScrollIndicators();
                this.setupMouseParallax();
                this.setupScrollPhysics();
                this.updateUI();

                console.log('âœ… Parallax System ready - 8 sections with smart canvas loading');
            }

            createBackgroundVisualizers() {
                const container = document.getElementById('backgroundContainer');

                backgroundThemes.forEach((theme, index) => {
                    const visualizerDiv = document.createElement('div');
                    visualizerDiv.className = 'background-visualizer';
                    visualizerDiv.id = `bg-visualizer-${index}`;

                    const canvas = document.createElement('canvas');
                    canvas.id = `bg-canvas-${index}`;
                    visualizerDiv.appendChild(canvas);

                    container.appendChild(visualizerDiv);

                    setTimeout(() => {
                        const visualizer = new HolographicBackgroundVisualizer(canvas, theme, index);
                        this.backgroundVisualizers.push(visualizer);
                    }, index * 200);
                });
            }

            createCardSections() {
                const container = document.getElementById('floatingCards');
                container.innerHTML = '';
                this.cardSections = [];

                this.sections.forEach((group, sectionIndex) => {
                    const section = document.createElement('div');
                    section.className = 'card-section';
                    section.id = `card-section-${sectionIndex}`;
                    section.dataset.cardCount = group.effects.length;

                    group.effects.forEach((effect, cardIndex) => {
                        const card = this.createCard(effect, sectionIndex, cardIndex);
                        section.appendChild(card);
                    });

                    container.appendChild(section);
                    this.cardSections.push(section);
                });
            }

            createCard(effect, sectionIndex, cardIndex) {
                const card = document.createElement('div');
                card.className = 'floating-card';
                card.setAttribute('role', 'button');
                card.setAttribute('tabindex', '0');
                const groupDepth = this.sections[sectionIndex].depth || 0.2;
                card.dataset.depth = groupDepth + (cardIndex + 1) * 0.12;
                card._parallaxState = { scroll: 0, mouseX: 0, mouseY: 0, hovered: false };

                const tagsMarkup = effect.tags.map(tag => `<span class="tag">${tag}</span>`).join('');
                const evolutionCallout = effect.evolution
                    ? `<div class="evolution-callout"><strong>${effect.evolution.stage}</strong> ${effect.evolution.summary}</div>`
                    : '';
                card.innerHTML = `
                    <h3>${effect.title}</h3>
                    <p>${effect.description}</p>
                    <div class="tags">${tagsMarkup}</div>
                    ${evolutionCallout}
                    <div class="card-footer">
                        <span>${effect.groupName}</span>
                        <span class="card-cta">Open</span>
                    </div>
                `;

                const openModal = () => this.modal.open(effect.globalIndex);
                card.addEventListener('click', openModal);
                card.addEventListener('keyup', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        openModal();
                    }
                });

                card.addEventListener('mouseenter', () => {
                    card._parallaxState.hovered = true;
                    this.updateCardTransform(card);
                });

                card.addEventListener('mouseleave', () => {
                    card._parallaxState.hovered = false;
                    card._parallaxState.mouseX = 0;
                    card._parallaxState.mouseY = 0;
                    this.updateCardTransform(card);
                });

                this.updateCardTransform(card);
                return card;
            }

            setupMouseParallax() {
                const container = document.getElementById('floatingCards');

                container.addEventListener('mousemove', (event) => {
                    const rect = container.getBoundingClientRect();
                    const offsetX = (event.clientX - rect.left) / rect.width - 0.5;
                    const offsetY = (event.clientY - rect.top) / rect.height - 0.5;
                    const activeSection = this.cardSections[this.currentSection];
                    if (!activeSection) return;

                    [...activeSection.children].forEach((card) => {
                        const state = card._parallaxState;
                        if (!state) return;
                        state.mouseX = offsetX;
                        state.mouseY = offsetY;
                        this.updateCardTransform(card);
                    });
                });

                container.addEventListener('mouseleave', () => {
                    this.cardSections.forEach((section) => {
                        [...section.children].forEach((card) => {
                            const state = card._parallaxState;
                            if (!state) return;
                            state.mouseX = 0;
                            state.mouseY = 0;
                            this.updateCardTransform(card);
                        });
                    });
                });
            }

            updateCardTransform(card) {
                const state = card._parallaxState;
                if (!state) return;
                const depth = Number(card.dataset.depth || 0.4);
                const scrollOffset = state.scroll * 90;
                const mouseX = state.mouseX * 32 * depth;
                const mouseY = state.mouseY * 26 * depth;
                const scale = state.hovered ? 1.05 : 1;
                card.style.transform = `translate3d(${mouseX}px, ${scrollOffset + mouseY}px, 0) scale(${scale})`;
            }

            applyScrollParallax(progress) {
                const section = this.cardSections[this.currentSection];
                if (!section) return;
                const normalized = progress - 0.5;
                [...section.children].forEach((card) => {
                    const state = card._parallaxState;
                    if (!state) return;
                    const depth = Number(card.dataset.depth || 0.4);
                    state.scroll = normalized * depth;
                    this.updateCardTransform(card);
                });
            }

            createScrollIndicators() {
                const container = document.getElementById('scrollIndicator');
                container.innerHTML = '';

                for (let i = 0; i < this.sections.length; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'scroll-dot';
                    dot.addEventListener('click', () => {
                        this.scrollToSection(i);
                    });
                    container.appendChild(dot);
                }
            }

            setupScrollPhysics() {
                let ticking = false;

                window.addEventListener('scroll', () => {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            this.updateScrollState();
                            ticking = false;
                        });
                        ticking = true;
                    }
                });

                window.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY;
                    const sensitivity = 1.5;
                    const scrollAmount = delta * sensitivity;
                    window.scrollBy(0, scrollAmount);
                }, { passive: false });
            }

            updateScrollState() {
                const scrollTop = window.pageYOffset;
                const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
                const globalProgress = scrollTop / maxScroll;

                const sectionProgress = globalProgress * this.sections.length;
                const newSection = Math.floor(sectionProgress);
                const sectionLocalProgress = sectionProgress - newSection;

                if (newSection !== this.currentSection && newSection >= 0 && newSection < this.sections.length) {
                    this.currentSection = Math.max(0, Math.min(this.sections.length - 1, newSection));
                    this.updateUI();
                }

                this.backgroundVisualizers.forEach((viz, index) => {
                    if (viz) {
                        if (index === this.currentSection) {
                            viz.updateScroll(sectionLocalProgress);
                        } else {
                            viz.updateScroll(0);
                        }
                    }
                });

                this.updateBackgroundVisibility();
                this.updateCardVisibility();
                this.applyScrollParallax(sectionLocalProgress);
                this.updateChaosMeter();
            }

            updateBackgroundVisibility() {
                const backgrounds = document.querySelectorAll('.background-visualizer');
                backgrounds.forEach((bg, index) => {
                    bg.classList.toggle('active', index === this.currentSection);
                    bg.classList.toggle('inactive', index !== this.currentSection);
                });
            }

            updateCardVisibility() {
                this.cardSections.forEach((section, index) => {
                    section.classList.toggle('active', index === this.currentSection);
                });
            }

            updateUI() {
                const theme = backgroundThemes[this.currentSection];
                const group = this.sections[this.currentSection];
                document.getElementById('sectionTitle').textContent = group ? group.name : theme.name;
                const sectionDescriptor = group && group.evolutionSummary
                    ? `${theme.name} â€¢ ${group.evolutionSummary}`
                    : theme.name;
                document.getElementById('sectionSubtitle').textContent = `Section ${this.currentSection + 1} of ${this.sections.length} â€¢ ${sectionDescriptor}`;

                const dots = document.querySelectorAll('.scroll-dot');
                dots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === this.currentSection);
                });
            }

            updateChaosMeter() {
                const theme = backgroundThemes[this.currentSection];
                const group = this.sections[this.currentSection];
                const bonus = group && group.evolutionIntensity ? group.evolutionIntensity : 0;
                const chaosPercentage = Math.min(100, ((theme.chaos + bonus) * 100).toFixed(0));
                const chaosFill = document.getElementById('chaosFill');
                chaosFill.style.width = `${chaosPercentage}%`;
                const chaosTitle = document.querySelector('.chaos-meter-title');
                if (chaosTitle) {
                    chaosTitle.textContent = group && group.evolutionSummary
                        ? `Chaos Intensity â€¢ ${group.evolutionSummary}`
                        : 'Chaos Intensity';
                }
            }

            scrollToSection(sectionIndex) {
                const targetScroll = (sectionIndex / this.sections.length) * (document.documentElement.scrollHeight - window.innerHeight);

                window.scrollTo({
                    top: targetScroll,
                    behavior: 'smooth'
                });
            }

            startRenderLoop() {
                const render = () => {
                    this.backgroundVisualizers.forEach(viz => {
                        if (viz) viz.render();
                    });
                    requestAnimationFrame(render);
                };

                render();
                console.log('ðŸŽ¬ Parallax background render loop started');
            }
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            console.log('ðŸš€ Starting Visual Codex Parallax System...');
            const manager = new ParallaxScrollSystemManager();
            manager.startRenderLoop();
            window.parallaxManager = manager;
        });
        
    </script>
</body>
</html>