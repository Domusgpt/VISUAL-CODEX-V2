<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elegant 4D Flow Twin â€” Rift Cascade</title>
    <style>
        :root {
            color-scheme: dark;
        }
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at 50% 0%, #0a000f 0%, #05020c 46%, #020107 100%);
            font-family: "Inter", system-ui, sans-serif;
        }
        canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>
<body>
<canvas id="rift-canvas"></canvas>
<script>
(function() {
    'use strict';

    function rand(min, max) {
        return Math.random() * (max - min) + min;
    }

    var scenePalettes = [
        {
            sky: ['#12002a', '#25004d', '#080012'],
            veins: '#9c4dff',
            shards: '#00e0ff',
            embers: '#ff8a65',
            echo: '#d8b4ff'
        },
        {
            sky: ['#01121c', '#012a3a', '#001318'],
            veins: '#00f5ff',
            shards: '#6bffda',
            embers: '#ffe29a',
            echo: '#51f0ff'
        },
        {
            sky: ['#1f0303', '#3a0802', '#0f0200'],
            veins: '#ff3b5f',
            shards: '#ff9060',
            embers: '#ffd452',
            echo: '#ff6f91'
        }
    ];

    function RiftCascade() {
        this.canvas = document.getElementById('rift-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.dpr = window.devicePixelRatio || 1;
        this.time = 0;
        this.sceneClock = 0;
        this.sceneIndex = 0;
        this.sceneDuration = 16000;
        this.spirals = [];
        this.emberStreams = [];
        this.fractures = [];
        this.columns = [];
        this.mouse = { x: 0.5, y: 0.5 };
        this.resize();
        this.seed();
        this.bind();
        this.start();
    }

    RiftCascade.prototype.resize = function() {
        var width = window.innerWidth;
        var height = window.innerHeight;
        this.canvas.width = width * this.dpr;
        this.canvas.height = height * this.dpr;
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
    };

    RiftCascade.prototype.bind = function() {
        var self = this;
        window.addEventListener('resize', function() { self.resize(); });
        document.addEventListener('mousemove', function(e) {
            self.mouse.x = e.clientX / window.innerWidth;
            self.mouse.y = e.clientY / window.innerHeight;
        });
    };

    RiftCascade.prototype.seed = function() {
        this.spirals.length = 0;
        this.emberStreams.length = 0;
        this.fractures.length = 0;
        this.columns.length = 0;

        for (var i = 0; i < 42; i++) {
            this.spirals.push({
                theta: rand(0, Math.PI * 2),
                radius: rand(120, 520),
                depth: rand(-1, 1),
                drift: rand(0.001, 0.004),
                scale: rand(0.7, 1.6),
                offset: rand(-0.8, 0.8)
            });
        }

        for (var s = 0; s < 280; s++) {
            this.emberStreams.push({
                x: rand(-200, this.canvas.width / this.dpr + 200),
                y: rand(-200, this.canvas.height / this.dpr + 200),
                vx: rand(-0.6, 0.6),
                vy: rand(-0.6, 0.6),
                trail: [],
                trailLength: Math.floor(rand(30, 60)),
                pulse: rand(0.0006, 0.0014),
                age: rand(0, Math.PI * 2)
            });
        }

        for (var f = 0; f < 16; f++) {
            this.fractures.push({
                x: rand(0.1, 0.9),
                y: rand(0.2, 0.8),
                phase: rand(0, Math.PI * 2),
                variance: rand(0.6, 1.4)
            });
        }

        for (var c = 0; c < 7; c++) {
            this.columns.push({
                anchor: rand(0.15, 0.85),
                height: rand(240, 460),
                sway: rand(0.0012, 0.0028),
                twist: rand(0.9, 1.4),
                scatter: rand(0.4, 1.2)
            });
        }
    };

    RiftCascade.prototype.start = function() {
        if (this.running) return;
        this.running = true;
        this.render(performance.now());
    };

    RiftCascade.prototype.advanceScene = function() {
        this.sceneIndex = (this.sceneIndex + 1) % scenePalettes.length;
        this.sceneClock = 0;
    };

    RiftCascade.prototype.render = function(now) {
        if (!this.running) return;
        var dt = now - (this.prevTime || now);
        this.prevTime = now;
        this.time += dt;
        this.sceneClock += dt;
        if (this.sceneClock > this.sceneDuration) {
            this.advanceScene();
        }
        var palette = scenePalettes[this.sceneIndex];
        this.drawSky(palette);
        this.drawColumns(dt, palette);
        this.drawSpirals(dt, palette);
        this.drawEmbers(dt, palette);
        this.drawFractures(dt, palette);
        requestAnimationFrame(this.render.bind(this));
    };

    RiftCascade.prototype.drawSky = function(palette) {
        var gradient = this.ctx.createRadialGradient(
            this.canvas.width / this.dpr * 0.5,
            this.canvas.height / this.dpr * 0.2,
            120,
            this.canvas.width / this.dpr * 0.5,
            this.canvas.height / this.dpr,
            Math.max(this.canvas.width, this.canvas.height)
        );
        gradient.addColorStop(0, palette.sky[0]);
        gradient.addColorStop(0.4, palette.sky[1]);
        gradient.addColorStop(1, palette.sky[2]);
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width / this.dpr, this.canvas.height / this.dpr);
    };

    RiftCascade.prototype.drawColumns = function(dt, palette) {
        var baseY = this.canvas.height / this.dpr * 0.86;
        var centerX = this.canvas.width / this.dpr * 0.5;
        this.ctx.globalCompositeOperation = 'screen';
        for (var i = 0; i < this.columns.length; i++) {
            var column = this.columns[i];
            var offsetX = (column.anchor - 0.5) * this.canvas.width / this.dpr * 0.8;
            var sway = Math.sin(this.time * column.sway + column.anchor * 10 + this.mouse.x * 4) * 60 * column.scatter;
            var height = column.height * (1 + Math.sin(this.time * 0.001 + column.anchor * 6) * 0.2);
            var gradient = this.ctx.createLinearGradient(0, baseY, 0, baseY - height);
            gradient.addColorStop(0, palette.sky[2] + '00');
            gradient.addColorStop(0.3, palette.veins + '66');
            gradient.addColorStop(1, palette.veins);
            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = 3.6;
            this.ctx.globalAlpha = 0.32;
            this.ctx.beginPath();
            this.ctx.moveTo(centerX + offsetX + sway, baseY);
            this.ctx.lineTo(centerX + offsetX - sway * 0.2, baseY - height);
            this.ctx.stroke();
        }
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.globalAlpha = 1;
    };

    RiftCascade.prototype.drawSpirals = function(dt, palette) {
        var cx = this.canvas.width / this.dpr * 0.5;
        var cy = this.canvas.height / this.dpr * 0.45;
        this.ctx.save();
        this.ctx.translate(cx, cy);
        for (var i = 0; i < this.spirals.length; i++) {
            var spiral = this.spirals[i];
            spiral.theta += spiral.drift * dt;
            var radius = spiral.radius * (1 + Math.sin(this.time * 0.0006 + spiral.depth) * 0.25);
            var wobble = Math.sin(this.time * 0.001 + spiral.offset) * 0.35;
            var x = Math.cos(spiral.theta + wobble) * radius;
            var y = Math.sin(spiral.theta - wobble) * radius * 0.6;
            var size = 2.4 + (1 + Math.sin(this.time * 0.002 + spiral.depth * 6)) * 1.4;
            var gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size * 12);
            gradient.addColorStop(0, palette.shards);
            gradient.addColorStop(0.6, palette.echo + '55');
            gradient.addColorStop(1, 'transparent');
            this.ctx.fillStyle = gradient;
            this.ctx.globalAlpha = 0.36;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 10, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.restore();
        this.ctx.globalAlpha = 1;
    };

    RiftCascade.prototype.drawEmbers = function(dt, palette) {
        for (var i = 0; i < this.emberStreams.length; i++) {
            var ember = this.emberStreams[i];
            ember.age += dt * ember.pulse;
            ember.vx += Math.sin(this.time * 0.0004 + ember.age) * 0.002;
            ember.vy += Math.cos(this.time * 0.0006 + ember.age) * 0.002;
            ember.x += ember.vx + (this.mouse.x - 0.5) * 1.6;
            ember.y += ember.vy + (this.mouse.y - 0.5) * 1.6;
            if (ember.x < -240) ember.x = this.canvas.width / this.dpr + 240;
            if (ember.x > this.canvas.width / this.dpr + 240) ember.x = -240;
            if (ember.y < -240) ember.y = this.canvas.height / this.dpr + 240;
            if (ember.y > this.canvas.height / this.dpr + 240) ember.y = -240;
            ember.trail.unshift({ x: ember.x, y: ember.y });
            if (ember.trail.length > ember.trailLength) {
                ember.trail.pop();
            }
            this.ctx.beginPath();
            this.ctx.lineWidth = 1.2;
            this.ctx.strokeStyle = palette.embers;
            for (var t = 0; t < ember.trail.length; t++) {
                var point = ember.trail[t];
                var alpha = 1 - t / ember.trail.length;
                this.ctx.globalAlpha = Math.pow(alpha, 1.4) * 0.9;
                if (t === 0) this.ctx.moveTo(ember.x, ember.y);
                this.ctx.lineTo(point.x, point.y);
            }
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1;
    };

    RiftCascade.prototype.drawFractures = function(dt, palette) {
        var cx = this.canvas.width / this.dpr * 0.5;
        var cy = this.canvas.height / this.dpr * 0.3;
        this.ctx.globalCompositeOperation = 'lighter';
        for (var i = 0; i < this.fractures.length; i++) {
            var fracture = this.fractures[i];
            fracture.phase += dt * 0.0006 * fracture.variance;
            var ripple = 100 + Math.sin(fracture.phase) * 60;
            var gradient = this.ctx.createRadialGradient(
                cx + (fracture.x - 0.5) * this.canvas.width / this.dpr * 0.9,
                cy + (fracture.y - 0.5) * this.canvas.height / this.dpr * 0.6,
                ripple * 0.2,
                cx,
                cy,
                ripple * 1.8
            );
            gradient.addColorStop(0, palette.shards);
            gradient.addColorStop(0.5, palette.echo + '44');
            gradient.addColorStop(1, 'transparent');
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(
                cx + (fracture.x - 0.5) * this.canvas.width / this.dpr * 0.9,
                cy + (fracture.y - 0.5) * this.canvas.height / this.dpr * 0.6,
                ripple,
                0,
                Math.PI * 2
            );
            this.ctx.fill();
        }
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.globalAlpha = 1;
    };

    new RiftCascade();
})();
</script>
</body>
</html>
