<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVEP Moir√© 4D Hypercube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            height: 300vh; /* Make it scrollable */
        }
        
        .infinite-scroll-content {
            height: 300vh;
            background: linear-gradient(0deg, 
                rgba(0,20,40,0.3) 0%, 
                rgba(20,0,40,0.2) 33%, 
                rgba(40,20,0,0.2) 66%, 
                rgba(0,40,20,0.3) 100%);
        }
        
        .scroll-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #00ffff;
            color: #00ffff;
            z-index: 100;
            font-size: 12px;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .controls {
            /* position: absolute; */
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 1px solid #00ffff;
            color: #00ffff;
            z-index: 100;
            width: 200px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            color: #ff00ff;
            font-weight: bold;
        }
        .audio-btn {
            background: rgba(0,255,255,0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 15px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        .audio-btn:hover {
            background: rgba(0,255,255,0.4);
        }
        .status {
            position: absolute;
            top: 10px;
            left: 20px;
            color: #ffff00;
            font-size: 14px;
        }
        .scene-pill-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            margin-top: 6px;
        }
        .scene-pill {
            font-size: 10px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            padding: 6px 4px;
            border-radius: 6px;
            border: 1px solid rgba(0,255,255,0.35);
            background: rgba(0,0,0,0.35);
            color: #ffe6ff;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .scene-pill:hover {
            background: rgba(255,0,255,0.25);
            color: white;
            box-shadow: 0 0 12px rgba(255,0,255,0.3);
        }
        .scene-pill.active {
            background: linear-gradient(135deg, rgba(0,255,255,0.35), rgba(255,0,255,0.35));
            border-color: rgba(255,255,255,0.65);
            color: white;
        }
        .evolution-status {
            margin-top: 6px;
            font-size: 10px;
            color: rgba(200,255,255,0.8);
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="infinite-scroll-content"></div>
    <canvas id="canvas"></canvas>
    
    <div class="status" id="status">
        MVEP 4D Hypercube Evolution ‚Ä¢ Mouse: Move | Scroll: Grid/Color | Audio & Evolutions: Control Panel
    </div>
    
    <div class="scroll-indicator" id="scrollIndicator">
        Scroll: 0% | Grid: 12.0 | Color: 0.00
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label>Dimension: <span class="value-display" id="dimensionValue">3.8</span></label>
            <input type="range" id="dimension" min="3.0" max="5.0" step="0.1" value="3.8">
        </div>
        <div class="control-group">
            <label>Morph Factor: <span class="value-display" id="morphValue">0.7</span></label>
            <input type="range" id="morphFactor" min="0.0" max="1.5" step="0.1" value="0.7">
        </div>
        <div class="control-group">
            <label>Glitch Intensity: <span class="value-display" id="glitchValue">0.05</span></label>
            <input type="range" id="glitchIntensity" min="0.0" max="0.2" step="0.01" value="0.05">
        </div>
        <div class="control-group">
            <label>Rotation Speed: <span class="value-display" id="rotationValue">1.2</span></label>
            <input type="range" id="rotationSpeed" min="0.0" max="3.0" step="0.1" value="1.2">
        </div>
        <div class="control-group">
            <label>Grid Density: <span class="value-display" id="gridValue">12.0</span></label>
            <input type="range" id="gridDensity" min="5.0" max="25.0" step="0.5" value="12.0">
        </div>
        <div class="control-group">
            <label>Moir√© Scale: <span class="value-display" id="moireValue">1.01</span></label>
            <input type="range" id="moireScale" min="0.95" max="1.05" step="0.001" value="1.01">
        </div>
        <div class="control-group">
            <label>Color Shift: <span class="value-display" id="colorValue">0.0</span></label>
            <input type="range" id="colorShift" min="-1.0" max="1.0" step="0.1" value="0.0">
        </div>
        <div class="control-group">
            <label>Trail Persistence: <span class="value-display" id="trailPersistenceValue">0.45</span></label>
            <input type="range" id="trailPersistence" min="0.0" max="1.0" step="0.05" value="0.45">
        </div>
        <div class="control-group">
            <label>Resonance Warp: <span class="value-display" id="resonanceWarpValue">0.30</span></label>
            <input type="range" id="resonanceWarp" min="0.0" max="1.0" step="0.05" value="0.3">
        </div>
        <div class="control-group">
            <label>Evolution Scenes</label>
            <div class="scene-pill-grid">
                <button class="scene-pill active" data-mode="aurora">Aurora Bloom</button>
                <button class="scene-pill" data-mode="gravity">Gravity Lens</button>
                <button class="scene-pill" data-mode="prism">Prism Surge</button>
                <button class="scene-pill" data-mode="abyss">Abyss Echo</button>
                <button class="scene-pill" data-mode="zenith">Zenith Veil</button>
                <button class="scene-pill" data-mode="rift">Rift Bloom</button>
            </div>
            <div class="evolution-status" id="evolutionStatus">Aurora Bloom baseline</div>
        </div>
        <button class="audio-btn" id="evolutionCycleBtn">Cycle Evolutions</button>
        <button class="audio-btn" id="audioBtn">Enable Audio</button>
    </div>

    <script>
        class MVEPMoireHypercube {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.touchIntensity = 0.0;
                this.touchPoint = { x: 0.5, y: 0.5 };
                this.touchChaos = 0.0;
                this.time = 0;
                this.startTime = Date.now();
                this.lastPersist = Date.now();
                
                // MVEP Parameters
                this.params = {
                    dimension: 3.8,
                    morphFactor: 0.7,
                    glitchIntensity: 0.05,
                    rotationSpeed: 1.2,
                    gridDensity: 12.0,
                    moireScale: 1.01,
                    colorShift: 0.0,
                    trailPersistence: 0.45,
                    resonanceWarp: 0.3
                };

                this.storageKey = 'mvep-moire-hypercube-phase3-state';
                this.storageAvailable = false;
                try {
                    const testKey = `${this.storageKey}-test`;
                    localStorage.setItem(testKey, '1');
                    localStorage.removeItem(testKey);
                    this.storageAvailable = true;
                } catch (error) {
                    console.warn('MVEP storage unavailable', error);
                }

                // Audio
                this.audioEnabled = false;
                this.audioContext = null;
                this.analyser = null;
                this.audioData = { bass: 0, mid: 0, high: 0, pitch: 0 };

                this.evolutionMode = 'aurora';
                this.evolutionPhase = 0;
                this.evolutionMemory = 0.22;
                this.evolutionConfigs = {
                    aurora: {
                        label: 'Aurora Bloom',
                        paletteA: [0.2, 0.8, 1.0],
                        paletteB: [1.0, 0.4, 1.0],
                        pulse: 0.4,
                        morphBoost: 0.2,
                        chaosBoost: 0.15,
                        colorShiftBase: 0.1,
                        vector: [0.45, 0.9, 1.2]
                    },
                    gravity: {
                        label: 'Gravity Lens',
                        paletteA: [0.9, 0.9, 0.3],
                        paletteB: [0.2, 0.6, 1.3],
                        pulse: 0.55,
                        morphBoost: 0.35,
                        chaosBoost: 0.25,
                        colorShiftBase: -0.05,
                        vector: [1.0, 0.7, 1.1]
                    },
                    prism: {
                        label: 'Prism Surge',
                        paletteA: [1.2, 0.5, 0.9],
                        paletteB: [0.4, 1.1, 1.2],
                        pulse: 0.7,
                        morphBoost: 0.5,
                        chaosBoost: 0.2,
                        colorShiftBase: 0.25,
                        vector: [1.35, 0.8, 1.25]
                    },
                    abyss: {
                        label: 'Abyss Echo',
                        paletteA: [0.15, 0.35, 1.2],
                        paletteB: [0.8, 0.2, 1.4],
                        pulse: 0.85,
                        morphBoost: 0.65,
                        chaosBoost: 0.4,
                        colorShiftBase: -0.3,
                        vector: [0.3, 0.5, 1.45]
                    },
                    zenith: {
                        label: 'Zenith Veil',
                        paletteA: [0.45, 1.05, 1.35],
                        paletteB: [1.1, 0.55, 1.4],
                        pulse: 0.5,
                        morphBoost: 0.4,
                        chaosBoost: 0.22,
                        colorShiftBase: 0.18,
                        vector: [0.85, 1.1, 1.35]
                    },
                    rift: {
                        label: 'Rift Bloom',
                        paletteA: [0.25, 0.6, 1.25],
                        paletteB: [1.25, 0.35, 1.5],
                        pulse: 0.95,
                        morphBoost: 0.7,
                        chaosBoost: 0.45,
                        colorShiftBase: -0.22,
                        vector: [0.4, 0.9, 1.5]
                    }
                };

                this.evolutionStatusEl = null;
                this.evolutionCycleTimer = null;

                this.init();
            }
            
            init() {
                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }
                
                this.setupCanvas();
                this.createShaders();
                this.createGeometry();
                this.bindEvents();
                const restored = this.restoreState();
                this.setEvolutionMode(this.evolutionMode, { manual: restored });
                if (restored) {
                    this.updateEvolutionStatus('State recall engaged');
                }
                this.animate();
            }
            
            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                };
                resize();
                window.addEventListener('resize', resize);
            }
            
            createShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    varying vec2 v_uv;
                    
                    void main() {
                        v_uv = a_position * 0.5 + 0.5;
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;
                
                const fragmentShaderSource = `
                    precision highp float;
                    
                    varying vec2 v_uv;
                    
                    uniform float u_time;
                    uniform float u_dimension;
                    uniform float u_morphFactor;
                    uniform float u_glitchIntensity;
                    uniform float u_rotationSpeed;
                    uniform float u_gridDensity;
                    uniform float u_moireScale;
                    uniform float u_colorShift;
                    uniform vec2 u_resolution;
                    uniform vec2 u_mouse;
                    uniform float u_touchIntensity;
                    uniform vec2 u_touchPoint;
                    uniform float u_touchChaos;
                    uniform float u_trailPersistence;
                    uniform float u_resonanceWarp;
                    uniform float u_evolutionPhase;
                    uniform vec3 u_evolutionPrimary;
                    uniform vec3 u_evolutionSecondary;
                    uniform float u_evolutionPulse;
                    uniform vec3 u_evolutionVector;
                    uniform float u_memoryImprint;

                    // Audio uniforms
                    uniform float u_audioEnabled;
                    uniform float u_bassLevel;
                    uniform float u_midLevel;
                    uniform float u_highLevel;
                    uniform float u_pitchFactor;
                    
                    // 4D Rotation Matrices
                    mat4 rotateXW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(
                            c, 0.0, 0.0, -s,
                            0.0, 1.0, 0.0, 0.0,
                            0.0, 0.0, 1.0, 0.0,
                            s, 0.0, 0.0, c
                        );
                    }
                    
                    mat4 rotateYW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(
                            1.0, 0.0, 0.0, 0.0,
                            0.0, c, 0.0, -s,
                            0.0, 0.0, 1.0, 0.0,
                            0.0, s, 0.0, c
                        );
                    }
                    
                    mat4 rotateZW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(
                            1.0, 0.0, 0.0, 0.0,
                            0.0, 1.0, 0.0, 0.0,
                            0.0, 0.0, c, -s,
                            0.0, 0.0, s, c
                        );
                    }
                    
                    // 4D to 3D projection
                    vec3 project4Dto3D(vec4 point4D) {
                        float w = point4D.w + 2.0;
                        return point4D.xyz / max(w, 0.1);
                    }
                    
                    // 4D Hypercube distance field
                    float hypercubeLattice(vec3 p, float morphFactor, float gridDensity) {
                        // Convert to 4D space
                        float resonance = 1.0 + u_resonanceWarp * 0.6;
                        vec4 p4d = vec4(p * gridDensity * resonance, sin(u_time * 0.5) * morphFactor);

                        // Apply 4D rotations with mouse influence
                        float rotX = u_time * u_rotationSpeed + u_mouse.x * 3.14159 + u_evolutionPhase * 6.283 * 0.25;
                        float rotY = u_time * u_rotationSpeed * 0.7 + u_mouse.y * 3.14159;
                        float rotZ = u_time * u_rotationSpeed * 0.5 + u_evolutionPulse;

                        // Audio-reactive rotation if available
                        if (u_audioEnabled > 0.5) {
                            rotX += u_bassLevel * 2.0;
                            rotY += u_midLevel * 1.5;
                            rotZ += u_highLevel * 1.0;
                        }
                        
                        p4d = rotateXW(rotX) * p4d;
                        p4d = rotateYW(rotY) * p4d;
                        p4d = rotateZW(rotZ) * p4d;
                        
                        // Hypercube lattice calculation
                        vec4 latticePos = fract(p4d) - 0.5;
                        float dist = max(max(abs(latticePos.x), abs(latticePos.y)), 
                                       max(abs(latticePos.z), abs(latticePos.w)));
                        
                        return 1.0 - smoothstep(0.4, 0.5, dist);
                    }
                    
                    // Moir√© pattern generation
                    float generateMoire(vec3 p, float morphFactor, float gridDensity) {
                        float grid1 = hypercubeLattice(p, morphFactor, gridDensity);
                        float grid2 = hypercubeLattice(p, morphFactor, gridDensity * u_moireScale);
                        return abs(grid1 - grid2) * 0.5;
                    }
                    
                    // RGB Color splitting effect
                    vec3 applyColorSplitting(vec2 uv, vec3 baseColor) {
                        float glitchAmount = u_glitchIntensity;
                        if (u_audioEnabled > 0.5) {
                            glitchAmount += u_highLevel * 0.1;
                        }
                        
                        vec2 rOffset = vec2(glitchAmount, glitchAmount * 0.5);
                        vec2 gOffset = vec2(-glitchAmount * 0.3, glitchAmount * 0.2);
                        vec2 bOffset = vec2(glitchAmount * 0.1, -glitchAmount * 0.4);
                        
                        float r = baseColor.r;
                        float g = baseColor.g * 0.9;
                        float b = baseColor.b * 0.8;
                        
                        return vec3(r, g, b);
                    }
                    
                    // Hue shift function
                    vec3 hueShift(vec3 color, float shift) {
                        float c = cos(shift);
                        float s = sin(shift);
                        mat3 hueMatrix = mat3(
                            0.299 + 0.701*c + 0.168*s, 0.587 - 0.587*c + 0.330*s, 0.114 - 0.114*c - 0.497*s,
                            0.299 - 0.299*c - 0.328*s, 0.587 + 0.413*c + 0.035*s, 0.114 - 0.114*c + 0.292*s,
                            0.299 - 0.300*c + 1.25*s, 0.587 - 0.588*c - 1.05*s, 0.114 + 0.886*c - 0.203*s
                        );
                        return hueMatrix * color;
                    }
                    
                    void main() {
                        vec2 uv = (v_uv - 0.5) * 2.0;
                        uv.x *= u_resolution.x / u_resolution.y;
                        
                        // Ray direction for 3D effect
                        vec3 rayDir = normalize(vec3(uv, 1.0));
                        
                        // Calculate hypercube lattice with morphing
                        float morphFactor = u_morphFactor;
                        if (u_audioEnabled > 0.5) {
                            morphFactor += u_bassLevel * 0.5;
                        }
                        
                        float lattice = hypercubeLattice(rayDir, morphFactor, u_gridDensity);
                        float moire = generateMoire(rayDir, morphFactor, u_gridDensity);
                        
                        // Combine lattice and moir√©
                        float combined = lattice + moire * 0.5;

                        vec2 touchUV = v_uv;
                        vec2 touchDelta = touchUV - u_touchPoint;
                        float touchFalloff = exp(-length(touchDelta) * 6.0);
                        float touchWave = sin(u_time * 6.0 - length(touchDelta) * 24.0) * 0.5 + 0.5;
                        float touchContribution = u_touchIntensity * touchFalloff * touchWave;
                        float chaosContribution = u_touchChaos * 0.35;
                        float evolutionWave = sin(u_evolutionPhase * 6.283 + length(rayDir.xy) * 8.0);

                        combined += touchContribution * (1.0 + chaosContribution);
                        combined += evolutionWave * u_trailPersistence * 0.4;
                        moire += touchContribution * 0.3 + evolutionWave * u_resonanceWarp * 0.25;

                        // Base colors (vaporwave palette)
                        vec3 color1 = vec3(0.0, 0.8, 1.0);  // Cyan
                        vec3 color2 = vec3(1.0, 0.0, 1.0);  // Magenta
                        vec3 color3 = vec3(1.0, 1.0, 0.0);  // Yellow
                        vec3 evolutionPalette = mix(u_evolutionPrimary, u_evolutionSecondary, evolutionWave * 0.5 + 0.5);
                        vec3 memoryVector = mix(u_evolutionVector, evolutionPalette, u_memoryImprint * 0.4 + 0.2);

                        // Color mixing based on lattice pattern
                        vec3 finalColor = mix(mix(color1, color2, combined), color3, moire);
                        finalColor = mix(finalColor, evolutionPalette, u_trailPersistence * 0.35 + chaosContribution * 0.25);
                        finalColor = mix(finalColor, memoryVector, u_memoryImprint * 0.4 + u_trailPersistence * 0.15);

                        // Apply hue shifting
                        finalColor = hueShift(finalColor, u_colorShift + chaosContribution * 0.8 + u_evolutionPulse * 0.6);

                        // Apply RGB color splitting
                        finalColor = applyColorSplitting(v_uv, finalColor);

                        // Add some glow and intensity
                        finalColor *= (0.5 + combined * (1.2 + u_evolutionPulse));
                        finalColor += touchContribution * vec3(0.25, 0.15, 0.45);
                        finalColor += chaosContribution * 0.4;
                        finalColor += evolutionWave * u_trailPersistence * vec3(0.08, 0.12, 0.18);

                        // Audio-reactive brightness
                        if (u_audioEnabled > 0.5) {
                            finalColor *= (0.8 + u_bassLevel * 0.4 + u_midLevel * 0.3);
                        }

                        // Touch-driven bloom
                        finalColor += vec3(0.05, 0.08, 0.12) * pow(touchContribution + u_trailPersistence * 0.2, 1.2);
                        finalColor = clamp(finalColor, 0.0, 1.8);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `;
                
                const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);
                
                this.program = this.gl.createProgram();
                this.gl.attachShader(this.program, vertexShader);
                this.gl.attachShader(this.program, fragmentShader);
                this.gl.linkProgram(this.program);
                
                if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(this.program));
                    return;
                }
                
                this.gl.useProgram(this.program);
                
                // Get uniform locations
                this.uniforms = {
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    dimension: this.gl.getUniformLocation(this.program, 'u_dimension'),
                    morphFactor: this.gl.getUniformLocation(this.program, 'u_morphFactor'),
                    glitchIntensity: this.gl.getUniformLocation(this.program, 'u_glitchIntensity'),
                    rotationSpeed: this.gl.getUniformLocation(this.program, 'u_rotationSpeed'),
                    gridDensity: this.gl.getUniformLocation(this.program, 'u_gridDensity'),
                    moireScale: this.gl.getUniformLocation(this.program, 'u_moireScale'),
                    colorShift: this.gl.getUniformLocation(this.program, 'u_colorShift'),
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    mouse: this.gl.getUniformLocation(this.program, 'u_mouse'),
                    touchIntensity: this.gl.getUniformLocation(this.program, 'u_touchIntensity'),
                    touchPoint: this.gl.getUniformLocation(this.program, 'u_touchPoint'),
                    touchChaos: this.gl.getUniformLocation(this.program, 'u_touchChaos'),
                    trailPersistence: this.gl.getUniformLocation(this.program, 'u_trailPersistence'),
                    resonanceWarp: this.gl.getUniformLocation(this.program, 'u_resonanceWarp'),
                    evolutionPhase: this.gl.getUniformLocation(this.program, 'u_evolutionPhase'),
                    evolutionPrimary: this.gl.getUniformLocation(this.program, 'u_evolutionPrimary'),
                    evolutionSecondary: this.gl.getUniformLocation(this.program, 'u_evolutionSecondary'),
                    evolutionPulse: this.gl.getUniformLocation(this.program, 'u_evolutionPulse'),
                    evolutionVector: this.gl.getUniformLocation(this.program, 'u_evolutionVector'),
                    memoryImprint: this.gl.getUniformLocation(this.program, 'u_memoryImprint'),
                    audioEnabled: this.gl.getUniformLocation(this.program, 'u_audioEnabled'),
                    bassLevel: this.gl.getUniformLocation(this.program, 'u_bassLevel'),
                    midLevel: this.gl.getUniformLocation(this.program, 'u_midLevel'),
                    highLevel: this.gl.getUniformLocation(this.program, 'u_highLevel'),
                    pitchFactor: this.gl.getUniformLocation(this.program, 'u_pitchFactor')
                };
            }
            
            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    return null;
                }
                
                return shader;
            }
            
            createGeometry() {
                // Fullscreen quad
                const vertices = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                this.vertexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }
            
            bindEvents() {
                // Mouse tracking
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX / window.innerWidth;
                    this.mouseY = 1.0 - (e.clientY / window.innerHeight); // Flip Y
                });
                
                // PARAMETER-ONLY SCROLL (NO ACTUAL PAGE MOVEMENT)
                this.scrollParameter = 0;
                
                window.addEventListener('wheel', (e) => {
                    e.preventDefault(); // Prevent actual scrolling
                    
                    // Accumulate scroll input into parameter
                    const delta = e.deltaY * 0.001;
                    this.scrollParameter += delta;
                    this.scrollParameter = Math.max(0, Math.min(1, this.scrollParameter)); // Clamp 0-1
                    
                    // Bind scroll parameter to grid density (5.0 to 25.0)
                    this.params.gridDensity = 5.0 + (this.scrollParameter * 20.0);
                    document.getElementById('gridDensity').value = this.params.gridDensity;
                    document.getElementById('gridValue').textContent = this.params.gridDensity.toFixed(1);
                    
                    // Bind scroll parameter to color shift (-1.0 to 1.0)
                    this.params.colorShift = -1.0 + (this.scrollParameter * 2.0);
                    document.getElementById('colorShift').value = this.params.colorShift;
                    document.getElementById('colorValue').textContent = this.params.colorShift.toFixed(1);
                    
                    // Update scroll indicator
                    const indicator = document.getElementById('scrollIndicator');
                    if (indicator) {
                        indicator.textContent = `Scroll: ${(this.scrollParameter * 100).toFixed(1)}% | Grid: ${this.params.gridDensity.toFixed(1)} | Color: ${this.params.colorShift.toFixed(2)}`;
                    }
                    
                    console.log(`üéõÔ∏è Parameter scroll: ${(this.scrollParameter * 100).toFixed(1)}% ‚Üí Grid: ${this.params.gridDensity.toFixed(1)}, Color: ${this.params.colorShift.toFixed(2)} (no page movement)`);
                    this.persistState();
                }, { passive: false });
                
                // Parameter controls
                this.evolutionStatusEl = document.getElementById('evolutionStatus');

                const params = ['dimension', 'morphFactor', 'glitchIntensity', 'rotationSpeed', 'gridDensity', 'moireScale', 'colorShift', 'trailPersistence', 'resonanceWarp'];
                params.forEach(param => {
                    const slider = document.getElementById(param);
                    const display = document.getElementById(param + 'Value');
                    slider.addEventListener('input', (e) => {
                        this.params[param] = parseFloat(e.target.value);
                        const decimals = (param === 'colorShift' || param === 'gridDensity' || param === 'dimension' || param === 'rotationSpeed') ? 1 : 2;
                        display.textContent = parseFloat(e.target.value).toFixed(decimals);
                    });
                    slider.addEventListener('change', () => this.persistState());
                });

                document.querySelectorAll('.scene-pill').forEach((pill) => {
                    pill.addEventListener('click', () => {
                        this.stopEvolutionCycle();
                        document.querySelectorAll('.scene-pill').forEach(btn => btn.classList.remove('active'));
                        pill.classList.add('active');
                        this.setEvolutionMode(pill.dataset.mode, { manual: true });
                    });
                });

                const cycleBtn = document.getElementById('evolutionCycleBtn');
                if (cycleBtn) {
                    this.cycleButton = cycleBtn;
                    cycleBtn.addEventListener('click', () => this.cycleEvolutions());
                }

                document.getElementById('audioBtn').addEventListener('click', () => this.toggleAudio());
            }

            updateEvolutionStatus(text) {
                if (!this.evolutionStatusEl) return;
                const now = new Date();
                this.evolutionStatusEl.textContent = `${text} ‚Ä¢ ${now.toLocaleTimeString()}`;
            }

            persistState() {
                if (!this.storageAvailable) return;
                const payload = {
                    params: this.params,
                    evolutionMode: this.evolutionMode,
                    evolutionMemory: this.evolutionMemory,
                    evolutionPhase: this.evolutionPhase,
                    scrollParameter: this.scrollParameter || 0
                };
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(payload));
                } catch (error) {
                    console.warn('Failed to persist MVEP state', error);
                }
            }

            restoreState() {
                if (!this.storageAvailable) return false;
                const raw = localStorage.getItem(this.storageKey);
                if (!raw) return false;
                try {
                    const saved = JSON.parse(raw);
                    if (saved.params) {
                        Object.assign(this.params, saved.params);
                        Object.entries(saved.params).forEach(([key, value]) => {
                            const slider = document.getElementById(key);
                            const display = document.getElementById(`${key}Value`);
                            if (slider) {
                                slider.value = value;
                            }
                            if (display) {
                                const decimals = (key === 'colorShift' || key === 'gridDensity' || key === 'dimension' || key === 'rotationSpeed') ? 1 : 2;
                                display.textContent = parseFloat(value).toFixed(decimals);
                            }
                        });
                    }
                    if (saved.evolutionMode && this.evolutionConfigs[saved.evolutionMode]) {
                        this.evolutionMode = saved.evolutionMode;
                    }
                    if (typeof saved.evolutionMemory === 'number') {
                        this.evolutionMemory = saved.evolutionMemory;
                    }
                    if (typeof saved.evolutionPhase === 'number') {
                        this.evolutionPhase = saved.evolutionPhase;
                    }
                    if (typeof saved.scrollParameter === 'number') {
                        this.scrollParameter = saved.scrollParameter;
                        const indicator = document.getElementById('scrollIndicator');
                        if (indicator) {
                            indicator.textContent = `Scroll: ${(this.scrollParameter * 100).toFixed(1)}% | Grid: ${this.params.gridDensity.toFixed(1)} | Color: ${this.params.colorShift.toFixed(2)}`;
                        }
                    }
                    return true;
                } catch (error) {
                    console.warn('Failed to restore MVEP state', error);
                    return false;
                }
            }

            setEvolutionMode(mode, { manual = false } = {}) {
                const config = this.evolutionConfigs[mode];
                if (!config) return;
                this.evolutionMode = mode;
                this.params.morphFactor = Math.min(1.5, 0.6 + config.morphBoost);
                this.params.glitchIntensity = Math.min(0.2, 0.03 + config.chaosBoost * 0.4);
                const baseShift = config.colorShiftBase ?? 0;
                this.params.colorShift = Math.max(-1.0, Math.min(1.0, baseShift + (manual ? 0 : this.touchChaos * 0.1)));
                this.params.trailPersistence = Math.min(1.0, Math.max(0.0, this.params.trailPersistence + config.pulse * 0.05));
                this.params.resonanceWarp = Math.min(1.0, Math.max(0.0, config.pulse * 0.5));
                this.touchChaos = Math.min(1.0, this.touchChaos + config.chaosBoost * 0.4);
                this.touchIntensity = Math.min(1.0, this.touchIntensity + config.pulse * 0.2);
                this.evolutionMemory = Math.min(1.0, this.evolutionMemory * 0.7 + (config.pulse + config.chaosBoost) * 0.25);

                const controlsToUpdate = [
                    ['morphFactor', this.params.morphFactor],
                    ['glitchIntensity', this.params.glitchIntensity],
                    ['colorShift', this.params.colorShift],
                    ['trailPersistence', this.params.trailPersistence],
                    ['resonanceWarp', this.params.resonanceWarp]
                ];
                controlsToUpdate.forEach(([id, value]) => {
                    const slider = document.getElementById(id);
                    const display = document.getElementById(id + 'Value');
                    if (slider) slider.value = value;
                    if (display) {
                        const decimals = (id === 'colorShift' || id === 'gridDensity' || id === 'dimension' || id === 'rotationSpeed') ? 1 : 2;
                        display.textContent = value.toFixed(decimals);
                    }
                });

                document.querySelectorAll('.scene-pill').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });

                this.updateEvolutionStatus(`${config.label} engaged${manual ? ' ‚Ä¢ manual override' : ''}`);
                this.persistState();
            }

            stopEvolutionCycle() {
                if (this.evolutionCycleTimer) {
                    clearInterval(this.evolutionCycleTimer);
                    this.evolutionCycleTimer = null;
                    this.updateEvolutionStatus('Evolution cycle paused');
                    if (this.cycleButton) {
                        this.cycleButton.textContent = 'Cycle Evolutions';
                    }
                    this.persistState();
                }
            }

            cycleEvolutions() {
                if (this.evolutionCycleTimer) {
                    this.stopEvolutionCycle();
                    return;
                }

                const modes = Object.keys(this.evolutionConfigs);
                let index = modes.indexOf(this.evolutionMode);
                this.updateEvolutionStatus('Evolution cycle initiated');
                if (this.cycleButton) {
                    this.cycleButton.textContent = 'Stop Evolution Cycle';
                }

                index = (index + 1) % modes.length;
                this.setEvolutionMode(modes[index]);

                this.evolutionCycleTimer = setInterval(() => {
                    index = (index + 1) % modes.length;
                    this.setEvolutionMode(modes[index]);
                }, 6200);
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = this.audioContext.createMediaStreamSource(stream);
                    
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    source.connect(this.analyser);
                    
                    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
                    this.audioEnabled = true;
                    
                    document.getElementById('audioBtn').textContent = 'Audio: ON';
                    document.getElementById('status').textContent = 'MVEP 4D Hypercube - Mouse: Move | Audio: LIVE';
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            toggleAudio() {
                if (!this.audioEnabled) {
                    this.initAudio();
                } else {
                    this.audioEnabled = false;
                    document.getElementById('audioBtn').textContent = 'Enable Audio';
                    document.getElementById('status').textContent = 'MVEP 4D Hypercube - Mouse: Move | Audio: OFF';
                }
                this.persistState();
            }
            
            updateAudio() {
                if (!this.audioEnabled || !this.analyser) return;
                
                this.analyser.getByteFrequencyData(this.frequencyData);
                
                // Extract frequency bands
                const bassEnd = Math.floor(this.frequencyData.length * 0.1);
                const midEnd = Math.floor(this.frequencyData.length * 0.4);
                
                let bass = 0, mid = 0, high = 0;
                
                for (let i = 0; i < bassEnd; i++) {
                    bass += this.frequencyData[i];
                }
                bass /= (bassEnd * 255);
                
                for (let i = bassEnd; i < midEnd; i++) {
                    mid += this.frequencyData[i];
                }
                mid /= ((midEnd - bassEnd) * 255);
                
                for (let i = midEnd; i < this.frequencyData.length; i++) {
                    high += this.frequencyData[i];
                }
                high /= ((this.frequencyData.length - midEnd) * 255);
                
                this.audioData = { bass, mid, high, pitch: 0 };
            }
            
            render() {
                this.time = (Date.now() - this.startTime) / 1000;

                this.updateAudio();

                // Ease touch parameters back to calm state
                const persistence = 0.82 + this.params.trailPersistence * 0.15;
                const chaosDamping = 0.9 + this.params.trailPersistence * 0.08;
                this.touchIntensity = Math.max(0.0, this.touchIntensity * persistence - 0.001 * (1.0 - this.params.trailPersistence * 0.5));
                this.touchChaos = Math.max(0.0, this.touchChaos * chaosDamping - 0.0005);
                this.evolutionPhase = (this.evolutionPhase + 0.0025 + this.params.resonanceWarp * 0.002 + this.audioData.mid * 0.004) % 1.0;
                this.evolutionMemory = Math.max(0.1, this.evolutionMemory * 0.995 + this.audioData.mid * 0.002 + this.touchChaos * 0.003);
                if (this.storageAvailable && Date.now() - this.lastPersist > 5000) {
                    this.persistState();
                    this.lastPersist = Date.now();
                }
                const evolutionConfig = this.evolutionConfigs[this.evolutionMode] || this.evolutionConfigs.aurora;

                this.gl.clear(this.gl.COLOR_BUFFER_BIT);

                // Set uniforms
                this.gl.uniform1f(this.uniforms.time, this.time);
                this.gl.uniform1f(this.uniforms.dimension, this.params.dimension);
                this.gl.uniform1f(this.uniforms.morphFactor, this.params.morphFactor);
                this.gl.uniform1f(this.uniforms.glitchIntensity, this.params.glitchIntensity);
                this.gl.uniform1f(this.uniforms.rotationSpeed, this.params.rotationSpeed);
                this.gl.uniform1f(this.uniforms.gridDensity, this.params.gridDensity);
                this.gl.uniform1f(this.uniforms.moireScale, this.params.moireScale);
                this.gl.uniform1f(this.uniforms.colorShift, this.params.colorShift);
                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform2f(this.uniforms.mouse, this.mouseX, this.mouseY);
                this.gl.uniform1f(this.uniforms.touchIntensity, this.touchIntensity);
                this.gl.uniform2f(this.uniforms.touchPoint, this.touchPoint.x, this.touchPoint.y);
                this.gl.uniform1f(this.uniforms.touchChaos, this.touchChaos);
                this.gl.uniform1f(this.uniforms.trailPersistence, this.params.trailPersistence);
                this.gl.uniform1f(this.uniforms.resonanceWarp, this.params.resonanceWarp);
                this.gl.uniform1f(this.uniforms.evolutionPhase, this.evolutionPhase);
                this.gl.uniform3f(this.uniforms.evolutionPrimary, evolutionConfig.paletteA[0], evolutionConfig.paletteA[1], evolutionConfig.paletteA[2]);
                this.gl.uniform3f(this.uniforms.evolutionSecondary, evolutionConfig.paletteB[0], evolutionConfig.paletteB[1], evolutionConfig.paletteB[2]);
                const pulse = evolutionConfig.pulse + this.audioData.bass * 0.3;
                this.gl.uniform1f(this.uniforms.evolutionPulse, pulse);
                this.gl.uniform3f(this.uniforms.evolutionVector, evolutionConfig.vector[0], evolutionConfig.vector[1], evolutionConfig.vector[2]);
                this.gl.uniform1f(this.uniforms.memoryImprint, this.evolutionMemory);

                // Audio uniforms
                this.gl.uniform1f(this.uniforms.audioEnabled, this.audioEnabled ? 1.0 : 0.0);
                this.gl.uniform1f(this.uniforms.bassLevel, this.audioData.bass);
                this.gl.uniform1f(this.uniforms.midLevel, this.audioData.mid);
                this.gl.uniform1f(this.uniforms.highLevel, this.audioData.high);
                this.gl.uniform1f(this.uniforms.pitchFactor, this.audioData.pitch);
                
                // Draw
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
            
            animate() {
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize
        const mvepVisualizer = new MVEPMoireHypercube();
        window.mvepVisualizer = mvepVisualizer;

        // Add touch reactions for mobile
        function setupTouchReactions() {
            const rippleStyleId = 'mvep-touch-ripple-style';
            if (!document.getElementById(rippleStyleId)) {
                const rippleStyle = document.createElement('style');
                rippleStyle.id = rippleStyleId;
                rippleStyle.textContent = `
                    @keyframes mvepTouchRipple {
                        0% { transform: scale(0.4); opacity: 0.9; }
                        100% { transform: scale(3.2); opacity: 0; }
                    }

                    .mvep-touch-ripple {
                        position: absolute;
                        width: 70px;
                        height: 70px;
                        border-radius: 50%;
                        border: 2px solid rgba(0, 255, 255, 0.8);
                        pointer-events: none;
                        animation: mvepTouchRipple 0.7s ease-out forwards;
                        box-shadow: 0 0 18px rgba(255, 0, 255, 0.4);
                    }
                `;
                document.head.appendChild(rippleStyle);
            }

            const overlayId = 'mvep-touch-overlay';
            let overlay = document.getElementById(overlayId);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1200;
                `;
                document.body.appendChild(overlay);
            }

            const statusEl = document.getElementById('status');

            const spawnRipple = (clientX, clientY, scale = 1) => {
                const ripple = document.createElement('div');
                ripple.className = 'mvep-touch-ripple';
                ripple.style.left = `${clientX - 35}px`;
                ripple.style.top = `${clientY - 35}px`;
                ripple.style.transform = `scale(${Math.max(0.6, scale)})`;
                overlay.appendChild(ripple);
                setTimeout(() => ripple.remove(), 700);
            };

            const updateTouchState = (clientX, clientY, intensity) => {
                if (!mvepVisualizer) return;
                const normX = clientX / window.innerWidth;
                const normY = 1.0 - (clientY / window.innerHeight);

                mvepVisualizer.mouseX = normX;
                mvepVisualizer.mouseY = normY;
                mvepVisualizer.touchPoint = { x: normX, y: normY };
                mvepVisualizer.touchIntensity = Math.min(1.0, Math.max(mvepVisualizer.touchIntensity, intensity));
                mvepVisualizer.touchChaos = Math.min(1.0, mvepVisualizer.touchChaos + intensity * 0.25);

                if (statusEl) {
                    statusEl.textContent = 'MVEP 4D Hypercube ‚Äì Touch drive active';
                }
            };

            const updateChaosFromTouches = (touches) => {
                if (!mvepVisualizer || touches.length < 2) return;
                const touch1 = touches[0];
                const touch2 = touches[1];
                const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const normalized = Math.min(1, distance / 240);
                mvepVisualizer.touchChaos = Math.min(1.0, mvepVisualizer.touchChaos + normalized * 0.4);
            };

            document.addEventListener('touchstart', (e) => {
                if (!mvepVisualizer) return;
                if (e.target && e.target.closest('.controls')) return;
                const primary = e.touches[0];
                updateTouchState(primary.clientX, primary.clientY, 1.0);
                spawnRipple(primary.clientX, primary.clientY, 1);
                updateChaosFromTouches(e.touches);
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!mvepVisualizer) return;
                if (e.target && e.target.closest('.controls')) return;
                const primary = e.touches[0];
                updateTouchState(primary.clientX, primary.clientY, 0.8);
                updateChaosFromTouches(e.touches);
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!mvepVisualizer) return;
                if (e.touches.length === 0) {
                    mvepVisualizer.touchIntensity *= 0.4;
                    if (statusEl) {
                        statusEl.textContent = 'MVEP 4D Hypercube - Mouse: Move | Scroll: Grid/Color | Audio: ' + (mvepVisualizer.audioEnabled ? 'LIVE' : 'OFF');
                    }
                }
            });
        }
        
        // Initialize touch reactions when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupTouchReactions);
        } else {
            setupTouchReactions();
        }
    </script>
    
    <!-- Add collapsible menu system -->
    <script>
        window.COLLAPSIBLE_MENU_CONFIG = {
            startCollapsed: true,
            position: 'top-right',
            theme: 'dark'
        };
    </script>
    <script src="../js/inject-collapsible-menu.js"></script>
</body>
</html>