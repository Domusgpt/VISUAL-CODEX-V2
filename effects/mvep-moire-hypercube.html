<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVEP Moir√© 4D Hypercube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            height: 300vh; /* Make it scrollable */
        }
        
        .infinite-scroll-content {
            height: 300vh;
            background: linear-gradient(0deg, 
                rgba(0,20,40,0.3) 0%, 
                rgba(20,0,40,0.2) 33%, 
                rgba(40,20,0,0.2) 66%, 
                rgba(0,40,20,0.3) 100%);
        }
        
        .scroll-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #00ffff;
            color: #00ffff;
            z-index: 100;
            font-size: 12px;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .controls {
            /* position: absolute; */
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border: 1px solid #00ffff;
            color: #00ffff;
            z-index: 100;
            width: 200px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            color: #ff00ff;
            font-weight: bold;
        }
        .phase-dock {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0,255,255,0.25);
        }
        .phase-dock h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            letter-spacing: 0.08em;
            color: #00ffff;
        }
        .phase-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(120px, 1fr));
            gap: 6px;
        }
        .phase-chip {
            background: linear-gradient(135deg, rgba(0,0,0,0.5), rgba(0,40,60,0.7));
            border: 1px solid rgba(0,255,255,0.35);
            color: #a0ffff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: transform 0.2s ease, border 0.2s ease;
        }
        .phase-chip:hover {
            transform: translateY(-2px);
            border-color: rgba(255,255,0,0.6);
        }
        .phase-chip.active {
            border-color: rgba(255,255,0,0.85);
            color: #ffffcc;
            box-shadow: 0 0 14px rgba(255,255,0,0.35);
        }
        .phase-autopilot {
            margin-top: 10px;
            width: 100%;
            background: rgba(255,255,0,0.18);
            border: 1px solid rgba(255,255,0,0.45);
            color: #ffffaa;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .phase-autopilot:hover {
            background: rgba(255,255,0,0.32);
            box-shadow: 0 0 12px rgba(255,255,0,0.25);
        }
        .audio-btn {
            background: rgba(0,255,255,0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 15px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        .audio-btn:hover {
            background: rgba(0,255,255,0.4);
        }
        .status {
            position: absolute;
            top: 10px;
            left: 20px;
            color: #ffff00;
            font-size: 14px;
        }
        .phase-timeline {
            position: fixed;
            top: 140px;
            left: 20px;
            width: 260px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 12px;
            padding: 14px;
            color: #a0ffff;
            font-size: 11px;
            box-shadow: 0 0 16px rgba(0,255,255,0.2);
        }
        .phase-timeline h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            letter-spacing: 0.08em;
        }
        .phase-timeline-entry {
            border-left: 2px solid rgba(0,255,255,0.35);
            padding-left: 10px;
            margin-bottom: 8px;
        }
        .phase-timeline-entry strong {
            display: block;
            color: #ffffaa;
            font-size: 11px;
        }
        .phase-timeline-entry span {
            display: block;
            color: rgba(255,255,255,0.7);
            margin-top: 2px;
        }
        .phase-orbit {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(0,255,255,0.35);
            border-radius: 10px;
            padding: 10px 16px;
            color: #a0ffff;
            font-size: 11px;
            letter-spacing: 0.05em;
            max-width: 360px;
            text-align: center;
            box-shadow: 0 0 14px rgba(0,255,255,0.2);
        }
    </style>
</head>
<body>
    <div class="infinite-scroll-content"></div>
    <canvas id="canvas"></canvas>
    
    <div class="status" id="status">
        MVEP 4D Hypercube - Mouse: Move | Scroll: Grid/Color | Audio: Click to Enable
    </div>
    
    <div class="scroll-indicator" id="scrollIndicator">
        Scroll: 0% | Grid: 12.0 | Color: 0.00
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label>Dimension: <span class="value-display" id="dimensionValue">3.8</span></label>
            <input type="range" id="dimension" min="3.0" max="5.0" step="0.1" value="3.8">
        </div>
        <div class="control-group">
            <label>Morph Factor: <span class="value-display" id="morphValue">0.7</span></label>
            <input type="range" id="morphFactor" min="0.0" max="1.5" step="0.1" value="0.7">
        </div>
        <div class="control-group">
            <label>Glitch Intensity: <span class="value-display" id="glitchValue">0.05</span></label>
            <input type="range" id="glitchIntensity" min="0.0" max="0.2" step="0.01" value="0.05">
        </div>
        <div class="control-group">
            <label>Rotation Speed: <span class="value-display" id="rotationValue">1.2</span></label>
            <input type="range" id="rotationSpeed" min="0.0" max="3.0" step="0.1" value="1.2">
        </div>
        <div class="control-group">
            <label>Grid Density: <span class="value-display" id="gridValue">12.0</span></label>
            <input type="range" id="gridDensity" min="5.0" max="25.0" step="0.5" value="12.0">
        </div>
        <div class="control-group">
            <label>Moir√© Scale: <span class="value-display" id="moireValue">1.01</span></label>
            <input type="range" id="moireScale" min="0.95" max="1.05" step="0.001" value="1.01">
        </div>
        <div class="control-group">
            <label>Color Shift: <span class="value-display" id="colorValue">0.0</span></label>
            <input type="range" id="colorShift" min="-1.0" max="1.0" step="0.1" value="0.0">
        </div>
        <div class="phase-dock">
            <h4>Phase Evolutions</h4>
            <div class="phase-grid" id="phaseGrid">
                <button class="phase-chip active" data-phase="0">Luminous Lattice</button>
                <button class="phase-chip" data-phase="1">Nebula Bloom</button>
                <button class="phase-chip" data-phase="2">Gravity Rain</button>
                <button class="phase-chip" data-phase="3">Temporal Lace</button>
                <button class="phase-chip" data-phase="4">Aether Vines</button>
                <button class="phase-chip" data-phase="5">Chroma Tide</button>
            </div>
            <button class="phase-autopilot" id="phaseAutopilotBtn">Engage Phase Autopilot</button>
        </div>
        <button class="audio-btn" id="audioBtn">Enable Audio</button>
    </div>

    <div class="phase-timeline" id="phaseTimeline">
        <h4>Phase Timeline</h4>
        <div id="phaseTimelineEntries"></div>
    </div>

    <div class="phase-orbit" id="phaseTicker">Phase orbit idle. Scroll or select a phase.</div>

    <script>
        class MVEPMoireHypercube {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.touchIntensity = 0.0;
                this.touchPoint = { x: 0.5, y: 0.5 };
                this.touchChaos = 0.0;
                this.time = 0;
                this.startTime = Date.now();
                
                // MVEP Parameters
                this.params = {
                    dimension: 3.8,
                    morphFactor: 0.7,
                    glitchIntensity: 0.05,
                    rotationSpeed: 1.2,
                    gridDensity: 12.0,
                    moireScale: 1.01,
                    colorShift: 0.0,
                    sceneMode: 0
                };

                // Audio
                this.audioEnabled = false;
                this.audioContext = null;
                this.analyser = null;
                this.audioData = { bass: 0, mid: 0, high: 0, pitch: 0 };

                this.phaseButtons = Array.from(document.querySelectorAll('.phase-chip'));
                this.phaseAutopilotBtn = document.getElementById('phaseAutopilotBtn');
                this.phaseTimelineEl = document.getElementById('phaseTimelineEntries');
                this.phaseTickerEl = document.getElementById('phaseTicker');
                this.phaseHistory = [];
                this.phaseAutopilot = false;
                this.phasePulse = 0.0;
                this.scrollPhaseIndex = -1;
                this.scrollMomentum = 0.0;
                this.phaseVariant = Math.random();
                this.phaseSequence = null;
                this.phaseSequenceIndex = 0;
                this.phaseSchedule = null;

                this.phasePresets = [
                    {
                        name: 'Luminous Lattice',
                        ticker: 'Luminous lattice stabilized ‚Äì crystalline edges sharpened.',
                        targets: { dimension: 3.6, morphFactor: 0.5, glitchIntensity: 0.04, rotationSpeed: 1.0, gridDensity: 10.0, moireScale: 1.01, colorShift: -0.2 }
                    },
                    {
                        name: 'Nebula Bloom',
                        ticker: 'Nebula bloom unfolding ‚Äì chromatic mist blooms outward.',
                        targets: { dimension: 4.1, morphFactor: 1.1, glitchIntensity: 0.08, rotationSpeed: 1.6, gridDensity: 14.5, moireScale: 1.015, colorShift: 0.35 }
                    },
                    {
                        name: 'Gravity Rain',
                        ticker: 'Gravity rain activated ‚Äì vertical sheets bending geometry.',
                        targets: { dimension: 4.4, morphFactor: 0.9, glitchIntensity: 0.12, rotationSpeed: 1.9, gridDensity: 18.0, moireScale: 1.02, colorShift: -0.6 }
                    },
                    {
                        name: 'Temporal Lace',
                        ticker: 'Temporal lace weaving ‚Äì layered echoes trailing motion.',
                        targets: { dimension: 3.9, morphFactor: 1.3, glitchIntensity: 0.09, rotationSpeed: 0.85, gridDensity: 8.5, moireScale: 0.995, colorShift: 0.6 }
                    },
                    {
                        name: 'Aether Vines',
                        ticker: 'Aether vines entwined ‚Äì bio-lattice strands climbing.',
                        targets: { dimension: 3.5, morphFactor: 1.6, glitchIntensity: 0.07, rotationSpeed: 1.45, gridDensity: 11.5, moireScale: 1.018, colorShift: 0.85 }
                    },
                    {
                        name: 'Chroma Tide',
                        ticker: 'Chroma tide surging ‚Äì spectral undertow oscillating.',
                        targets: { dimension: 4.6, morphFactor: 1.05, glitchIntensity: 0.14, rotationSpeed: 2.1, gridDensity: 20.0, moireScale: 1.028, colorShift: -0.85 }
                    }
                ];

                this.phaseSequences = [
                    [0, 2, 5, 3],
                    [1, 4, 2],
                    [4, 0, 3, 5],
                    [5, 1, 3, 0]
                ];

                this.init();
            }
            
            init() {
                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }
                
                this.setupCanvas();
                this.createShaders();
                this.createGeometry();
                this.bindEvents();
                this.setPhase(0, 'init');
                this.animate();
            }
            
            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                };
                resize();
                window.addEventListener('resize', resize);
            }
            
            createShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    varying vec2 v_uv;
                    
                    void main() {
                        v_uv = a_position * 0.5 + 0.5;
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;
                
                const fragmentShaderSource = `
                    precision highp float;
                    
                    varying vec2 v_uv;
                    
                    uniform float u_time;
                    uniform float u_dimension;
                    uniform float u_morphFactor;
                    uniform float u_glitchIntensity;
                    uniform float u_rotationSpeed;
                    uniform float u_gridDensity;
                    uniform float u_moireScale;
                    uniform float u_colorShift;
                    uniform vec2 u_resolution;
                    uniform vec2 u_mouse;
                    uniform float u_touchIntensity;
                    uniform vec2 u_touchPoint;
                    uniform float u_touchChaos;
                    uniform float u_sceneMode;
                    uniform float u_phasePulse;
                    uniform float u_phaseVariant;

                    // Audio uniforms
                    uniform float u_audioEnabled;
                    uniform float u_bassLevel;
                    uniform float u_midLevel;
                    uniform float u_highLevel;
                    uniform float u_pitchFactor;
                    
                    // 4D Rotation Matrices
                    mat4 rotateXW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(
                            c, 0.0, 0.0, -s,
                            0.0, 1.0, 0.0, 0.0,
                            0.0, 0.0, 1.0, 0.0,
                            s, 0.0, 0.0, c
                        );
                    }
                    
                    mat4 rotateYW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(
                            1.0, 0.0, 0.0, 0.0,
                            0.0, c, 0.0, -s,
                            0.0, 0.0, 1.0, 0.0,
                            0.0, s, 0.0, c
                        );
                    }
                    
                    mat4 rotateZW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(
                            1.0, 0.0, 0.0, 0.0,
                            0.0, 1.0, 0.0, 0.0,
                            0.0, 0.0, c, -s,
                            0.0, 0.0, s, c
                        );
                    }
                    
                    // 4D to 3D projection
                    vec3 project4Dto3D(vec4 point4D) {
                        float w = point4D.w + 2.0;
                        return point4D.xyz / max(w, 0.1);
                    }
                    
                    // 4D Hypercube distance field
                    float hypercubeLattice(vec3 p, float morphFactor, float gridDensity) {
                        // Convert to 4D space
                        vec4 p4d = vec4(p * gridDensity, sin(u_time * 0.5) * morphFactor);
                        
                        // Apply 4D rotations with mouse influence
                        float rotX = u_time * u_rotationSpeed + u_mouse.x * 3.14159;
                        float rotY = u_time * u_rotationSpeed * 0.7 + u_mouse.y * 3.14159;
                        float rotZ = u_time * u_rotationSpeed * 0.5;
                        
                        // Audio-reactive rotation if available
                        if (u_audioEnabled > 0.5) {
                            rotX += u_bassLevel * 2.0;
                            rotY += u_midLevel * 1.5;
                            rotZ += u_highLevel * 1.0;
                        }
                        
                        p4d = rotateXW(rotX) * p4d;
                        p4d = rotateYW(rotY) * p4d;
                        p4d = rotateZW(rotZ) * p4d;
                        
                        // Hypercube lattice calculation
                        vec4 latticePos = fract(p4d) - 0.5;
                        float dist = max(max(abs(latticePos.x), abs(latticePos.y)), 
                                       max(abs(latticePos.z), abs(latticePos.w)));
                        
                        return 1.0 - smoothstep(0.4, 0.5, dist);
                    }
                    
                    // Moir√© pattern generation
                    float generateMoire(vec3 p, float morphFactor, float gridDensity) {
                        float grid1 = hypercubeLattice(p, morphFactor, gridDensity);
                        float grid2 = hypercubeLattice(p, morphFactor, gridDensity * u_moireScale);
                        return abs(grid1 - grid2) * 0.5;
                    }
                    
                    // RGB Color splitting effect
                    vec3 applyColorSplitting(vec2 uv, vec3 baseColor) {
                        float glitchAmount = u_glitchIntensity;
                        if (u_audioEnabled > 0.5) {
                            glitchAmount += u_highLevel * 0.1;
                        }
                        
                        vec2 rOffset = vec2(glitchAmount, glitchAmount * 0.5);
                        vec2 gOffset = vec2(-glitchAmount * 0.3, glitchAmount * 0.2);
                        vec2 bOffset = vec2(glitchAmount * 0.1, -glitchAmount * 0.4);
                        
                        float r = baseColor.r;
                        float g = baseColor.g * 0.9;
                        float b = baseColor.b * 0.8;
                        
                        return vec3(r, g, b);
                    }

                    // Hue shift function
                    vec3 hueShift(vec3 color, float shift) {
                        float c = cos(shift);
                        float s = sin(shift);
                        mat3 hueMatrix = mat3(
                            0.299 + 0.701*c + 0.168*s, 0.587 - 0.587*c + 0.330*s, 0.114 - 0.114*c - 0.497*s,
                            0.299 - 0.299*c - 0.328*s, 0.587 + 0.413*c + 0.035*s, 0.114 - 0.114*c + 0.292*s,
                            0.299 - 0.300*c + 1.25*s, 0.587 - 0.588*c - 1.05*s, 0.114 + 0.886*c - 0.203*s
                        );
                        return hueMatrix * color;
                    }

                    vec3 applyPhaseEvolution(vec3 color, vec3 rayDir, vec2 uv) {
                        float mode = u_sceneMode;
                        float flux = clamp(u_phasePulse, 0.0, 1.5);
                        float variant = u_phaseVariant;
                        vec2 centered = uv - 0.5;
                        float radius = length(centered);
                        if (mode < 0.5) {
                            vec3 glow = vec3(0.2 + flux * 0.6, 0.15 + flux * 0.4, 0.35 + flux * 0.7);
                            return color * (1.0 + flux * 0.35) + glow * 0.4;
                        } else if (mode < 1.5) {
                            float bloom = smoothstep(0.45, 0.05, radius);
                            vec3 nebula = vec3(0.35 + flux * 0.7, 0.25 + flux * 0.6, 0.9 + flux * 0.5);
                            nebula *= 0.8 + sin(rayDir.y * 4.0 + u_time * 1.5) * 0.2;
                            return mix(color, nebula, clamp(0.35 + bloom * flux, 0.0, 0.85));
                        } else if (mode < 2.5) {
                            float streak = sin(rayDir.y * 6.0 + u_time * 4.0) * cos(uv.x * 40.0 - u_time * 2.0);
                            vec3 rain = vec3(0.2 + flux * 0.6, 0.1 + flux * 0.25, 0.45 + flux * 0.8) * (0.8 + streak * 0.4);
                            return mix(color, rain, clamp(0.4 + flux * 0.6, 0.0, 1.0));
                        } else if (mode < 3.5) {
                            float lace = sin((rayDir.x + rayDir.z) * 6.0 + u_time * 1.2) * cos(rayDir.y * 6.0 - u_time * 1.4);
                            vec3 overlay = vec3(0.7 + flux * 0.4, 0.75 + flux * 0.35, 0.95 + flux * 0.4);
                            overlay *= 0.8 + lace * 0.3;
                            overlay += vec3(flux * 0.25);
                            return mix(color, overlay, clamp(0.45 + flux * 0.5, 0.0, 1.0));
                        } else if (mode < 4.5) {
                            float vineWeave = sin((rayDir.x + rayDir.z) * (5.0 + variant * 3.5) + u_time * 1.8);
                            float vineCurl = cos((rayDir.y + radius) * (12.0 + variant * 6.0) - u_time * 1.2);
                            float tendrils = pow(max(0.0, vineWeave * 0.6 + vineCurl * 0.4 + flux * 0.25), 1.35);
                            vec3 vines = vec3(
                                0.28 + tendrils * 0.5,
                                0.92 + tendrils * 0.35,
                                0.44 + tendrils * 0.4
                            );
                            vines *= 0.75 + sin(rayDir.z * (8.0 + variant * 2.5) + u_time * 0.8) * 0.25;
                            float blend = clamp(0.4 + tendrils * 0.55 + flux * 0.25, 0.0, 1.0);
                            return mix(color, vines, blend);
                        } else if (mode < 5.5) {
                            float tide = sin(centered.x * (18.0 + variant * 10.0) + u_time * (1.6 + variant));
                            float undertow = cos((rayDir.y + rayDir.z) * (9.0 + variant * 5.0) - u_time * 1.4);
                            float swell = tide * 0.6 + undertow * 0.4;
                            vec3 tideColor = vec3(
                                0.34 + swell * 0.6,
                                0.42 + swell * 0.35,
                                0.98 + swell * 0.45
                            );
                            tideColor += vec3(0.25 * flux, 0.15 * flux, 0.35 * flux);
                            float mixAmt = clamp(0.45 + abs(swell) * 0.5 + flux * 0.25, 0.0, 1.0);
                            return mix(color, tideColor, mixAmt);
                        } else {
                            float chaos = sin((rayDir.x + rayDir.y + rayDir.z) * (10.0 + variant * 6.0) + u_time * 2.2);
                            float bands = sin(radius * (28.0 + variant * 12.0) - u_time * 1.6);
                            vec3 veil = vec3(
                                0.6 + chaos * 0.35,
                                0.2 + bands * 0.3,
                                0.95 + chaos * 0.4
                            );
                            veil += vec3(0.12 * flux, 0.05 * flux, 0.18 * flux);
                            float blend = clamp(0.5 + flux * 0.4, 0.0, 1.0);
                            return mix(color, veil, blend);
                        }
                    }

                    void main() {
                        vec2 uv = (v_uv - 0.5) * 2.0;
                        uv.x *= u_resolution.x / u_resolution.y;

                        // Ray direction for 3D effect
                        vec3 rayDir = normalize(vec3(uv, 1.0));
                        
                        // Calculate hypercube lattice with morphing
                        float morphFactor = u_morphFactor;
                        if (u_audioEnabled > 0.5) {
                            morphFactor += u_bassLevel * 0.5;
                        }
                        
                        float lattice = hypercubeLattice(rayDir, morphFactor, u_gridDensity);
                        float moire = generateMoire(rayDir, morphFactor, u_gridDensity);

                        // Combine lattice and moir√©
                        float combined = lattice + moire * 0.5;
                        combined += u_phasePulse * 0.25;

                        vec2 touchUV = v_uv;
                        vec2 touchDelta = touchUV - u_touchPoint;
                        float touchFalloff = exp(-length(touchDelta) * 6.0);
                        float touchWave = sin(u_time * 6.0 - length(touchDelta) * 24.0) * 0.5 + 0.5;
                        float touchContribution = u_touchIntensity * touchFalloff * touchWave;
                        float chaosContribution = u_touchChaos * 0.35;

                        combined += touchContribution * (1.0 + chaosContribution);
                        moire += touchContribution * 0.3;

                        // Base colors (vaporwave palette)
                        vec3 color1 = vec3(0.0, 0.8, 1.0);  // Cyan
                        vec3 color2 = vec3(1.0, 0.0, 1.0);  // Magenta
                        vec3 color3 = vec3(1.0, 1.0, 0.0);  // Yellow

                        // Color mixing based on lattice pattern
                        vec3 finalColor = mix(mix(color1, color2, combined), color3, moire);

                        // Apply hue shifting
                        finalColor = hueShift(finalColor, u_colorShift + chaosContribution * 0.8);

                        // Apply RGB color splitting
                        finalColor = applyColorSplitting(v_uv, finalColor);

                        // Add some glow and intensity
                        finalColor *= (0.5 + combined * 1.5);
                        finalColor += touchContribution * vec3(0.25, 0.15, 0.45);
                        finalColor += chaosContribution * 0.4;

                        // Audio-reactive brightness
                        if (u_audioEnabled > 0.5) {
                            finalColor *= (0.8 + u_bassLevel * 0.4 + u_midLevel * 0.3);
                        }

                        // Touch-driven bloom
                        finalColor += vec3(0.05, 0.08, 0.12) * pow(touchContribution, 1.2);
                        finalColor = applyPhaseEvolution(finalColor, rayDir, v_uv);
                        finalColor *= (1.0 + u_phasePulse * 0.25);
                        finalColor = clamp(finalColor, 0.0, 1.8);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `;
                
                const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);
                
                this.program = this.gl.createProgram();
                this.gl.attachShader(this.program, vertexShader);
                this.gl.attachShader(this.program, fragmentShader);
                this.gl.linkProgram(this.program);
                
                if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(this.program));
                    return;
                }
                
                this.gl.useProgram(this.program);
                
                // Get uniform locations
                this.uniforms = {
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    dimension: this.gl.getUniformLocation(this.program, 'u_dimension'),
                    morphFactor: this.gl.getUniformLocation(this.program, 'u_morphFactor'),
                    glitchIntensity: this.gl.getUniformLocation(this.program, 'u_glitchIntensity'),
                    rotationSpeed: this.gl.getUniformLocation(this.program, 'u_rotationSpeed'),
                    gridDensity: this.gl.getUniformLocation(this.program, 'u_gridDensity'),
                    moireScale: this.gl.getUniformLocation(this.program, 'u_moireScale'),
                    colorShift: this.gl.getUniformLocation(this.program, 'u_colorShift'),
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    mouse: this.gl.getUniformLocation(this.program, 'u_mouse'),
                    touchIntensity: this.gl.getUniformLocation(this.program, 'u_touchIntensity'),
                    touchPoint: this.gl.getUniformLocation(this.program, 'u_touchPoint'),
                    touchChaos: this.gl.getUniformLocation(this.program, 'u_touchChaos'),
                    audioEnabled: this.gl.getUniformLocation(this.program, 'u_audioEnabled'),
                    bassLevel: this.gl.getUniformLocation(this.program, 'u_bassLevel'),
                    midLevel: this.gl.getUniformLocation(this.program, 'u_midLevel'),
                    highLevel: this.gl.getUniformLocation(this.program, 'u_highLevel'),
                    pitchFactor: this.gl.getUniformLocation(this.program, 'u_pitchFactor'),
                    sceneMode: this.gl.getUniformLocation(this.program, 'u_sceneMode'),
                    phasePulse: this.gl.getUniformLocation(this.program, 'u_phasePulse'),
                    phaseVariant: this.gl.getUniformLocation(this.program, 'u_phaseVariant')
                };
            }
            
            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    return null;
                }
                
                return shader;
            }
            
            createGeometry() {
                // Fullscreen quad
                const vertices = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                this.vertexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }
            
            bindEvents() {
                // Mouse tracking
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX / window.innerWidth;
                    this.mouseY = 1.0 - (e.clientY / window.innerHeight); // Flip Y
                });
                
                // PARAMETER-ONLY SCROLL (NO ACTUAL PAGE MOVEMENT)
                this.scrollParameter = 0;
                this.refreshScrollIndicator();

                window.addEventListener('wheel', (e) => {
                    e.preventDefault(); // Prevent actual scrolling

                    // Accumulate scroll input into parameter
                    const delta = e.deltaY * 0.001;
                    this.scrollParameter += delta;
                    this.scrollParameter = Math.max(0, Math.min(1, this.scrollParameter)); // Clamp 0-1

                    // Bind scroll parameter to grid density (5.0 to 25.0)
                    this.params.gridDensity = 5.0 + (this.scrollParameter * 20.0);
                    // Bind scroll parameter to color shift (-1.0 to 1.0)
                    this.params.colorShift = -1.0 + (this.scrollParameter * 2.0);
                    this.scrollMomentum = Math.min(1.0, Math.abs(delta) * 3.0);
                    this.phasePulse = Math.min(1.0, this.phasePulse + Math.abs(delta) * 2.0);
                    this.updateControlDisplays();
                    this.syncPhaseWithScroll();

                    console.log(`üéõÔ∏è Parameter scroll: ${(this.scrollParameter * 100).toFixed(1)}% ‚Üí Grid: ${this.params.gridDensity.toFixed(1)}, Color: ${this.params.colorShift.toFixed(2)} (no page movement)`);
                }, { passive: false });

                // Parameter controls
                const params = ['dimension', 'morphFactor', 'glitchIntensity', 'rotationSpeed', 'gridDensity', 'moireScale', 'colorShift'];
                const displayMap = {
                    dimension: 'dimensionValue',
                    morphFactor: 'morphValue',
                    glitchIntensity: 'glitchValue',
                    rotationSpeed: 'rotationValue',
                    gridDensity: 'gridValue',
                    moireScale: 'moireValue',
                    colorShift: 'colorValue'
                };
                params.forEach(param => {
                    const slider = document.getElementById(param);
                    const display = document.getElementById(displayMap[param]);
                    slider.addEventListener('input', (e) => {
                        this.params[param] = parseFloat(e.target.value);
                        if (display) {
                            const step = slider.step || '0.1';
                            const decimals = step.includes('.') ? step.split('.')[1].length : 0;
                            display.textContent = Number(this.params[param]).toFixed(Math.min(3, Math.max(decimals, 1)));
                        }
                        this.refreshScrollIndicator();
                    });
                });

                document.getElementById('audioBtn').addEventListener('click', () => this.toggleAudio());

                if (this.phaseButtons.length) {
                    this.phaseButtons.forEach((button) => {
                        button.addEventListener('click', () => {
                            const phase = Number(button.dataset.phase || 0);
                            if (this.phaseAutopilot) {
                                this.togglePhaseAutopilot();
                            }
                            this.setPhase(phase, 'manual');
                        });
                    });
                }

                this.phaseAutopilotBtn?.addEventListener('click', () => this.togglePhaseAutopilot());
                this.updateControlDisplays();
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = this.audioContext.createMediaStreamSource(stream);
                    
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    source.connect(this.analyser);
                    
                    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
                    this.audioEnabled = true;
                    
                    document.getElementById('audioBtn').textContent = 'Audio: ON';
                    document.getElementById('status').textContent = 'MVEP 4D Hypercube - Mouse: Move | Audio: LIVE';
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            toggleAudio() {
                if (!this.audioEnabled) {
                    this.initAudio();
                } else {
                    this.audioEnabled = false;
                    document.getElementById('audioBtn').textContent = 'Enable Audio';
                    document.getElementById('status').textContent = 'MVEP 4D Hypercube - Mouse: Move | Audio: OFF';
                }
            }

            updatePhaseTicker(message) {
                if (!this.phaseTickerEl) return;
                this.phaseTickerEl.textContent = message;
            }

            updatePhaseButtons() {
                if (!this.phaseButtons) return;
                this.phaseButtons.forEach((button) => {
                    const phase = Number(button.dataset.phase || 0);
                    button.classList.toggle('active', phase === this.params.sceneMode);
                });
            }

            refreshScrollIndicator() {
                const indicator = document.getElementById('scrollIndicator');
                if (!indicator) return;
                const percent = (this.scrollParameter || 0) * 100;
                indicator.textContent = `Scroll: ${percent.toFixed(1)}% | Grid: ${this.params.gridDensity.toFixed(1)} | Color: ${this.params.colorShift.toFixed(2)}`;
            }

            updateControlDisplays() {
                const mapping = [
                    ['dimension', 'dimensionValue', this.params.dimension],
                    ['morphFactor', 'morphValue', this.params.morphFactor],
                    ['glitchIntensity', 'glitchValue', this.params.glitchIntensity],
                    ['rotationSpeed', 'rotationValue', this.params.rotationSpeed],
                    ['gridDensity', 'gridValue', this.params.gridDensity],
                    ['moireScale', 'moireValue', this.params.moireScale],
                    ['colorShift', 'colorValue', this.params.colorShift]
                ];
                mapping.forEach(([sliderId, displayId, value]) => {
                    const slider = document.getElementById(sliderId);
                    const display = document.getElementById(displayId);
                    if (slider) {
                        slider.value = value;
                    }
                    if (display) {
                        const step = slider?.step || '0.1';
                        const decimals = step.includes('.') ? step.split('.')[1].length : 0;
                        display.textContent = Number(value).toFixed(Math.min(3, Math.max(decimals, 1)));
                    }
                });
                this.refreshScrollIndicator();
            }

            updatePhaseTimeline() {
                if (!this.phaseTimelineEl) return;
                const recent = this.phaseHistory.slice(-8).reverse();
                this.phaseTimelineEl.innerHTML = recent.map((entry) => {
                    const time = new Date(entry.timestamp).toLocaleTimeString();
                    const variant = typeof entry.variant === 'number' ? ` ‚Ä¢ Œª=${entry.variant.toFixed(2)}` : '';
                    return `
                        <div class="phase-timeline-entry">
                            <strong>${time} ‚Ä¢ ${entry.name}</strong>
                            <span>${entry.source}${variant}</span>
                        </div>
                    `;
                }).join('');
            }

            recordPhase(source) {
                const preset = this.phasePresets[this.params.sceneMode];
                this.phaseHistory.push({
                    timestamp: Date.now(),
                    mode: this.params.sceneMode,
                    name: preset?.name || `Phase ${this.params.sceneMode}`,
                    source,
                    variant: this.phaseVariant
                });
                if (this.phaseHistory.length > 40) {
                    this.phaseHistory.shift();
                }
                this.updatePhaseTimeline();
            }

            applyPhasePreset(mode, blend = 0.5) {
                const preset = this.phasePresets[mode];
                if (!preset) return;
                Object.entries(preset.targets).forEach(([key, value]) => {
                    if (typeof this.params[key] === 'number') {
                        this.params[key] = this.params[key] * (1 - blend) + value * blend;
                    }
                });
                this.updateControlDisplays();
            }

            pickPhaseSequence() {
                const selection = this.phaseSequences[Math.floor(Math.random() * this.phaseSequences.length)] || [];
                return selection.slice();
            }

            resetPhaseSchedule() {
                if (this.phaseSchedule) {
                    clearTimeout(this.phaseSchedule);
                    this.phaseSchedule = null;
                }
            }

            schedulePhaseAutopilot(initial = false) {
                if (!this.phaseAutopilot) return;
                if (!this.phaseSequence || this.phaseSequenceIndex >= this.phaseSequence.length) {
                    this.phaseSequence = this.pickPhaseSequence();
                    this.phaseSequenceIndex = 0;
                    if (this.phaseSequence.length) {
                        const itinerary = this.phaseSequence
                            .map(index => this.phasePresets[index]?.name || `Phase ${index}`)
                            .join(' ‚Üí ');
                        this.updatePhaseTicker(`Autopilot itinerary: ${itinerary}`);
                    }
                }
                if (!this.phaseSequence?.length) return;
                const next = this.phaseSequence[this.phaseSequenceIndex % this.phaseSequence.length];
                this.phaseSequenceIndex += 1;
                this.setPhase(next, 'autopilot');
                const delay = initial ? 2200 : 6500 + Math.random() * 3500;
                this.resetPhaseSchedule();
                this.phaseSchedule = setTimeout(() => this.schedulePhaseAutopilot(), delay);
            }

            setPhase(mode, source = 'manual') {
                const quiet = source === 'init';
                if (mode === this.params.sceneMode && source !== 'autopilot' && source !== 'scroll-sync' && !quiet) {
                    this.recordPhase(`${source}:retain`);
                    return;
                }
                this.params.sceneMode = mode;
                this.scrollPhaseIndex = mode;
                if (source !== 'scroll-sync' && this.phasePresets.length > 1) {
                    this.scrollParameter = mode / Math.max(1, this.phasePresets.length - 1);
                }
                this.phasePulse = quiet ? Math.max(this.phasePulse, 0.6) : 1.0;
                this.phaseVariant = Math.random();
                this.updatePhaseButtons();
                this.applyPhasePreset(mode, source === 'autopilot' ? 0.55 : 0.45);
                const preset = this.phasePresets[mode];
                if (preset) {
                    if (!quiet) {
                        this.updatePhaseTicker(preset.ticker);
                    } else {
                        this.updatePhaseTicker('Phase orbit idle. Scroll or select a phase.');
                    }
                }
                this.touchChaos = Math.min(1.0, this.touchChaos + (quiet ? 0.15 : 0.3));
                this.recordPhase(`${source}:${preset?.name || mode}`);
            }

            togglePhaseAutopilot() {
                this.phaseAutopilot = !this.phaseAutopilot;
                if (this.phaseAutopilotBtn) {
                    this.phaseAutopilotBtn.textContent = this.phaseAutopilot ? 'Disengage Phase Autopilot' : 'Engage Phase Autopilot';
                }
                if (this.phaseAutopilot) {
                    this.updatePhaseTicker('Autopilot weaving through the phase orbit.');
                    this.phaseSequence = this.pickPhaseSequence();
                    this.phaseSequenceIndex = 0;
                    this.schedulePhaseAutopilot(true);
                } else {
                    this.updatePhaseTicker('Phase orbit idle. Scroll or select a phase.');
                    this.resetPhaseSchedule();
                    this.phaseSequence = null;
                    this.phaseSequenceIndex = 0;
                }
            }

            syncPhaseWithScroll() {
                const phases = this.phasePresets.length;
                if (!phases) return;
                const index = Math.min(phases - 1, Math.max(0, Math.floor((this.scrollParameter || 0) * phases)));
                if (index !== this.scrollPhaseIndex) {
                    this.scrollPhaseIndex = index;
                    this.setPhase(index, 'scroll-sync');
                }
            }
            
            updateAudio() {
                if (!this.audioEnabled || !this.analyser) return;
                
                this.analyser.getByteFrequencyData(this.frequencyData);
                
                // Extract frequency bands
                const bassEnd = Math.floor(this.frequencyData.length * 0.1);
                const midEnd = Math.floor(this.frequencyData.length * 0.4);
                
                let bass = 0, mid = 0, high = 0;
                
                for (let i = 0; i < bassEnd; i++) {
                    bass += this.frequencyData[i];
                }
                bass /= (bassEnd * 255);
                
                for (let i = bassEnd; i < midEnd; i++) {
                    mid += this.frequencyData[i];
                }
                mid /= ((midEnd - bassEnd) * 255);
                
                for (let i = midEnd; i < this.frequencyData.length; i++) {
                    high += this.frequencyData[i];
                }
                high /= ((this.frequencyData.length - midEnd) * 255);
                
                this.audioData = { bass, mid, high, pitch: 0 };
            }
            
            render() {
                this.time = (Date.now() - this.startTime) / 1000;

                this.updateAudio();

                // Ease touch parameters back to calm state
                this.touchIntensity = Math.max(0.0, this.touchIntensity * 0.92 - 0.001);
                this.touchChaos = Math.max(0.0, this.touchChaos * 0.94 - 0.0005);

                this.gl.clear(this.gl.COLOR_BUFFER_BIT);

                // Set uniforms
                this.gl.uniform1f(this.uniforms.time, this.time);
                this.gl.uniform1f(this.uniforms.dimension, this.params.dimension);
                this.gl.uniform1f(this.uniforms.morphFactor, this.params.morphFactor);
                this.gl.uniform1f(this.uniforms.glitchIntensity, this.params.glitchIntensity);
                this.gl.uniform1f(this.uniforms.rotationSpeed, this.params.rotationSpeed);
                this.gl.uniform1f(this.uniforms.gridDensity, this.params.gridDensity);
                this.gl.uniform1f(this.uniforms.moireScale, this.params.moireScale);
                this.gl.uniform1f(this.uniforms.colorShift, this.params.colorShift);
                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform2f(this.uniforms.mouse, this.mouseX, this.mouseY);
                this.gl.uniform1f(this.uniforms.touchIntensity, this.touchIntensity);
                this.gl.uniform2f(this.uniforms.touchPoint, this.touchPoint.x, this.touchPoint.y);
                this.gl.uniform1f(this.uniforms.touchChaos, this.touchChaos);

                this.phasePulse = Math.max(0.0, this.phasePulse * 0.95 - 0.0008);
                this.scrollMomentum = Math.max(0.0, this.scrollMomentum * 0.9 - 0.0005);
                const phaseFlux = Math.min(1.5, this.phasePulse + this.scrollMomentum * 0.6 + this.touchChaos * 0.25);
                this.gl.uniform1f(this.uniforms.sceneMode, this.params.sceneMode || 0);
                this.gl.uniform1f(this.uniforms.phasePulse, phaseFlux);
                this.gl.uniform1f(this.uniforms.phaseVariant, this.phaseVariant);

                // Audio uniforms
                this.gl.uniform1f(this.uniforms.audioEnabled, this.audioEnabled ? 1.0 : 0.0);
                this.gl.uniform1f(this.uniforms.bassLevel, this.audioData.bass);
                this.gl.uniform1f(this.uniforms.midLevel, this.audioData.mid);
                this.gl.uniform1f(this.uniforms.highLevel, this.audioData.high);
                this.gl.uniform1f(this.uniforms.pitchFactor, this.audioData.pitch);
                
                // Draw
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
            
            animate() {
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize
        const mvepVisualizer = new MVEPMoireHypercube();
        window.mvepVisualizer = mvepVisualizer;

        // Add touch reactions for mobile
        function setupTouchReactions() {
            const rippleStyleId = 'mvep-touch-ripple-style';
            if (!document.getElementById(rippleStyleId)) {
                const rippleStyle = document.createElement('style');
                rippleStyle.id = rippleStyleId;
                rippleStyle.textContent = `
                    @keyframes mvepTouchRipple {
                        0% { transform: scale(0.4); opacity: 0.9; }
                        100% { transform: scale(3.2); opacity: 0; }
                    }

                    .mvep-touch-ripple {
                        position: absolute;
                        width: 70px;
                        height: 70px;
                        border-radius: 50%;
                        border: 2px solid rgba(0, 255, 255, 0.8);
                        pointer-events: none;
                        animation: mvepTouchRipple 0.7s ease-out forwards;
                        box-shadow: 0 0 18px rgba(255, 0, 255, 0.4);
                    }
                `;
                document.head.appendChild(rippleStyle);
            }

            const overlayId = 'mvep-touch-overlay';
            let overlay = document.getElementById(overlayId);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1200;
                `;
                document.body.appendChild(overlay);
            }

            const statusEl = document.getElementById('status');

            const spawnRipple = (clientX, clientY, scale = 1) => {
                const ripple = document.createElement('div');
                ripple.className = 'mvep-touch-ripple';
                ripple.style.left = `${clientX - 35}px`;
                ripple.style.top = `${clientY - 35}px`;
                ripple.style.transform = `scale(${Math.max(0.6, scale)})`;
                overlay.appendChild(ripple);
                setTimeout(() => ripple.remove(), 700);
            };

            const updateTouchState = (clientX, clientY, intensity) => {
                if (!mvepVisualizer) return;
                const normX = clientX / window.innerWidth;
                const normY = 1.0 - (clientY / window.innerHeight);

                mvepVisualizer.mouseX = normX;
                mvepVisualizer.mouseY = normY;
                mvepVisualizer.touchPoint = { x: normX, y: normY };
                mvepVisualizer.touchIntensity = Math.min(1.0, Math.max(mvepVisualizer.touchIntensity, intensity));
                mvepVisualizer.touchChaos = Math.min(1.0, mvepVisualizer.touchChaos + intensity * 0.25);

                if (statusEl) {
                    statusEl.textContent = 'MVEP 4D Hypercube ‚Äì Touch drive active';
                }
            };

            const updateChaosFromTouches = (touches) => {
                if (!mvepVisualizer || touches.length < 2) return;
                const touch1 = touches[0];
                const touch2 = touches[1];
                const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const normalized = Math.min(1, distance / 240);
                mvepVisualizer.touchChaos = Math.min(1.0, mvepVisualizer.touchChaos + normalized * 0.4);
            };

            document.addEventListener('touchstart', (e) => {
                if (!mvepVisualizer) return;
                if (e.target && e.target.closest('.controls')) return;
                const primary = e.touches[0];
                updateTouchState(primary.clientX, primary.clientY, 1.0);
                spawnRipple(primary.clientX, primary.clientY, 1);
                updateChaosFromTouches(e.touches);
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!mvepVisualizer) return;
                if (e.target && e.target.closest('.controls')) return;
                const primary = e.touches[0];
                updateTouchState(primary.clientX, primary.clientY, 0.8);
                updateChaosFromTouches(e.touches);
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!mvepVisualizer) return;
                if (e.touches.length === 0) {
                    mvepVisualizer.touchIntensity *= 0.4;
                    if (statusEl) {
                        statusEl.textContent = 'MVEP 4D Hypercube - Mouse: Move | Scroll: Grid/Color | Audio: ' + (mvepVisualizer.audioEnabled ? 'LIVE' : 'OFF');
                    }
                }
            });
        }
        
        // Initialize touch reactions when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupTouchReactions);
        } else {
            setupTouchReactions();
        }
    </script>
    
    <!-- Add collapsible menu system -->
    <script>
        window.COLLAPSIBLE_MENU_CONFIG = {
            startCollapsed: true,
            position: 'top-right',
            theme: 'dark'
        };
    </script>
    <script src="../js/inject-collapsible-menu.js"></script>
</body>
</html>