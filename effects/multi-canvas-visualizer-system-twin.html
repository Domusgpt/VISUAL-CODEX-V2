<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Canvas Visualizer â€“ Rift Twin</title>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(circle at 70% 18%, #140015 0%, #050005 40%, #010103 100%);
            font-family: 'JetBrains Mono', 'Orbitron', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .rift-system {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px 28px;
            gap: 10px;
        }

        .rift-strip {
            position: relative;
            flex: 1;
            border-radius: 20px;
            background: linear-gradient(145deg, rgba(6, 1, 18, 0.92), rgba(31, 4, 35, 0.82));
            overflow: hidden;
            box-shadow:
                inset 0 0 60px rgba(114, 8, 124, 0.5),
                0 0 120px rgba(214, 0, 255, 0.25);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .rift-strip::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(circle at 50% 50%, rgba(255, 200, 255, 0.12), transparent 60%);
            mix-blend-mode: screen;
        }
    </style>
</head>
<body>
    <div class="rift-system">
        <div class="rift-strip"><canvas id="rift-strip-0"></canvas></div>
        <div class="rift-strip"><canvas id="rift-strip-1"></canvas></div>
        <div class="rift-strip"><canvas id="rift-strip-2"></canvas></div>
        <div class="rift-strip"><canvas id="rift-strip-3"></canvas></div>
        <div class="rift-strip"><canvas id="rift-strip-4"></canvas></div>
    </div>

    <script>
        class RiftCascadeConductor {
            constructor() {
                this.strips = Array.from({ length: 5 }, (_, index) => {
                    const canvas = document.getElementById(`rift-strip-${index}`);
                    const ctx = canvas.getContext('2d');
                    return {
                        canvas,
                        ctx,
                        fractures: [],
                        streams: [],
                        embers: [],
                        shivers: this.createNoiseField(index * 4 + 2)
                    };
                });

                this.phases = [
                    {
                        name: 'Shatter Bloom',
                        palette: ['#ff3f8e', '#ff9d3d', '#fffcf0'],
                        fractureDepth: 0.46,
                        streamWeight: 0.75,
                        emberDensity: 54,
                        shiverScale: 0.32
                    },
                    {
                        name: 'Abyss Echo',
                        palette: ['#4f8dff', '#0affd2', '#ffffff'],
                        fractureDepth: 0.58,
                        streamWeight: 1.1,
                        emberDensity: 66,
                        shiverScale: 0.44
                    },
                    {
                        name: 'Crimson Rift',
                        palette: ['#ff4b5a', '#ff004f', '#ffcd7b'],
                        fractureDepth: 0.72,
                        streamWeight: 1.3,
                        emberDensity: 72,
                        shiverScale: 0.38
                    },
                    {
                        name: 'Ion Requiem',
                        palette: ['#f2f8ff', '#7cc9ff', '#ad57ff'],
                        fractureDepth: 0.5,
                        streamWeight: 0.9,
                        emberDensity: 60,
                        shiverScale: 0.48
                    }
                ];

                this.phaseIndex = 0;
                this.phaseDuration = 17000;
                this.phaseTimer = 0;
                this.lastTimestamp = performance.now();

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.seedPhase(true);
                requestAnimationFrame((timestamp) => this.tick(timestamp));
            }

            resize() {
                const height = (window.innerHeight - 4 * 10 - 40) / 5;
                this.strips.forEach(({ canvas }) => {
                    canvas.width = window.innerWidth - 56;
                    canvas.height = Math.max(height, 120);
                });
            }

            createNoiseField(seed) {
                const field = [];
                let value = seed * 213 + 97;
                for (let i = 0; i < 256; i++) {
                    value = (value * 48271) % 2147483647;
                    field.push(value / 2147483647);
                }
                return field;
            }

            sampleNoise(field, x) {
                const index = Math.floor(x) % field.length;
                const next = (index + 1) % field.length;
                const frac = x - Math.floor(x);
                return field[index] * (1 - frac) + field[next] * frac;
            }

            seedPhase(initial = false) {
                const phase = this.phases[this.phaseIndex];
                this.strips.forEach((strip, index) => this.seedStrip(strip, phase, index, initial));
            }

            seedStrip(strip, phase, index, initial) {
                const { canvas } = strip;
                const fractureCount = Math.floor(6 + Math.random() * 4);
                const streamCount = Math.floor(5 + Math.random() * 5);
                const emberCount = Math.floor(phase.emberDensity);
                const hueShift = (index / this.strips.length) * Math.PI * 1.2;

                strip.fractures = Array.from({ length: fractureCount }, () => this.createFracture(canvas, phase, hueShift));
                strip.streams = Array.from({ length: streamCount }, (_, streamIndex) => this.createStream(canvas, phase, hueShift, streamIndex));
                strip.embers = Array.from({ length: emberCount }, () => this.createEmber(canvas, phase, hueShift));

                if (initial) {
                    strip.embers.forEach(ember => ember.life = Math.random() * ember.maxLife);
                }
            }

            createFracture(canvas, phase, hueShift) {
                const segments = 6 + Math.floor(Math.random() * 6);
                const path = [];
                for (let i = 0; i < segments; i++) {
                    const x = (i / (segments - 1)) * canvas.width;
                    const offset = (Math.random() - 0.5) * canvas.height * phase.fractureDepth;
                    const y = canvas.height * 0.5 + offset;
                    path.push({ x, y });
                }
                return {
                    path,
                    hueShift,
                    thickness: 1.5 + Math.random() * 3.5,
                    flicker: Math.random() * Math.PI * 2,
                    tremor: 8 + Math.random() * 12,
                    color: phase.palette[Math.floor(Math.random() * phase.palette.length)]
                };
            }

            createStream(canvas, phase, hueShift, streamIndex) {
                return {
                    x: Math.random() * canvas.width,
                    baseY: canvas.height * (0.2 + Math.random() * 0.6),
                    amplitude: canvas.height * (0.25 + Math.random() * 0.35),
                    waveSpeed: 0.6 + Math.random() * 0.6,
                    drift: (Math.random() - 0.5) * 0.4,
                    width: 12 + Math.random() * 32,
                    paletteIndex: streamIndex % phase.palette.length,
                    hueShift,
                    ripple: Math.random() * Math.PI * 2
                };
            }

            createEmber(canvas, phase, hueShift) {
                return {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.6,
                    vy: -0.3 - Math.random() * 0.7,
                    radius: 1.2 + Math.random() * 3.6,
                    life: 0,
                    maxLife: 1.2 + Math.random() * 1.8,
                    hueShift,
                    color: phase.palette[Math.floor(Math.random() * phase.palette.length)]
                };
            }

            tick(timestamp) {
                const delta = timestamp - this.lastTimestamp;
                this.lastTimestamp = timestamp;
                this.phaseTimer += delta;

                if (this.phaseTimer >= this.phaseDuration) {
                    this.phaseTimer = 0;
                    this.phaseIndex = (this.phaseIndex + 1) % this.phases.length;
                    this.seedPhase();
                }

                const progress = this.phaseTimer / this.phaseDuration;
                this.strips.forEach((strip, index) => this.updateStrip(strip, this.phases[this.phaseIndex], delta / 1000, progress, index));

                requestAnimationFrame((next) => this.tick(next));
            }

            updateStrip(strip, phase, deltaSeconds, phaseProgress, stripIndex) {
                const { canvas, ctx } = strip;
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = `rgba(5, 1, 10, ${0.32 + phase.fractureDepth * 0.2})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.globalCompositeOperation = 'lighter';
                this.drawFractures(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex);
                this.drawStreams(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex);
                this.drawEmbers(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex);
                this.drawAsh(ctx, canvas, phase, phaseProgress, stripIndex);
            }

            drawFractures(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex) {
                const { fractures, shivers } = strip;
                fractures.forEach(fracture => {
                    fracture.flicker += deltaSeconds * 2.6;
                    ctx.beginPath();
                    const color = this.shiftColor(fracture.color, fracture.hueShift + phaseProgress * Math.PI * 1.4 + stripIndex * 0.4);
                    ctx.strokeStyle = this.mixColor(color, 0.28 + Math.sin(fracture.flicker) * 0.38);
                    ctx.lineWidth = fracture.thickness * (1 + Math.sin(fracture.flicker * 1.6) * 0.4);

                    fracture.path.forEach((point, idx) => {
                        const noise = this.sampleNoise(shivers, idx * 4 + fracture.flicker * 18);
                        const wobble = (noise - 0.5) * fracture.tremor * (0.8 + phaseProgress * 1.4);
                        const y = point.y + wobble;
                        const x = point.x + Math.sin(fracture.flicker + idx * 0.6) * 6 * (phaseProgress + 0.2);
                        if (idx === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });

                    ctx.stroke();
                });
            }

            drawStreams(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex) {
                const { canvas, streams, shivers } = strip;
                streams.forEach(stream => {
                    stream.x += stream.drift + Math.sin(phaseProgress * Math.PI * 2 + stream.ripple) * 0.8;
                    stream.ripple += deltaSeconds * (0.8 + phase.streamWeight * 0.6);

                    if (stream.x < -80) stream.x = canvas.width + 80;
                    if (stream.x > canvas.width + 80) stream.x = -80;

                    const color = this.shiftColor(phase.palette[stream.paletteIndex], stream.hueShift + phaseProgress * Math.PI * 2);
                    const width = stream.width * (0.5 + Math.sin(stream.ripple) * 0.25);
                    const gradient = ctx.createLinearGradient(stream.x - width * 0.8, 0, stream.x + width * 0.8, canvas.height);
                    gradient.addColorStop(0, this.mixColor(color, 0.05));
                    gradient.addColorStop(0.5, this.mixColor(color, 0.45 + phase.streamWeight * 0.25));
                    gradient.addColorStop(1, this.mixColor(color, 0.05));

                    ctx.lineWidth = Math.max(2.5, width * 0.4);
                    ctx.strokeStyle = gradient;
                    ctx.beginPath();
                    const segments = 48;
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const noise = this.sampleNoise(shivers, t * 48 + stream.ripple * 12 + stripIndex * 6);
                        const y = stream.baseY + Math.sin(t * Math.PI * 2 + stream.ripple) * stream.amplitude * (0.4 + phaseProgress * 0.8);
                        const offset = (noise - 0.5) * stream.amplitude * phase.shiverScale;
                        const x = stream.x + Math.sin(t * Math.PI * 1.6 + stream.ripple) * width;
                        if (i === 0) ctx.moveTo(x, y + offset);
                        else ctx.lineTo(x, y + offset);
                    }
                    ctx.stroke();

                    ctx.save();
                    ctx.shadowBlur = 24 + width * 0.6;
                    ctx.shadowColor = this.mixColor(color, 0.22 + phase.streamWeight * 0.18);
                    ctx.beginPath();
                    ctx.moveTo(stream.x, stream.baseY - stream.amplitude * 0.9);
                    ctx.lineTo(stream.x, stream.baseY + stream.amplitude * 0.9);
                    ctx.stroke();
                    ctx.restore();
                });
            }

            drawEmbers(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex) {
                const { canvas, embers, shivers } = strip;
                embers.forEach(ember => {
                    ember.life += deltaSeconds;
                    ember.x += ember.vx + Math.sin(ember.life * 6 + stripIndex) * 0.6;
                    ember.y += ember.vy * (0.8 + phaseProgress * 0.6);

                    const wobble = this.sampleNoise(shivers, ember.life * 28) - 0.5;
                    ember.x += wobble * 1.3;

                    if (ember.y < -40 || ember.life > ember.maxLife) {
                        ember.x = Math.random() * canvas.width;
                        ember.y = canvas.height + Math.random() * 40;
                        ember.life = 0;
                        ember.maxLife = 1.1 + Math.random() * 1.8;
                        ember.vx = (Math.random() - 0.5) * 0.8;
                        ember.vy = -0.5 - Math.random() * 0.8;
                        ember.color = phase.palette[Math.floor(Math.random() * phase.palette.length)];
                    }

                    const lifeRatio = 1 - ember.life / ember.maxLife;
                    const color = this.shiftColor(ember.color, ember.hueShift + phaseProgress * 4.2);
                    const radius = ember.radius * (1.4 + Math.sin(ember.life * Math.PI * 2) * 0.6);
                    const gradient = ctx.createRadialGradient(ember.x, ember.y, 0, ember.x, ember.y, radius * 3.2);
                    gradient.addColorStop(0, this.mixColor(color, 0.9 * lifeRatio));
                    gradient.addColorStop(0.4, this.mixColor(color, 0.35 * lifeRatio));
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(ember.x, ember.y, radius * 3.2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            drawAsh(ctx, canvas, phase, phaseProgress, stripIndex) {
                const flakes = 34;
                for (let i = 0; i < flakes; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const alpha = (0.12 + Math.random() * 0.18) * (1 + Math.sin((phaseProgress * 2 + stripIndex * 0.3) * Math.PI) * 0.5);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            shiftColor(hex, shift) {
                const rgb = this.hexToRgb(hex);
                const hsv = this.rgbToHsv(rgb.r, rgb.g, rgb.b);
                hsv.h = (hsv.h + shift / (Math.PI * 2)) % 1;
                const { r, g, b } = this.hsvToRgb(hsv.h, hsv.s, hsv.v);
                return `rgb(${r}, ${g}, ${b})`;
            }

            mixColor(color, alpha) {
                const matches = color.match(/rgb\((\d+), (\d+), (\d+)\)/);
                if (!matches) return `rgba(255, 255, 255, ${Math.min(alpha, 1)})`;
                const [, r, g, b] = matches.map(Number);
                return `rgba(${r}, ${g}, ${b}, ${Math.min(alpha, 1)})`;
            }

            hexToRgb(hex) {
                const normalized = hex.replace('#', '');
                const bigint = parseInt(normalized, 16);
                return {
                    r: (bigint >> 16) & 255,
                    g: (bigint >> 8) & 255,
                    b: bigint & 255
                };
            }

            rgbToHsv(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                const v = max;
                const s = max === 0 ? 0 : d / max;
                let h;
                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return { h, s, v };
            }

            hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0:
                        r = v; g = t; b = p;
                        break;
                    case 1:
                        r = q; g = v; b = p;
                        break;
                    case 2:
                        r = p; g = v; b = t;
                        break;
                    case 3:
                        r = p; g = q; b = v;
                        break;
                    case 4:
                        r = t; g = p; b = v;
                        break;
                    case 5:
                        r = v; g = p; b = q;
                        break;
                }

                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
        }

        window.addEventListener('DOMContentLoaded', () => new RiftCascadeConductor());
    </script>
</body>
</html>
