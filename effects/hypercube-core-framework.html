<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypercube Core Framework</title>
    <style>
        :root {
            color-scheme: dark;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            background: radial-gradient(circle at 50% 50%, #020611 0%, #01030a 40%, #000105 100%);
            overflow: hidden;
            font-family: "JetBrains Mono", "Fira Code", monospace;
            letter-spacing: 0.04em;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .backdrop-gradient {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background:
                radial-gradient(circle at 18% 22%, rgba(0, 247, 255, 0.08), transparent 42%),
                radial-gradient(circle at 76% 18%, rgba(148, 92, 255, 0.06), transparent 45%),
                radial-gradient(circle at 82% 76%, rgba(255, 64, 136, 0.08), transparent 40%),
                radial-gradient(circle at 12% 78%, rgba(0, 176, 255, 0.06), transparent 44%);
            filter: saturate(130%);
        }
    </style>
</head>
<body>
    <div class="backdrop-gradient"></div>
    <canvas id="coreCanvas"></canvas>
    <script>
        const canvas = document.getElementById('coreCanvas');
        const ctx = canvas.getContext('2d');

        const TAU = Math.PI * 2;
        const baseVertices = [];
        for (let x = -1; x <= 1; x += 2) {
            for (let y = -1; y <= 1; y += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    for (let w = -1; w <= 1; w += 2) {
                        baseVertices.push([x, y, z, w]);
                    }
                }
            }
        }

        const edges = [];
        for (let i = 0; i < baseVertices.length; i++) {
            for (let j = i + 1; j < baseVertices.length; j++) {
                const a = baseVertices[i];
                const b = baseVertices[j];
                let diff = 0;
                for (let k = 0; k < 4; k++) {
                    if (a[k] !== b[k]) diff++;
                }
                if (diff === 1) {
                    edges.push([i, j]);
                }
            }
        }

        const scenes = [
            {
                name: 'pulse-foundry',
                scale: 170,
                rotation: { xy: 0.22, xz: 0.13, xw: 0.17, yz: 0.19, yw: 0.11, zw: 0.07 },
                perspective4d: 2.7,
                depthWarp: 0.32,
                glow: 0.64,
                edgeOpacity: 0.85,
                nodeBloom: 1.4,
                palette: ['#00f5ff', '#3c7bff', '#b32bff'],
                pulseRate: 0.8,
                vortexStrength: 0.6
            },
            {
                name: 'axiom-weave',
                scale: 210,
                rotation: { xy: 0.31, xz: 0.06, xw: 0.22, yz: 0.14, yw: 0.08, zw: 0.25 },
                perspective4d: 3.4,
                depthWarp: 0.44,
                glow: 0.72,
                edgeOpacity: 0.72,
                nodeBloom: 1.1,
                palette: ['#7effd3', '#00c8ff', '#7440ff'],
                pulseRate: 1.1,
                vortexStrength: 0.35
            },
            {
                name: 'gravity-braid',
                scale: 195,
                rotation: { xy: 0.18, xz: 0.23, xw: 0.11, yz: 0.27, yw: 0.16, zw: 0.18 },
                perspective4d: 3.0,
                depthWarp: 0.58,
                glow: 0.82,
                edgeOpacity: 0.78,
                nodeBloom: 1.75,
                palette: ['#ff8ae6', '#ff4b7d', '#ffc94d'],
                pulseRate: 1.45,
                vortexStrength: 0.9
            }
        ];

        const rotations = ['xy', 'xz', 'xw', 'yz', 'yw', 'zw'];

        function rotate4D(point, angle, plane) {
            const [axisA, axisB] = plane.split('').map(axis => {
                switch (axis) {
                    case 'x': return 0;
                    case 'y': return 1;
                    case 'z': return 2;
                    case 'w': return 3;
                    default: return 0;
                }
            });
            const sin = Math.sin(angle);
            const cos = Math.cos(angle);
            const a = point[axisA];
            const b = point[axisB];
            point[axisA] = a * cos - b * sin;
            point[axisB] = a * sin + b * cos;
        }

        const projected = new Array(baseVertices.length).fill(null).map(() => ({ x: 0, y: 0, z: 0, depth: 0 }));

        function projectPoint(point, scene) {
            const warp = scene.depthWarp;
            const perspective = scene.perspective4d;
            const denom4d = perspective - point[3] * warp;
            const scale4d = 1 / Math.max(0.2, denom4d);
            const x3 = point[0] * scale4d;
            const y3 = point[1] * scale4d;
            const z3 = point[2] * scale4d;
            const camera = 1.7;
            const denom3d = camera - z3 * 0.55;
            const scale3d = scene.scale / Math.max(0.3, denom3d);
            return {
                x: x3 * scale3d,
                y: y3 * scale3d,
                z: z3,
                depth: denom4d
            };
        }

        class PulseNetwork {
            constructor() {
                this.pulses = [];
                this.spawnInterval = 400;
                this.lastSpawn = 0;
            }

            update(time, dt, scene) {
                if (time - this.lastSpawn > this.spawnInterval / scene.pulseRate) {
                    this.spawnPulse(scene);
                    this.lastSpawn = time;
                }
                for (const pulse of this.pulses) {
                    pulse.progress += dt * pulse.speed;
                    if (pulse.progress >= 1) pulse.dead = true;
                }
                this.pulses = this.pulses.filter(p => !p.dead);
            }

            spawnPulse(scene) {
                const edge = edges[Math.floor(Math.random() * edges.length)];
                const color = scene.palette[Math.floor(Math.random() * scene.palette.length)];
                this.pulses.push({
                    edge,
                    progress: 0,
                    speed: 0.18 + Math.random() * 0.22,
                    width: 1.4 + Math.random() * 1.8,
                    color
                });
            }

            draw(ctx, scene) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const pulse of this.pulses) {
                    const [aIndex, bIndex] = pulse.edge;
                    const a = projected[aIndex];
                    const b = projected[bIndex];
                    const x = a.x + (b.x - a.x) * pulse.progress;
                    const y = a.y + (b.y - a.y) * pulse.progress;
                    const width = pulse.width * (1 - Math.abs(0.5 - pulse.progress) * 1.4);
                    const grad = ctx.createRadialGradient(x, y, 0, x, y, 34);
                    grad.addColorStop(0, pulse.color + 'ff');
                    grad.addColorStop(1, pulse.color + '00');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.ellipse(x, y, width * 6, width * 6, 0, 0, TAU);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class NodeEmitter {
            constructor(count) {
                this.count = count;
                this.particles = new Array(count).fill(null).map(() => this.spawn());
            }

            spawn() {
                return {
                    index: Math.floor(Math.random() * baseVertices.length),
                    offset: Math.random(),
                    radius: 6 + Math.random() * 26,
                    speed: 0.4 + Math.random() * 0.6,
                    phase: Math.random() * TAU,
                    life: 0.2 + Math.random() * 0.8,
                    age: 0
                };
            }

            update(dt) {
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    p.age += dt * p.speed;
                    if (p.age > p.life) {
                        this.particles[i] = this.spawn();
                    }
                }
            }

            draw(ctx, scene) {
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                for (const particle of this.particles) {
                    const node = projected[particle.index];
                    const t = (particle.age / particle.life);
                    const radius = particle.radius * Math.sin(t * Math.PI);
                    const colorIndex = particle.index % scene.palette.length;
                    const color = scene.palette[colorIndex];
                    const alpha = 0.08 + 0.12 * (1 - t);
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = alpha;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, Math.max(4, radius), 0, TAU);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        class FluxBridge {
            constructor() {
                this.arcs = new Array(12).fill(null).map(() => this.spawn());
            }

            spawn() {
                const edge = edges[Math.floor(Math.random() * edges.length)];
                return {
                    edge,
                    offset: Math.random(),
                    amplitude: 0.1 + Math.random() * 0.5,
                    phase: Math.random() * TAU,
                    speed: 0.4 + Math.random() * 0.6
                };
            }

            update(dt, scene) {
                for (let i = 0; i < this.arcs.length; i++) {
                    const arc = this.arcs[i];
                    arc.phase += dt * scene.vortexStrength * arc.speed * 1.7;
                    arc.offset += dt * 0.2;
                    if (arc.offset > 1) {
                        this.arcs[i] = this.spawn();
                    }
                }
            }

            draw(ctx, scene) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const arc of this.arcs) {
                    const [aIndex, bIndex] = arc.edge;
                    const a = projected[aIndex];
                    const b = projected[bIndex];
                    const midX = (a.x + b.x) / 2;
                    const midY = (a.y + b.y) / 2;
                    const dx = b.x - a.x;
                    const dy = b.y - a.y;
                    const normalX = -dy;
                    const normalY = dx;
                    const magnitude = Math.sqrt(normalX * normalX + normalY * normalY) || 1;
                    const nX = normalX / magnitude;
                    const nY = normalY / magnitude;
                    const wave = Math.sin(arc.phase) * arc.amplitude;
                    const controlX = midX + nX * wave * 90;
                    const controlY = midY + nY * wave * 90;
                    const gradient = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
                    gradient.addColorStop(0, scene.palette[0] + '88');
                    gradient.addColorStop(0.5, scene.palette[1] + 'cc');
                    gradient.addColorStop(1, scene.palette[2] + '88');
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 1.1 + Math.sin(arc.phase) * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.quadraticCurveTo(controlX, controlY, b.x, b.y);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        class SceneDirector {
            constructor() {
                this.sceneIndex = 0;
                this.scene = scenes[0];
                this.lastSwitch = performance.now();
                this.duration = 16000;
            }

            update(time) {
                if (time - this.lastSwitch > this.duration) {
                    this.sceneIndex = (this.sceneIndex + 1) % scenes.length;
                    this.scene = scenes[this.sceneIndex];
                    this.lastSwitch = time;
                }
                return this.scene;
            }
        }

        const director = new SceneDirector();
        const pulseNetwork = new PulseNetwork();
        const emitter = new NodeEmitter(64);
        const bridges = new FluxBridge();

        let lastTime = performance.now();

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(window.innerWidth * dpr);
            canvas.height = Math.floor(window.innerHeight * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        resize();
        window.addEventListener('resize', resize);

        function render(now) {
            const dt = Math.min(1 / 15, (now - lastTime) / 1000);
            lastTime = now;

            const scene = director.update(now);
            pulseNetwork.update(now, dt, scene);
            emitter.update(dt);
            bridges.update(dt, scene);

            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 3, 12, 0.18)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            for (let i = 0; i < baseVertices.length; i++) {
                const point = baseVertices[i].slice();
                for (const plane of rotations) {
                    const speed = scene.rotation[plane] || 0;
                    rotate4D(point, now * 0.0005 * speed + i * 0.03, plane);
                }
                const projectedPoint = projectPoint(point, scene);
                projected[i].x = centerX + projectedPoint.x;
                projected[i].y = centerY + projectedPoint.y;
                projected[i].z = projectedPoint.z;
                projected[i].depth = projectedPoint.depth;
            }

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (const [aIndex, bIndex] of edges) {
                const a = projected[aIndex];
                const b = projected[bIndex];
                const gradient = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
                gradient.addColorStop(0, scene.palette[0] + '44');
                gradient.addColorStop(0.5, scene.palette[1] + 'bb');
                gradient.addColorStop(1, scene.palette[2] + '44');
                ctx.strokeStyle = gradient;
                const depthAlpha = 0.25 + 0.6 / (1 + Math.abs(a.z) + Math.abs(b.z));
                ctx.globalAlpha = depthAlpha * scene.edgeOpacity;
                ctx.lineWidth = 1.2 + scene.glow * 0.6;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
            }
            ctx.restore();

            bridges.draw(ctx, scene);
            pulseNetwork.draw(ctx, scene);

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < projected.length; i++) {
                const node = projected[i];
                const radius = 3.4 + (Math.sin(now * 0.0008 + i) + 1) * scene.nodeBloom;
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, radius * 4.2);
                gradient.addColorStop(0, scene.palette[i % scene.palette.length] + 'ff');
                gradient.addColorStop(0.5, scene.palette[(i + 1) % scene.palette.length] + '88');
                gradient.addColorStop(1, scene.palette[(i + 2) % scene.palette.length] + '00');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, TAU);
                ctx.fill();
            }
            ctx.restore();

            emitter.draw(ctx, scene);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
