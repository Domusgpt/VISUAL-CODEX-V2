<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Canvas Visualizer System</title>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: radial-gradient(circle at 30% 20%, #130029 0%, #030007 42%, #000000 100%);
            color: #fff;
            font-family: 'JetBrains Mono', 'Orbitron', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .system-root {
            display: flex;
            flex-direction: column;
            gap: 6px;
            height: 100vh;
            padding: 16px 24px;
        }

        .strip {
            position: relative;
            flex: 1;
            border-radius: 18px;
            overflow: hidden;
            background: linear-gradient(135deg, rgba(8, 12, 35, 0.94), rgba(2, 0, 10, 0.86));
            box-shadow:
                inset 0 0 60px rgba(12, 14, 45, 0.9),
                0 0 80px rgba(16, 0, 56, 0.45);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .strip::after {
            content: '';
            pointer-events: none;
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 50%, rgba(180, 220, 255, 0.07), transparent 58%);
            mix-blend-mode: screen;
        }
    </style>
</head>
<body>
    <div class="system-root">
        <div class="strip"><canvas id="strip-0"></canvas></div>
        <div class="strip"><canvas id="strip-1"></canvas></div>
        <div class="strip"><canvas id="strip-2"></canvas></div>
        <div class="strip"><canvas id="strip-3"></canvas></div>
        <div class="strip"><canvas id="strip-4"></canvas></div>
    </div>

    <script>
        class MultiCanvasConductor {
            constructor() {
                this.strips = Array.from({ length: 5 }, (_, index) => {
                    const canvas = document.getElementById(`strip-${index}`);
                    const ctx = canvas.getContext('2d');
                    return {
                        canvas,
                        ctx,
                        ribbons: [],
                        nodes: [],
                        pulses: [],
                        noiseField: this.createNoiseField(index)
                    };
                });

                this.phases = [
                    {
                        name: 'Lattice Bloom',
                        palette: ['#0aefff', '#19ff6b', '#f7f9ff'],
                        ribbonWidth: 42,
                        waveLift: 0.16,
                        density: 38,
                        pulseStrength: 0.7,
                        noiseInfluence: 0.45
                    },
                    {
                        name: 'Flux Mirage',
                        palette: ['#ff5ef4', '#ffd300', '#57efff'],
                        ribbonWidth: 54,
                        waveLift: 0.23,
                        density: 48,
                        pulseStrength: 1.2,
                        noiseInfluence: 0.32
                    },
                    {
                        name: 'Cryo Veil',
                        palette: ['#5e8bff', '#a7e1ff', '#00ffe6'],
                        ribbonWidth: 36,
                        waveLift: 0.12,
                        density: 44,
                        pulseStrength: 0.9,
                        noiseInfluence: 0.55
                    },
                    {
                        name: 'Solar Thread',
                        palette: ['#ff926b', '#ffe46b', '#fff8d9'],
                        ribbonWidth: 40,
                        waveLift: 0.18,
                        density: 52,
                        pulseStrength: 1.35,
                        noiseInfluence: 0.41
                    }
                ];

                this.phaseIndex = 0;
                this.phaseDuration = 16000;
                this.phaseTimer = 0;
                this.lastTimestamp = performance.now();

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.seedPhase(true);
                requestAnimationFrame((timestamp) => this.tick(timestamp));
            }

            resize() {
                const height = (window.innerHeight - 5 * 6 - 32) / 5;
                this.strips.forEach(({ canvas }) => {
                    canvas.width = window.innerWidth - 48;
                    canvas.height = Math.max(height, 120);
                });
            }

            createNoiseField(seed) {
                const noise = [];
                const length = 256;
                let value = seed * 97;
                for (let i = 0; i < length; i++) {
                    value = (value * 16807) % 2147483647;
                    noise.push(value / 2147483647);
                }
                return noise;
            }

            sampleNoise(noise, x) {
                const index = Math.floor(x) % noise.length;
                const next = (index + 1) % noise.length;
                const fract = x - Math.floor(x);
                return noise[index] * (1 - fract) + noise[next] * fract;
            }

            seedPhase(initial = false) {
                const phase = this.phases[this.phaseIndex];
                this.strips.forEach((strip, index) => {
                    this.seedStrip(strip, phase, index, initial);
                });
            }

            seedStrip(strip, phase, index, initial) {
                const { canvas } = strip;
                const baseHueShift = (index / this.strips.length) * Math.PI * 2;
                const ribbonCount = Math.floor(4 + Math.random() * 3);
                const nodeCount = Math.floor(phase.density * 0.6);
                const pulseCount = Math.floor(phase.density * 0.22);

                strip.ribbons = Array.from({ length: ribbonCount }, (_, ribbonIndex) => this.createRibbon(canvas, phase, baseHueShift, ribbonIndex));
                strip.nodes = Array.from({ length: nodeCount }, () => this.createNode(canvas, phase, baseHueShift));
                strip.pulses = Array.from({ length: pulseCount }, () => this.createPulse(canvas, phase));

                if (initial) {
                    strip.nodes.forEach(node => node.energy = Math.random());
                }
            }

            createRibbon(canvas, phase, hueShift, ribbonIndex) {
                const direction = Math.random() > 0.5 ? 1 : -1;
                const baseline = canvas.height * (0.2 + Math.random() * 0.6);
                const amplitude = canvas.height * (0.2 + Math.random() * 0.35);
                const speed = (0.8 + Math.random() * 0.7) * direction;
                const offset = Math.random() * Math.PI * 2;
                const paletteIndex = ribbonIndex % phase.palette.length;

                return {
                    baseline,
                    amplitude,
                    speed,
                    offset,
                    width: phase.ribbonWidth * (0.6 + Math.random() * 0.8),
                    color: phase.palette[paletteIndex],
                    hueShift
                };
            }

            createNode(canvas, phase, hueShift) {
                return {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.4,
                    vy: (Math.random() - 0.5) * 0.4,
                    radius: 2 + Math.random() * 4,
                    energy: 0,
                    hueShift,
                    color: phase.palette[Math.floor(Math.random() * phase.palette.length)]
                };
            }

            createPulse(canvas, phase) {
                return {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 12 + Math.random() * 28,
                    growth: 0.65 + Math.random() * 0.6,
                    life: 0,
                    maxLife: 1.6 + Math.random() * 1.2,
                    color: phase.palette[Math.floor(Math.random() * phase.palette.length)],
                    direction: Math.random() > 0.5 ? 1 : -1
                };
            }

            tick(timestamp) {
                const delta = timestamp - this.lastTimestamp;
                this.lastTimestamp = timestamp;
                this.phaseTimer += delta;

                if (this.phaseTimer >= this.phaseDuration) {
                    this.phaseTimer = 0;
                    this.phaseIndex = (this.phaseIndex + 1) % this.phases.length;
                    this.seedPhase();
                }

                const progress = this.phaseTimer / this.phaseDuration;
                this.strips.forEach((strip, index) => this.updateStrip(strip, this.phases[this.phaseIndex], delta / 1000, progress, index));

                requestAnimationFrame((nextTimestamp) => this.tick(nextTimestamp));
            }

            updateStrip(strip, phase, deltaSeconds, phaseProgress, stripIndex) {
                const { canvas, ctx } = strip;
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = `rgba(4, 6, 18, ${0.16 + phase.noiseInfluence * 0.3})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.globalCompositeOperation = 'lighter';
                this.drawRibbons(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex);
                this.drawNodes(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex);
                this.drawPulses(strip, ctx, phase, deltaSeconds);
                this.injectDust(ctx, canvas, phase, stripIndex, phaseProgress);
            }

            drawRibbons(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex) {
                const { canvas, ribbons, noiseField } = strip;
                const width = canvas.width;
                const height = canvas.height;
                const waveLift = phase.waveLift + phaseProgress * 0.12;

                ribbons.forEach(ribbon => {
                    ribbon.offset += ribbon.speed * deltaSeconds;

                    ctx.beginPath();
                    const segments = 140;
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const x = t * width;
                        const noise = this.sampleNoise(noiseField, (t * 32) + ribbon.offset * 0.5 + stripIndex * 12);
                        const y = ribbon.baseline + Math.sin(t * Math.PI * 2 + ribbon.offset) * ribbon.amplitude * waveLift + (noise - 0.5) * ribbon.amplitude * phase.noiseInfluence;
                        const intensity = 0.32 + Math.pow(Math.sin((t + phaseProgress) * Math.PI), 3) * 0.68;

                        const color = this.shiftColor(ribbon.color, ribbon.hueShift + phaseProgress * Math.PI * 2);
                        ctx.strokeStyle = this.mixColor(color, intensity);
                        ctx.lineWidth = ribbon.width * (0.2 + intensity * 0.8);

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }

                    ctx.stroke();
                });
            }

            drawNodes(strip, ctx, phase, deltaSeconds, phaseProgress, stripIndex) {
                const { canvas, nodes, noiseField } = strip;
                nodes.forEach(node => {
                    node.x += node.vx * (1 + phaseProgress * 1.4);
                    node.y += node.vy * (1 + phaseProgress * 1.4);

                    const drift = this.sampleNoise(noiseField, (node.x + node.y) * 0.04 + phaseProgress * 32);
                    node.x += (drift - 0.5) * 0.9;
                    node.y += (0.5 - drift) * 0.9;

                    if (node.x < -20) node.x = canvas.width + 20;
                    if (node.x > canvas.width + 20) node.x = -20;
                    if (node.y < -20) node.y = canvas.height + 20;
                    if (node.y > canvas.height + 20) node.y = -20;

                    node.energy += deltaSeconds * (0.4 + phase.pulseStrength * 0.4);
                    if (node.energy > 1) node.energy -= 1;

                    const color = this.shiftColor(node.color, node.hueShift + phaseProgress * 6.28 + node.energy * 0.8);
                    const glow = 0.35 + Math.sin(node.energy * Math.PI * 2) * 0.5;

                    ctx.beginPath();
                    const radius = node.radius * (1.3 + glow * 1.8);
                    const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, radius * 2.6);
                    gradient.addColorStop(0, this.mixColor(color, 0.8));
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.arc(node.x, node.y, radius * 2.6, 0, Math.PI * 2);
                    ctx.fill();
                });

                for (let i = 0; i < nodes.length; i++) {
                    const a = nodes[i];
                    for (let j = i + 1; j < Math.min(i + 12, nodes.length); j++) {
                        const b = nodes[(j + stripIndex) % nodes.length];
                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < 180) {
                            const alpha = (1 - dist / 180) * 0.5;
                            ctx.strokeStyle = this.mixColor(this.shiftColor(a.color, phaseProgress * 2), alpha);
                            ctx.lineWidth = 1.1 + alpha * 2;
                            ctx.beginPath();
                            ctx.moveTo(a.x, a.y);
                            ctx.lineTo(b.x, b.y);
                            ctx.stroke();
                        }
                    }
                }
            }

            drawPulses(strip, ctx, phase, deltaSeconds) {
                strip.pulses.forEach(pulse => {
                    pulse.life += deltaSeconds;
                    pulse.radius += pulse.growth * 26 * deltaSeconds * pulse.direction;

                    if (pulse.life >= pulse.maxLife) {
                        pulse.x = Math.random() * strip.canvas.width;
                        pulse.y = Math.random() * strip.canvas.height;
                        pulse.radius = 12 + Math.random() * 32;
                        pulse.life = 0;
                        pulse.maxLife = 1.3 + Math.random() * 1.6;
                        pulse.direction = Math.random() > 0.5 ? 1 : -1;
                        pulse.color = phase.palette[Math.floor(Math.random() * phase.palette.length)];
                    }

                    const alpha = 1 - pulse.life / pulse.maxLife;
                    ctx.beginPath();
                    ctx.strokeStyle = this.mixColor(pulse.color, 0.25 + alpha * phase.pulseStrength * 0.8);
                    ctx.lineWidth = 1.6 + phase.pulseStrength * 1.8;
                    ctx.arc(pulse.x, pulse.y, Math.abs(pulse.radius), 0, Math.PI * 2);
                    ctx.stroke();
                });
            }

            injectDust(ctx, canvas, phase, stripIndex, phaseProgress) {
                const dustCount = 28;
                for (let i = 0; i < dustCount; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const alpha = (0.18 + Math.random() * 0.2) * (1 + Math.sin((phaseProgress + stripIndex * 0.07) * Math.PI * 2) * 0.5);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            shiftColor(hex, shift) {
                const rgb = this.hexToRgb(hex);
                const hsv = this.rgbToHsv(rgb.r, rgb.g, rgb.b);
                hsv.h = (hsv.h + shift / (Math.PI * 2)) % 1;
                const { r, g, b } = this.hsvToRgb(hsv.h, hsv.s, hsv.v);
                return `rgb(${r}, ${g}, ${b})`;
            }

            mixColor(color, alpha) {
                const matches = color.match(/rgb\((\d+), (\d+), (\d+)\)/);
                if (!matches) return `rgba(255, 255, 255, ${Math.min(alpha, 1)})`;
                const [, r, g, b] = matches.map(Number);
                return `rgba(${r}, ${g}, ${b}, ${Math.min(alpha, 1)})`;
            }

            hexToRgb(hex) {
                const normalized = hex.replace('#', '');
                const bigint = parseInt(normalized, 16);
                return {
                    r: (bigint >> 16) & 255,
                    g: (bigint >> 8) & 255,
                    b: bigint & 255
                };
            }

            rgbToHsv(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                const v = max;
                const s = max === 0 ? 0 : d / max;
                let h;
                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return { h, s, v };
            }

            hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0:
                        r = v; g = t; b = p;
                        break;
                    case 1:
                        r = q; g = v; b = p;
                        break;
                    case 2:
                        r = p; g = v; b = t;
                        break;
                    case 3:
                        r = p; g = q; b = v;
                        break;
                    case 4:
                        r = t; g = p; b = v;
                        break;
                    case 5:
                        r = v; g = p; b = q;
                        break;
                }

                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
        }

        window.addEventListener('DOMContentLoaded', () => new MultiCanvasConductor());
    </script>
</body>
</html>
