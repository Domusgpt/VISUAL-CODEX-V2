<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Holographic Visualizer Demo - Visual Codex</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0A0A0B;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      overflow: hidden;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .controls {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
    }

    .control-btn {
      padding: 12px 24px;
      background: rgba(15, 15, 17, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
    }

    .control-btn:hover {
      background: rgba(123,63,242,0.3);
      border-color: #7B3FF2;
    }

    .control-btn.active {
      background: rgba(123,63,242,0.5);
      border-color: #7B3FF2;
    }

    .title {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      background: linear-gradient(135deg, #7B3FF2, #4FC3F7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      z-index: 100;
      text-align: center;
    }

    .subtitle {
      position: fixed;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: rgba(255,255,255,0.5);
      z-index: 100;
    }

    .impulse-indicator {
      position: fixed;
      top: 40px;
      right: 40px;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(123,63,242,0.3) 0%, transparent 70%);
      opacity: 0;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="holo"></canvas>

  <h1 class="title">Holographic Visualizer</h1>
  <p class="subtitle">Click anywhere or use buttons below. Patterns 18, 19, 20</p>

  <div class="impulse-indicator" id="impulse"></div>

  <div class="controls">
    <button class="control-btn active" onclick="setGeometry(0)">Tetra</button>
    <button class="control-btn" onclick="setGeometry(1)">Box</button>
    <button class="control-btn" onclick="setGeometry(2)">Sponge</button>
    <button class="control-btn" onclick="triggerImpulse()">Impulse</button>
  </div>

  <script>
    const canvas = document.getElementById('holo');
    const gl = canvas.getContext('webgl2');
    const impulseEl = document.getElementById('impulse');

    // Holographic Parameters
    const params = {
      geometryType: 0,
      density: 2.5,      // High = fog, clears on interaction
      chaos: 0.3,
      morph: 0.0,
      hue: 0.5,
      saturation: 0.6,
      intensity: 0.7,
      impulse: 0,
      time: 0
    };

    const targetParams = { ...params };

    // Shaders
    const vertexSource = `#version 300 es
      in vec2 position;
      void main() { gl_Position = vec4(position, 0.0, 1.0); }
    `;

    const fragmentSource = `#version 300 es
      precision highp float;
      uniform vec2 resolution;
      uniform float time;
      uniform int geometryType;
      uniform float density;
      uniform float chaos;
      uniform float hue;
      uniform float intensity;
      uniform float impulse;
      out vec4 fragColor;

      vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
      }

      vec3 fold(vec3 p, int type) {
        p = abs(p);
        if (type == 0) {
          if (p.x + p.y < 0.0) p.xy = -p.yx;
          if (p.x + p.z < 0.0) p.xz = -p.zx;
          if (p.y + p.z < 0.0) p.yz = -p.zy;
        } else if (type == 1) {
          p = clamp(p, -1.0, 1.0) * 2.0 - p;
        } else {
          float c = 3.0;
          p = mod(p + c/2.0, c) - c/2.0;
        }
        return p;
      }

      float DE(vec3 p, int type) {
        float scale = 2.0;
        float offset = 1.0 + chaos * 0.5;
        for (int i = 0; i < 6; i++) {
          p = fold(p, type);
          p = p * scale - offset * (scale - 1.0);
        }
        return length(p) * pow(scale, -6.0);
      }

      float raymarch(vec3 ro, vec3 rd, int type) {
        float t = 0.0;
        for (int i = 0; i < 48; i++) {
          vec3 p = ro + rd * t;
          float d = DE(p, type);
          if (d < 0.002 || t > 15.0) break;
          t += d;
        }
        return t;
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy - resolution * 0.5) / resolution.y;

        vec3 ro = vec3(0.0, 0.0, -3.0 + sin(time * 0.3) * 0.5);
        vec3 rd = normalize(vec3(uv, 1.0));

        float a = time * 0.15;
        mat2 rot = mat2(cos(a), -sin(a), sin(a), cos(a));
        rd.xz *= rot;
        ro.xz *= rot;

        float t = raymarch(ro, rd, geometryType);

        // INVERSE DENSITY: high density = more fog = less visible
        // On impulse, density drops, revealing geometry
        float effectiveDensity = density - impulse * 2.0;
        effectiveDensity = max(effectiveDensity, 0.3);

        float fog = 1.0 - exp(-t * effectiveDensity * 0.1);
        float glow = 1.0 / (1.0 + t * t * 0.15);

        // Boost intensity on impulse
        float effectiveIntensity = intensity + impulse * 0.5;

        vec3 color = hsv2rgb(vec3(
          hue + glow * 0.1 + impulse * 0.1,
          0.7 - impulse * 0.2,
          effectiveIntensity * glow
        ));

        color = mix(color, vec3(0.02, 0.02, 0.03), fog);
        color *= 1.0 - length(uv) * 0.4;

        fragColor = vec4(color, 1.0);
      }
    `;

    // Setup
    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      return shader;
    }

    const program = gl.createProgram();
    gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vertexSource));
    gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fragmentSource));
    gl.linkProgram(program);
    gl.useProgram(program);

    const vertices = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const uniforms = {};
    ['resolution', 'time', 'geometryType', 'density', 'chaos', 'hue', 'intensity', 'impulse']
      .forEach(name => uniforms[name] = gl.getUniformLocation(program, name));

    function resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    resize();
    window.addEventListener('resize', resize);

    // Impulse system
    function triggerImpulse() {
      targetParams.impulse = 1.0;
      gsap.to(impulseEl, { opacity: 1, scale: 1.5, duration: 0.1 });
      gsap.to(impulseEl, { opacity: 0, scale: 1, duration: 0.5, delay: 0.1 });
    }

    // Click anywhere triggers impulse
    document.addEventListener('click', (e) => {
      if (!e.target.classList.contains('control-btn')) {
        triggerImpulse();
      }
    });

    // Mouse movement affects hue
    document.addEventListener('mousemove', (e) => {
      targetParams.hue = e.clientX / window.innerWidth;
    });

    function setGeometry(type) {
      targetParams.geometryType = type;
      document.querySelectorAll('.control-btn').forEach((btn, i) => {
        btn.classList.toggle('active', i === type);
      });
    }

    // Render
    function render() {
      params.time += 0.016;

      // Lerp parameters
      ['geometryType', 'density', 'chaos', 'hue', 'intensity'].forEach(key => {
        params[key] += (targetParams[key] - params[key]) * 0.05;
      });

      // Decay impulse
      params.impulse = targetParams.impulse;
      targetParams.impulse *= 0.95;
      if (targetParams.impulse < 0.01) targetParams.impulse = 0;

      gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
      gl.uniform1f(uniforms.time, params.time);
      gl.uniform1i(uniforms.geometryType, Math.round(params.geometryType));
      gl.uniform1f(uniforms.density, params.density);
      gl.uniform1f(uniforms.chaos, params.chaos);
      gl.uniform1f(uniforms.hue, params.hue);
      gl.uniform1f(uniforms.intensity, params.intensity);
      gl.uniform1f(uniforms.impulse, params.impulse);

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }
    render();
  </script>

  <!--
  Visual Codex Pattern: Holographic Visualizer + Impulse + Inverse Density
  Category: Visualizer Systems
  Patterns: 18, 19, 20
  Author: Paul Phillips
  Â© 2025 Clear Seas Solutions LLC
  -->
</body>
</html>
