<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualizer Binding Demo - Visual Codex</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0A0A0B;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }

    .scroll-container {
      height: 500vh;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .content {
      position: relative;
      z-index: 1;
    }

    .section {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
    }

    .glass-card {
      background: rgba(15, 15, 17, 0.6);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 24px;
      padding: 40px;
      max-width: 500px;
      text-align: center;
    }

    .glass-card h2 {
      font-size: 2rem;
      margin-bottom: 16px;
      background: linear-gradient(135deg, #7B3FF2, #4FC3F7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .glass-card p {
      color: rgba(255,255,255,0.7);
      line-height: 1.6;
    }

    .param-display {
      position: fixed;
      top: 40px;
      right: 40px;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 12px;
      font-family: monospace;
      font-size: 12px;
      z-index: 100;
    }

    .param-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin: 4px 0;
    }

    .param-label { color: rgba(255,255,255,0.5); }
    .param-value { color: #4FC3F7; }
  </style>
</head>
<body>
  <canvas id="visualizer"></canvas>

  <div class="param-display">
    <div class="param-row"><span class="param-label">intensity:</span><span class="param-value" id="p-intensity">0.50</span></div>
    <div class="param-row"><span class="param-label">chaos:</span><span class="param-value" id="p-chaos">0.20</span></div>
    <div class="param-row"><span class="param-label">hue:</span><span class="param-value" id="p-hue">180</span></div>
    <div class="param-row"><span class="param-label">density:</span><span class="param-value" id="p-density">1.50</span></div>
  </div>

  <div class="scroll-container">
    <div class="content">
      <section class="section">
        <div class="glass-card">
          <h2>Scroll to Control</h2>
          <p>The WebGL visualizer behind this card responds to scroll position. Watch the parameters change.</p>
        </div>
      </section>

      <section class="section">
        <div class="glass-card">
          <h2>Hue Rotation</h2>
          <p>Colors shift through the spectrum as you scroll, mapped from 0° to 360°.</p>
        </div>
      </section>

      <section class="section">
        <div class="glass-card">
          <h2>Chaos Increase</h2>
          <p>The fractal mutation intensity increases, creating more complex patterns.</p>
        </div>
      </section>

      <section class="section">
        <div class="glass-card">
          <h2>Intensity Peak</h2>
          <p>Brightness reaches maximum as the visualization becomes fully active.</p>
        </div>
      </section>

      <section class="section">
        <div class="glass-card">
          <h2>Pattern Complete</h2>
          <p>Pattern 08 & 12: Visualizer Parameter Morphing with Percentage Binding</p>
        </div>
      </section>
    </div>
  </div>

  <script>
    gsap.registerPlugin(ScrollTrigger);

    // WebGL Visualizer
    const canvas = document.getElementById('visualizer');
    const gl = canvas.getContext('webgl2');

    const params = {
      intensity: 0.5,
      chaos: 0.2,
      hue: 0.5,
      density: 1.5,
      time: 0
    };

    // Shader sources
    const vertexSource = `#version 300 es
      in vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const fragmentSource = `#version 300 es
      precision highp float;
      uniform vec2 resolution;
      uniform float time;
      uniform float intensity;
      uniform float chaos;
      uniform float hue;
      uniform float density;
      out vec4 fragColor;

      vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
      }

      float noise(vec2 p) {
        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
      }

      void main() {
        vec2 uv = gl_FragCoord.xy / resolution;
        vec2 center = uv - 0.5;

        float dist = length(center);
        float angle = atan(center.y, center.x);

        float wave = sin(dist * 10.0 - time * 2.0 + chaos * 5.0);
        wave += sin(angle * 6.0 + time) * chaos;
        wave = wave * 0.5 + 0.5;

        float glow = 1.0 / (1.0 + dist * dist * density * 3.0);

        vec3 color = hsv2rgb(vec3(
          hue + wave * 0.1,
          0.7,
          intensity * glow * (0.5 + wave * 0.5)
        ));

        // Vignette
        color *= 1.0 - dist * 0.5;

        fragColor = vec4(color, 1.0);
      }
    `;

    // Compile shader
    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      return shader;
    }

    // Setup
    const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    // Geometry
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const uniforms = {
      resolution: gl.getUniformLocation(program, 'resolution'),
      time: gl.getUniformLocation(program, 'time'),
      intensity: gl.getUniformLocation(program, 'intensity'),
      chaos: gl.getUniformLocation(program, 'chaos'),
      hue: gl.getUniformLocation(program, 'hue'),
      density: gl.getUniformLocation(program, 'density')
    };

    // Resize
    function resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    resize();
    window.addEventListener('resize', resize);

    // Render loop
    function render() {
      params.time += 0.016;

      gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
      gl.uniform1f(uniforms.time, params.time);
      gl.uniform1f(uniforms.intensity, params.intensity);
      gl.uniform1f(uniforms.chaos, params.chaos);
      gl.uniform1f(uniforms.hue, params.hue);
      gl.uniform1f(uniforms.density, params.density);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Update display
      document.getElementById('p-intensity').textContent = params.intensity.toFixed(2);
      document.getElementById('p-chaos').textContent = params.chaos.toFixed(2);
      document.getElementById('p-hue').textContent = Math.round(params.hue * 360);
      document.getElementById('p-density').textContent = params.density.toFixed(2);

      requestAnimationFrame(render);
    }
    render();

    // Scroll binding
    ScrollTrigger.create({
      trigger: ".scroll-container",
      start: "top top",
      end: "bottom bottom",
      onUpdate: (self) => {
        const p = self.progress;

        // Linear mappings
        params.hue = p;                           // 0 to 1 (0° to 360°)
        params.intensity = 0.4 + (p * 0.6);       // 0.4 to 1.0
        params.chaos = 0.2 + (p * 0.5);           // 0.2 to 0.7
        params.density = 2.0 - (p * 1.2);         // 2.0 to 0.8 (inverse)
      }
    });
  </script>

  <!--
  Visual Codex Pattern: Visualizer Parameter Morphing
  Category: GSAP Scroll Choreography
  Patterns: 08, 12
  Author: Paul Phillips
  © 2025 Clear Seas Solutions LLC
  -->
</body>
</html>
