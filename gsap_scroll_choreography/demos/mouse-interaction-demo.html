<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern 15: Mouse Interaction Binding - Visual Codex</title>

    <!-- GSAP from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0f;
            color: #e8e8f0;
            overflow: hidden;
            cursor: none;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 1rem 2rem;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.2rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-link {
            color: #e8e8f0;
            text-decoration: none;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 1;
        }

        /* WebGL Canvas */
        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Custom Cursor */
        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.8), rgba(118, 75, 162, 0.4));
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            mix-blend-mode: screen;
            transition: transform 0.1s ease;
        }

        /* Controls Panel */
        .controls {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 1rem;
            padding: 1rem;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 12px;
        }

        .mode-btn {
            padding: 0.5rem 1rem;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 6px;
            color: #e8e8f0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.875rem;
        }

        .mode-btn:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: rgba(102, 126, 234, 0.6);
            border-color: rgba(102, 126, 234, 0.8);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            top: 6rem;
            left: 2rem;
            z-index: 1000;
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 300px;
        }

        .info-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #a8b2ff;
        }

        .info-text {
            font-size: 0.875rem;
            line-height: 1.5;
            opacity: 0.8;
        }

        /* Click Ripple Effect */
        .ripple {
            position: fixed;
            border: 2px solid rgba(102, 126, 234, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
        }

        /* Mobile Instructions */
        @media (max-width: 768px) {
            body { cursor: auto; }
            .cursor { display: none; }
            
            .mobile-notice {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1000;
                text-align: center;
                background: rgba(10, 10, 15, 0.9);
                padding: 2rem;
                border-radius: 12px;
                border: 1px solid rgba(102, 126, 234, 0.2);
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <a href="../index.html" class="back-link">‚Üê Back to GSAP Patterns</a>
        <h1>Pattern 15: Mouse Interaction Binding</h1>
    </div>

    <!-- WebGL Canvas -->
    <canvas id="webgl-canvas"></canvas>

    <!-- Custom Cursor -->
    <div class="cursor" id="cursor"></div>

    <!-- Info Panel -->
    <div class="info-panel">
        <div class="info-title">üåê 4D Mouse Control</div>
        <div class="info-text">
            Move your mouse to control 4D geometry rotation.
            Click to trigger impulse effects.
            Switch modes below to explore different interactions.
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="mode-btn active" data-mode="orbital">Orbital</button>
        <button class="mode-btn" data-mode="tilt">Tilt</button>
        <button class="mode-btn" data-mode="distort">Distort</button>
        <button class="mode-btn" data-mode="color">Color</button>
    </div>

    <!-- Mobile Notice -->
    <div class="mobile-notice" style="display: none;">
        <h3>Touch Device Detected</h3>
        <p>This demo works best with mouse control on desktop.</p>
        <p>Touch and drag to interact with the 4D geometry.</p>
    </div>

    <script>
        // ============================================
        // MOUSE INTERACTION BINDING DEMO
        // Pattern 15 - Visual Codex
        // ============================================

        // WebGL Setup
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Vertex Shader
        const vertexSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // Fragment Shader - 4D Geometry with Mouse Control
        const fragmentSource = `
            precision highp float;

            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec2 uMouse;
            uniform float uClickImpulse;
            uniform int uMode;

            #define PI 3.14159265359

            // 4D rotation matrices
            mat2 rot2D(float a) {
                float c = cos(a), s = sin(a);
                return mat2(c, -s, s, c);
            }

            // 4D to 3D projection
            vec3 project4D(vec4 p4d) {
                float w = 2.0;
                return p4d.xyz / (w - p4d.w);
            }

            // Signed Distance Functions for 4D shapes
            float sd4DTesseract(vec4 p, float s) {
                vec4 d = abs(p) - s;
                return min(max(max(max(d.x, d.y), d.z), d.w), 0.0) + 
                       length(max(d, 0.0));
            }

            float sd4DSphere(vec4 p, float r) {
                return length(p) - r;
            }

            // Main 4D geometry function
            float map4D(vec4 p) {
                vec4 pos = p;
                
                // Mouse-controlled rotations
                float mouseX = (uMouse.x - 0.5) * 2.0;
                float mouseY = (uMouse.y - 0.5) * 2.0;
                
                // Apply 4D rotations based on mode
                if (uMode == 0) { // Orbital
                    pos.xy *= rot2D(mouseX * PI);
                    pos.zw *= rot2D(mouseY * PI);
                } else if (uMode == 1) { // Tilt
                    pos.xz *= rot2D(mouseX * PI);
                    pos.yw *= rot2D(mouseY * PI);
                } else if (uMode == 2) { // Distort
                    pos.xw *= rot2D(mouseX * PI * 0.5);
                    pos.yz *= rot2D(mouseY * PI * 0.5);
                } else if (uMode == 3) { // Color
                    pos.xy *= rot2D(uTime * 0.5 + mouseX);
                    pos.zw *= rot2D(uTime * 0.3 + mouseY);
                }
                
                // Click impulse effect
                float impulse = uClickImpulse;
                pos *= 1.0 + impulse * 0.2;
                
                // Combine multiple 4D shapes
                float d1 = sd4DTesseract(pos, 0.5);
                float d2 = sd4DSphere(pos + vec4(sin(uTime) * 0.3, cos(uTime) * 0.3, 0.0, 0.0), 0.3);
                
                return min(d1, d2);
            }

            // Ray marching in 4D space
            float rayMarch4D(vec4 ro, vec4 rd) {
                float t = 0.0;
                for (int i = 0; i < 64; i++) {
                    vec4 pos = ro + rd * t;
                    float d = map4D(pos);
                    
                    if (d < 0.001 || t > 10.0) break;
                    t += d * 0.8;
                }
                return t;
            }

            // Calculate normal in 4D
            vec4 calcNormal4D(vec4 p) {
                vec2 e = vec2(0.001, 0.0);
                return normalize(vec4(
                    map4D(p + e.xyxx) - map4D(p - e.xyxx),
                    map4D(p + e.yxyx) - map4D(p - e.yxyx),
                    map4D(p + e.yyxy) - map4D(p - e.yyxy),
                    map4D(p + e.yyyx) - map4D(p - e.yyyx)
                ));
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / min(uResolution.x, uResolution.y);

                // 4D ray setup
                vec4 ro = vec4(0.0, 0.0, -3.0, 0.0);
                vec4 rd = normalize(vec4(uv, 1.0, 0.0));

                // Ray march
                float t = rayMarch4D(ro, rd);
                vec4 pos4d = ro + rd * t;

                // Project to 3D for lighting calculations
                vec3 pos3d = project4D(pos4d);
                vec4 normal4d = calcNormal4D(pos4d);
                vec3 normal3d = normalize(project4D(normal4d));

                // Base color
                vec3 col = vec3(0.05, 0.05, 0.1);

                if (t < 10.0) {
                    // Mouse-influenced coloring
                    float mouseInfluence = length(uMouse - 0.5) * 2.0;
                    
                    vec3 baseColor;
                    if (uMode == 0) { // Orbital - blue to purple
                        baseColor = mix(vec3(0.4, 0.6, 1.0), vec3(0.8, 0.4, 1.0), mouseInfluence);
                    } else if (uMode == 1) { // Tilt - green to cyan
                        baseColor = mix(vec3(0.4, 1.0, 0.6), vec3(0.4, 1.0, 1.0), mouseInfluence);
                    } else if (uMode == 2) { // Distort - red to orange
                        baseColor = mix(vec3(1.0, 0.4, 0.4), vec3(1.0, 0.8, 0.4), mouseInfluence);
                    } else { // Color mode - rainbow
                        float hue = uMouse.x * 6.28318 + uTime;
                        baseColor = vec3(
                            sin(hue) * 0.5 + 0.5,
                            sin(hue + 2.094) * 0.5 + 0.5,
                            sin(hue + 4.188) * 0.5 + 0.5
                        );
                    }

                    // Lighting
                    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
                    float diff = max(dot(normal3d, lightDir), 0.0);
                    float spec = pow(max(dot(reflect(-lightDir, normal3d), normalize(-pos3d)), 0.0), 32.0);

                    // Click impulse glow
                    float glow = uClickImpulse * 2.0;
                    
                    col = baseColor * (diff * 0.7 + 0.3);
                    col += baseColor * spec * 0.8;
                    col += baseColor * glow;
                    
                    // Distance fog
                    col = mix(col, vec3(0.05, 0.05, 0.1), smoothstep(5.0, 10.0, t));
                }

                // Mouse proximity effect
                vec2 mousePos = uMouse * uResolution;
                vec2 fragPos = gl_FragCoord.xy;
                float mouseDist = length(fragPos - mousePos);
                float mouseGlow = exp(-mouseDist * 0.001) * 0.1;
                col += vec3(0.4, 0.6, 1.0) * mouseGlow;

                // Vignette
                float vignette = 1.0 - length(uv) * 0.5;
                col *= vignette;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Compile shaders and create program
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Set up geometry
        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const position = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const uTime = gl.getUniformLocation(program, 'uTime');
        const uResolution = gl.getUniformLocation(program, 'uResolution');
        const uMouse = gl.getUniformLocation(program, 'uMouse');
        const uClickImpulse = gl.getUniformLocation(program, 'uClickImpulse');
        const uMode = gl.getUniformLocation(program, 'uMode');

        // Mouse and interaction state
        let mouseX = 0.5;
        let mouseY = 0.5;
        let clickImpulse = 0;
        let currentMode = 0;

        const cursor = document.getElementById('cursor');

        // Mouse movement tracking with GSAP smoothing
        let targetMouseX = 0.5;
        let targetMouseY = 0.5;

        gsap.ticker.add(() => {
            mouseX = gsap.utils.interpolate(mouseX, targetMouseX, 0.1);
            mouseY = gsap.utils.interpolate(mouseY, targetMouseY, 0.1);
            clickImpulse *= 0.9; // Decay click impulse
        });

        document.addEventListener('mousemove', (e) => {
            targetMouseX = e.clientX / window.innerWidth;
            targetMouseY = 1.0 - (e.clientY / window.innerHeight);
            
            // Update custom cursor
            gsap.to(cursor, {
                x: e.clientX - 10,
                y: e.clientY - 10,
                duration: 0.1,
                ease: "power2.out"
            });
        });

        document.addEventListener('click', (e) => {
            clickImpulse = 1.0;
            
            // Create ripple effect
            createRipple(e.clientX, e.clientY);
            
            // Cursor click animation
            gsap.to(cursor, {
                scale: 1.5,
                duration: 0.1,
                yoyo: true,
                repeat: 1,
                ease: "power2.inOut"
            });
        });

        // Ripple effect
        function createRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = (x - 25) + 'px';
            ripple.style.top = (y - 25) + 'px';
            ripple.style.width = '50px';
            ripple.style.height = '50px';
            document.body.appendChild(ripple);

            gsap.fromTo(ripple, 
                { scale: 0, opacity: 1 },
                { 
                    scale: 3, 
                    opacity: 0, 
                    duration: 0.6,
                    ease: "power2.out",
                    onComplete: () => ripple.remove()
                }
            );
        }

        // Mode switching
        document.querySelectorAll('.mode-btn').forEach((btn, index) => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = index;
                
                // Update info panel
                const infoTexts = [
                    'Move mouse to control orbital 4D rotation. XY controls XY plane, mouse Y controls ZW plane.',
                    'Mouse controls tilt rotations. XZ and YW plane rotations for complex 4D tilting effects.',
                    'Distortion mode - XW and YZ rotations create warping effects in 4D space.',
                    'Color mode - Mouse position controls hue and time-based rainbow cycling.'
                ];
                
                document.querySelector('.info-text').textContent = infoTexts[index];
            });
        });

        // Touch support for mobile
        let isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
            document.querySelector('.mobile-notice').style.display = 'block';
            
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                targetMouseX = touch.clientX / window.innerWidth;
                targetMouseY = 1.0 - (touch.clientY / window.innerHeight);
            });

            document.addEventListener('touchstart', (e) => {
                clickImpulse = 1.0;
                const touch = e.touches[0];
                createRipple(touch.clientX, touch.clientY);
            });
        }

        // Animation loop
        let startTime = performance.now();

        function render() {
            const time = (performance.now() - startTime) / 1000;

            gl.uniform1f(uTime, time);
            gl.uniform2f(uResolution, canvas.width, canvas.height);
            gl.uniform2f(uMouse, mouseX, mouseY);
            gl.uniform1f(uClickImpulse, clickImpulse);
            gl.uniform1i(uMode, currentMode);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        render();

        console.log('%c Mouse Interaction Binding Demo ', 
            'background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 10px; font-size: 16px;');
        console.log('Pattern 15 - Visual Codex | Move mouse to control 4D geometry rotation');
    </script>

    <!--
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë  Visual Codex Pattern 15: Mouse Interaction Binding         ‚ïë
    ‚ïë  Category: Interactive & WebGL Integration                   ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  üåü A Paul Phillips Manifestation                            ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  Features:                                                   ‚ïë
    ‚ïë  ‚Ä¢ WebGL shader with 4D rotation matrices                    ‚ïë
    ‚ïë  ‚Ä¢ Mouse position controls geometry rotation                 ‚ïë
    ‚ïë  ‚Ä¢ Click impulse triggers breathing effects                  ‚ïë
    ‚ïë  ‚Ä¢ 4 interaction modes: Orbital, Tilt, Distort, Color       ‚ïë
    ‚ïë  ‚Ä¢ GSAP-smoothed mouse tracking                              ‚ïë
    ‚ïë  ‚Ä¢ Custom cursor with click animations                       ‚ïë
    ‚ïë  ‚Ä¢ Touch support for mobile devices                          ‚ïë
    ‚ïë  ‚Ä¢ Real-time 4D to 3D projection                             ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë  ¬© 2025 Paul Phillips - Clear Seas Solutions LLC             ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    -->
</body>
</html>